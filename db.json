{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/apple-touch-icon-next.png","path":"apple-touch-icon-next.png","modified":0,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/favicon-16x16-next.png","path":"favicon-16x16-next.png","modified":0,"renderable":0},{"_id":"source/favicon-32x32-next.png","path":"favicon-32x32-next.png","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/apple-touch-icon-next.png","hash":"c266d095254c2ecf850eaeb62d88c4ce8f8fb4fe","modified":1756720441772},{"_id":"source/apple-touch-icon.png","hash":"e44fd3956c7862abc338dea31bd67a3da1a1fd38","modified":1756720441773},{"_id":"source/favicon-16x16-next.png","hash":"e8ee25327bb2b79a6bbb62e74561cf03f4279cde","modified":1756720441774},{"_id":"source/favicon-32x32-next.png","hash":"9cf025d60a59a5a7258097e504ba3304235f39dc","modified":1756720441775},{"_id":"source/favicon.ico","hash":"3f528435ae38be537b7b7ea2903dfd7c3ce8cd50","modified":1756720441775},{"_id":"source/_posts/01-Git.md","hash":"e68c1de0ab6f0bdf32e3afb2bc1677e8db96ba32","modified":1756720441759},{"_id":"source/_posts/01_1-CI-CD.md","hash":"c803f82ae2593ecdc98796114f4fe74c65c232e1","modified":1756720441759},{"_id":"source/_posts/02-微数据和JSON-LD.md","hash":"4915ef569e05f7cc3a1287682547c79853e7a56e","modified":1756720441761},{"_id":"source/_posts/03-模块.md","hash":"6ccfaf2d1c6aba4f2c15d738067f58bbdb8fd0f3","modified":1756720441761},{"_id":"source/_posts/01_2-git的相关命令.md","hash":"2f2b8bf453949390108eec935bea803216b16e97","modified":1756720441760},{"_id":"source/_posts/03_1模块中桶文件的问题.md","hash":"a77978b7573ee9a71ede2dee5e0a4639ab7d7024","modified":1756720441762},{"_id":"source/_posts/04-npm vs pnpm.md","hash":"d63f0aca637e016796a0150aa19582424eb6408b","modified":1756720441763},{"_id":"source/_posts/04-npm.md","hash":"1183b1a4c319944907bc48cbeeb4991de591146d","modified":1756720441764},{"_id":"source/_posts/04_1-npm 包上传机制.md","hash":"5a19f50197dbe6ac089196a1b386728ab51ef52b","modified":1756720441765},{"_id":"source/_posts/04_2-npm入口.md","hash":"6737e0977c68d2fc710a5db06fc2c5cbcc81e7a4","modified":1756720441766},{"_id":"source/_posts/04_3-npm开发库 本地测试的几种方案.md","hash":"5efbcb823bb7bbfa58b49652b17d665678604187","modified":1756720441766},{"_id":"source/_posts/04_4-npm workspace.md","hash":"4e89fee3f31c152b626a825d8e4e5ed3cb97ec63","modified":1756720441768},{"_id":"source/_posts/05-Monorepo（单一代码仓库）.md","hash":"e7f93d324370d0f850f70934672f762c22a09f27","modified":1756720441769},{"_id":"source/_posts/06-flle协议.md","hash":"50ef6ceb84e1e8c1582315679389e26380822ca3","modified":1756720441770},{"_id":"source/_posts/07-软链接和硬链接.md","hash":"63484324225e0cfed1173253ed844fe1dc51deb1","modified":1756720441771},{"_id":"source/_posts/css_display.md","hash":"a8b7602e1ea71b675ea3a3b38c5982c731076f13","modified":1756782331694},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1756775451055},{"_id":"node_modules/hexo-theme-next/README.md","hash":"6f1bf93dbccc8545872fe27b4693fda59cdbfb89","modified":1756775451064},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"94ae5888e628f7f67f776e4296cf8dae8bc25fd5","modified":1756775451675},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"5c6d3f23d65b77717d1b3e7b5575104f7d41b056","modified":1756775451677},{"_id":"node_modules/hexo-theme-next/package.json","hash":"81c9f00b10b811c0485c00a2d7810e525f0b0e93","modified":1756775451029},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1756775451039},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1756775451043},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1756775451667},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"b17d44bd7379c23241053a0b7fbd38c9c43cc239","modified":1756775451069},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1756775451076},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1756775451097},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"af6d7570621be760536c216a56d74e40a1cceae2","modified":1756775451195},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1756775451163},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1756775451226},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1756775451237},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1756775451063},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1756775451700},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"564bed75da6e05b11dce6164508f97a15e2fb6c2","modified":1756775451697},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1756775451694},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1756775451703},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1756775451709},{"_id":"node_modules/hexo-theme-next/languages/eo.yml","hash":"e34bb33ae827bf2f0727088599a73bc64bdad1b0","modified":1756775451705},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1756775451735},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1756775451728},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1756775451738},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1756775451740},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1756775451742},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"8ac44e58f71a38b7697a2f7f98a6971ed818cb5b","modified":1756775451731},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1756775451744},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1756775451746},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"b62faaa767a45a613dd042b5f1903675eb5a8cf9","modified":1756775451748},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1756775451756},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1756775451754},{"_id":"node_modules/hexo-theme-next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1756775451758},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1756775451763},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1756775451767},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1756775451774},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1756775451776},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1756775451779},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"5c0f00cdac3f4727b880dd223f622a535736fa8e","modified":1756775451788},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"8eb6a9f231ce1bfa54cc54418ccf14f01dcc9a31","modified":1756775451783},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"30e929e1138445534a6f46d64667c17273337acf","modified":1756775451058},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"12a6631617695504d5cf2a94b57d87bd331bef6f","modified":1756775451047},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1756775451053},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"93064dbd1a461d55c7c07a04626294c8150b4d1b","modified":1756775451060},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"313637fe3569f98fd926e8cd0fcc75d098eb6e6e","modified":1756775451200},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"ec9bb9c5ede773c02f0c8d8475245a8a437a2b71","modified":1756775451225},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"85f3a2ab22601a9606f2f630289db1363b98018f","modified":1756775451231},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1756775451109},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"fbf8232cacf0df87e88e74860be66c9f86018302","modified":1756775451124},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1756775451172},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1756775451196},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"d83fb59f02c5e6630a7770401a05c02f6f07358b","modified":1756775451247},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"2a7dfffebad19b67dc9e3b2a6b2986d0630ef930","modified":1756775451153},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"7261e24287984853c8ef08cda8bbc80cacf9bd6f","modified":1756775451245},{"_id":"node_modules/hexo-theme-next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1756775451072},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1756775451117},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"dfd7cdd6ba89f8c3deabc27726c7a350cadafd11","modified":1756775451156},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1756775451192},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1756775451227},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1756775450900},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1756775450839},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1756775450932},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"2063aaa1db448ebcf7b0fdbbc54d3991a368bbd3","modified":1756775450951},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1756775450989},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"83235f2879567eb8686431c9554a4b99f14ab665","modified":1756775450857},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"4c84d45daac86396edf656d2a8abe6e7583491ea","modified":1756775450873},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1756775450957},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"4bc2eb87f3fa26981652f517d1ab3f81de2ab89d","modified":1756775450962},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1756775450964},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"6281d47c1de98eb38f3aa0f6df29bbb19d412173","modified":1756775450966},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"af3946a595f997eb43d9af87428e4898c9acbc82","modified":1756775450972},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1756775450765},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1756775450776},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1756775450772},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"f57f7e09eb6220f681fa8385082b0960502ce5c4","modified":1756775450890},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1756775450904},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1756775450918},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1756775450923},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"7d7bbc4a9970bd4c5449bc71b94364a8ec61e5d2","modified":1756775450941},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1756775450974},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1756775450977},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1756775450997},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1756775451021},{"_id":"node_modules/hexo-theme-next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1756775451025},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"ebfe0954e3931431f46f913abe08d0212e06e7c2","modified":1756775451256},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"e21309d4165ebb6645084eed8dd749846ae981f1","modified":1756775451277},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1756775451553},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1756775451526},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1756775450688},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1756775451249},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1756775451252},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"a38c6d92b368bfc42c72ad799ad03f3274957065","modified":1756775451658},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1756775451253},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1756775451660},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"9ba4cceafd12c6d5ba8a6b986a046ef8319a7811","modified":1756775450756},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1756775450807},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1756775450811},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1756775450826},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"6f751f5c9499a39d7c5e1d323db3260342dd9431","modified":1756775450953},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"d434a2a8543fb09245eaf2bc6ca123435bfa4dbb","modified":1756775450960},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"694b271819aab37ce473b15db9e6aded971d82e5","modified":1756775450982},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"9c41a73ed3e8db8ca4cb53633b6f616279a5a7bd","modified":1756775450993},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","hash":"2ee359ae48273b01ba1e0768704524e08702c7eb","modified":1756775450995},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"6734719bb74e4d9818992b0e4a745c2a1aefd5e2","modified":1756775451006},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"93c1d103d9d16581c944c51f3d0638f57c80ee41","modified":1756775451141},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1756775451144},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1756775451088},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1756775451185},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1756775451146},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1756775451187},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1756775451235},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1756775451091},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1756775451095},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1756775451193},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1756775451228},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1756775451239},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"bfff923526d6800218f08dba6ce0bbf5c17755fd","modified":1756775451209},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1756775451212},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1756775451211},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1756775451214},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1756775451215},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-share.njk","hash":"16696990e4ce65fc8db18c4635082a5d5d06ff07","modified":1756775451222},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"bc5708e38b6070dff0cab6bf9480971017ce4dda","modified":1756775451233},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"6ad43135bd3aecf933ffdd750763e27ade36f97c","modified":1756775451148},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1756775451081},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1756775451106},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1756775451127},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1756775451137},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1756775451155},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1756775451182},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"1efeeda00db08a3c033798228dd0092ee532cc36","modified":1756775451190},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1756775451198},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1756775451242},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1756775451104},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1756775451240},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1756775451100},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1756775451112},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1756775451113},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1756775451125},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1756775451165},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1756775451176},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1756775451243},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1756775451160},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1756775451168},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1756775451181},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1756775451179},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"41b28f05e6233fb37700f7151f55868be10a0965","modified":1756775451074},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1756775451188},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1756775451197},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1756775451246},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"55c2468b2b7f035881d494085527d6554f37b556","modified":1756775451094},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1756775451161},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1756775451174},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1756775451122},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"00af4f5f9a79eaccf051f9e372d233d65d44c8a5","modified":1756775450823},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1756775450955},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"8a8f752260be5b8098393f9879b61ffe904465e8","modified":1756775450896},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1756775450906},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"5942feb3f31ed3480bf50b0f5a4a305b5bdca3d6","modified":1756775451003},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"e2b4a9d6b08155735ec336eedc506763d5671821","modified":1756775451018},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1756775450788},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1756775450813},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1756775450831},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1756775450842},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1756775450848},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1756775450879},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1756775450908},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1756775450924},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1756775451007},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1756775451324},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"2c800eaab6c613e5d091be2111aaa786641aa0c2","modified":1756775451539},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"879b49f693af0c04c285b2dd0c9cccaf77347b7c","modified":1756775451545},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"20d5c6aa136bbb55e03906d98ee90ad3fbaa80a7","modified":1756775451575},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"b724edca546373d5eaf9b3602868f971c9094cf6","modified":1756775451296},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","hash":"a772605646dcfb67620a10ee8ef23c38a6d19d80","modified":1756775450709},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1756775450861},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1756775450976},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1756775450991},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"b8445c828d78a38e2de50bdc86b3bff66285ea0f","modified":1756775451290},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1756775451336},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1756775451601},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1756775451349},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"48b2dfc04df6409c6e0736ccc11462ad97d349b1","modified":1756775451542},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"f316ba87f8d3299677fbf8345e1e993c35210e2e","modified":1756775451293},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1756775451308},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1756775451312},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1756775451438},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1756775451548},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1756775451561},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1756775451640},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"69c66aab4651e2e7ae9e65f08600144970648c60","modified":1756775451646},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1756775451261},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"bcbf498d8d3ecea84324f0a59b7f95f389a52b8d","modified":1756775451470},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1756775451267},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"e31f6adbb22a451f07e4661cff9a2f12e4e99a36","modified":1756775451273},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"c29a827e82d2820ed8977c92994da73721200fac","modified":1756775451280},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1756775451285},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1756775451477},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1756775451259},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1756775451265},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"f23c53e32d140091b819be2603d1afbbb5d66933","modified":1756775451271},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1756775451278},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1756775451475},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"dc03835e42d82eaf2633cf3b627990ad3e1f5967","modified":1756775451264},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"a03f16ffc7dfdbdc6053f9fd68d77257ba0c559e","modified":1756775451274},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"a92c4eb16bdb7806079467eb022ccf193bb0f794","modified":1756775451269},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e792a6233e1d4dbc5fd2f10ae97b7a790b82568b","modified":1756775451282},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1756775451287},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1756775451479},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1756775450745},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1756775450887},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1756775450938},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1756775450893},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1756775450999},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1756775450799},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"6c65d5a585b7dd75e5f0fa6ef2dc85d0bcd1e58f","modified":1756775450794},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"3631db0315bdeaa420091a9febb6fa3421a2bdb4","modified":1756775450845},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"e01b42846ffcabc676c3bdd9d89e8cafc084e20b","modified":1756775450852},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"03eb13679fc701c2ab91e502ccd26aacc37e7999","modified":1756775450883},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"917d1a2bbae6cc8817ce37abc17800b1740b2517","modified":1756775450911},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"e35e5a90a70a96117509368423726c6a56041ea2","modified":1756775450926},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"743f389fc5669e486c8804d7199a11542ff9bc11","modified":1756775451016},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1756775450914},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1756775450936},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"6b3fa841e48d8637a33530dd48c8ab1ef317323c","modified":1756775450727},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"3968d972f47b79acc6c3fe44028bad77c9c5aab7","modified":1756775450930},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"ae1c0c6c079594936de1aea756eb58992f8fb0e0","modified":1756775450946},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"7e6ad201d2c9d682261209db5dba07e9608fb42a","modified":1756775450980},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","hash":"71efb52a4c44c64c2b17edd4638d54ec884bd4c7","modified":1756775451027},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"fec1c5c913237112b2cc6fb7d1e73b789bf508f8","modified":1756775450871},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"171889aaab60704f87cfe9a05871f493ac292b47","modified":1756775450921},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1756775451307},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"51a97a33879289904cb523ddc2d88b5b0c60fa72","modified":1756775451310},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1756775451337},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1756775451606},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1756775451644},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1756775451340},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"93f014809d6442da23f8b7d729f7375e2badba7d","modified":1756775451577},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"809bab3414b1eb1ae44444eb821126868f764414","modified":1756775451579},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"026cd5735fd2a75bb60b7bf8bd09139583d602b9","modified":1756775451585},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"bb089299f87793bd5eff80c6375d4e796367b67b","modified":1756775451587},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"424de4f64b12c521e8c6bfbc711d7961490ab36e","modified":1756775451591},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1756775451589},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1756775451593},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"b47fb36915962309553ff7fb1782341585ed2b76","modified":1756775451595},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1756775451598},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1756775451320},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1756775451326},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"54d12e2c5d9982f7b9e5b23be5133954a8514e9d","modified":1756775451341},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1756775451529},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"1874e2b5d86cdeeaf2ccdc2669146a2b0c72d9db","modified":1756775451608},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1756775451653},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1756775451304},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1756775451344},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1756775451330},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1756775451345},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"a3dd3edea9c01b66b28a8367185269b9dcc3bdee","modified":1756775451533},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1756775451630},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1756775451633},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"21acb11e397526132605eef23bde7b307aa1eab5","modified":1756775451431},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"0847400d8579b0a2dd1bf662c78954c10adf2680","modified":1756775451610},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1756775451604},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1756775451611},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"46eece42510c2c89bb9209afb0262ad76a4b0b36","modified":1756775451620},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"ce36bf1602233298e0351b4babc592315529eb26","modified":1756775451617},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-copyright.styl","hash":"56805b77fe236fac19e19c716a49363bcf986311","modified":1756775451623},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1756775451625},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1756775451627},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"741566d6ac5f852b5c8dee6a8996b65e48e7c97f","modified":1756775451629},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1756775451636},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"5c31f3a86e4e6fbf2f8419415620461fa8a63c56","modified":1756775451315},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"9b0217e1caecd91e05572c7e8e52d32016ca312f","modified":1756775451435},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/fold.styl","hash":"42a0b65491ad85438596b3fe0b7f23973e4cef34","modified":1756775451322},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1756775451300},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1756775451332},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1756775451439},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1756775451487},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"49329a7144f3413d1c832e52a1f4954171ef11e1","modified":1756775451508},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1756775451537},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"8213015d9cae45d2c9945f8aba9d8db39c734efc","modified":1756775451559},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1756775451572},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"c3be8b0738f693e750486bb71769c3dbbec174cc","modified":1756775451642},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1756775451655},{"_id":"source/_posts/CI-CD.md","hash":"c803f82ae2593ecdc98796114f4fe74c65c232e1","modified":1756720441759},{"_id":"source/_posts/Git.md","hash":"e68c1de0ab6f0bdf32e3afb2bc1677e8db96ba32","modified":1756720441759},{"_id":"source/_posts/flle协议.md","hash":"50ef6ceb84e1e8c1582315679389e26380822ca3","modified":1756720441770},{"_id":"source/_posts/Monorepo（单一代码仓库）.md","hash":"e7f93d324370d0f850f70934672f762c22a09f27","modified":1756720441769},{"_id":"source/_posts/git的相关命令.md","hash":"2f2b8bf453949390108eec935bea803216b16e97","modified":1756720441760},{"_id":"source/_posts/npm vs pnpm.md","hash":"d63f0aca637e016796a0150aa19582424eb6408b","modified":1756720441763},{"_id":"source/_posts/npm workspace.md","hash":"4e89fee3f31c152b626a825d8e4e5ed3cb97ec63","modified":1756720441768},{"_id":"source/_posts/npm 包上传机制.md","hash":"5a19f50197dbe6ac089196a1b386728ab51ef52b","modified":1756720441765},{"_id":"source/_posts/npm入口.md","hash":"6737e0977c68d2fc710a5db06fc2c5cbcc81e7a4","modified":1756720441766},{"_id":"source/_posts/npm.md","hash":"1183b1a4c319944907bc48cbeeb4991de591146d","modified":1756720441764},{"_id":"source/_posts/微数据和JSON-LD.md","hash":"4915ef569e05f7cc3a1287682547c79853e7a56e","modified":1756720441761},{"_id":"source/_posts/模块.md","hash":"72ddb98b64fb34956599a9fe382ed9c6581c4945","modified":1756783085839},{"_id":"source/_posts/模块中桶文件的问题.md","hash":"a77978b7573ee9a71ede2dee5e0a4639ab7d7024","modified":1756720441762},{"_id":"source/_posts/npm开发库 本地测试的几种方案.md","hash":"5efbcb823bb7bbfa58b49652b17d665678604187","modified":1756720441766},{"_id":"source/_posts/软链接和硬链接.md","hash":"63484324225e0cfed1173253ed844fe1dc51deb1","modified":1756720441771}],"Category":[{"name":"技术","_id":"cmf1z5gfh00008sv9c97t3vo6"}],"Data":[],"Page":[],"Post":[{"title":"css中的display的contents属性","_content":"\n# display 中一个不常用的属性 contents \n\n`display: contents` 是 CSS Display Module Level 3 中引入的一个比较特殊且强大的值。它的作用是：**让一个元素本身不产生任何盒模型（即不渲染），但它的子元素会像直接继承了该元素的父元素一样正常渲染**。\n\n简单来说：**这个元素“消失”了，但它的孩子“冒出来”代替它参与布局**。\n\n---\n\n### 🔍 一、基本语法\n\n```css\n.element {\n  display: contents;\n}\n```\n\n---\n\n### 🧩 二、核心特性\n\n| 特性 | 说明 |\n|------|------|\n| **不渲染自身** | 元素本身不生成任何视觉框（box），即没有背景、边框、大小、定位等。 |\n| **子元素“提升”** | 子元素直接参与父元素的布局，仿佛父元素不存在。 |\n| **保留语义和DOM结构** | DOM 节点仍然存在，JavaScript 和 CSS 选择器仍可访问它。 |\n| **不影响可访问性（需注意）** | 屏幕阅读器仍能读取内容，但布局上“跳过”了该层。 |\n\n---\n\n### ✅ 三、实际例子\n\n#### 示例 1：`display: contents` 的效果\n\n```html\n<div class=\"parent\">\n  <div class=\"wrapper\" style=\"display: contents;\">\n    <p>段落1</p>\n    <p>段落2</p>\n  </div>\n</div>\n```\n\n```css\n.parent {\n  display: flex;\n  gap: 10px;\n  background: #eee;\n  padding: 20px;\n}\n.wrapper {\n  background: red;\n  padding: 10px;\n  border: 1px solid black;\n}\n```\n\n- **没有 `display: contents`**：\n  - `.wrapper` 是一个红色块，包含两个 `<p>`。\n  - 两个 `<p>` 在 `.wrapper` 内部，**不会直接参与 `.parent` 的 flex 布局**。\n\n- **加上 `display: contents`**：\n  - `.wrapper` 的背景、padding、border 全部**消失**。\n  - 两个 `<p>` 直接成为 `.parent` 的 flex item，**直接参与 flex 布局**，间隔 10px，且 `.parent` 的背景可见。\n\n> 💡 效果：`.wrapper` “透明化”，子元素“穿透”上来。\n\n---\n\n### 🎯 四、典型使用场景\n\n#### 1. **绕过不必要的包装容器（Wrapper）**\n当使用某些框架或 CMS 生成了无法修改的嵌套结构时，可以用 `display: contents` “忽略”中间层。\n\n```html\n<!-- 第三方组件生成的结构 -->\n<ul>\n  <li><span class=\"icon\">✅</span> 选项1</li>\n  <li style=\"display: contents;\"> <!-- 去掉这个li的样式影响 -->\n    <span class=\"icon\">❌</span> 选项2（禁用）\n  </li>\n</ul>\n```\n\n可以去掉某个 `<li>` 的布局影响，让其内容直接融入父级。\n\n#### 2. **Grid/Flex 布局中“扁平化”结构**\n\n```html\n<div class=\"grid-container\">\n  <div class=\"item-wrapper\" style=\"display: contents;\">\n    <div class=\"item\">A</div>\n    <div class=\"item\">B</div>\n  </div>\n</div>\n```\n\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n}\n.item {\n  background: blue;\n  color: white;\n}\n```\n\n结果：`.item` 直接成为 grid item，占据两列，而 `.item-wrapper` 不占空间。\n\n#### 3. **与 `::before` / `::after` 配合生成内容**\n由于 `display: contents` 不渲染自身，但子元素可渲染，所以可以配合伪元素“注入”内容而不影响布局。\n\n---\n\n### ⚠️ 五、注意事项与限制\n\n| 问题 | 说明 |\n|------|------|\n| **样式丢失** | 所有应用于该元素的盒模型样式（`background`, `border`, `padding`, `margin`, `width`, `height` 等）**全部失效**。 |\n| **伪元素失效** | `::before` 和 `::after` **不会显示**（因为没有框来承载它们）。 |\n| **可访问性影响** | 虽然内容还在，但结构被“扁平化”，可能影响屏幕阅读器的理解（需测试）。 |\n| **浏览器兼容性** | 大部分现代浏览器支持，但 **IE 完全不支持**。 |\n| | ✅ Chrome 65+, Firefox 63+, Safari 12.1+, Edge 79+ |\n\n---\n\n### 🆚 六、对比其他隐藏方式\n\n| 方式 | 是否占空间 | 子元素是否可见 | 是否渲染 |\n|------|------------|----------------|----------|\n| `display: none` | 否 | 否 | 完全不渲染 |\n| `visibility: hidden` | 是 | 否 | 渲染但不可见 |\n| `opacity: 0` | 是 | 是（透明） | 渲染 |\n| `display: contents` | **否（自身）** | **是（子元素提升）** | **自身不渲染，子元素渲染** |\n\n---\n\n### ✅ 七、总结\n\n`display: contents` 是一个“结构优化”工具，适用于：\n\n- 想去除某个包装元素的视觉样式，但保留其内容。\n- 在 Flex/Grid 布局中避免多余的嵌套层级。\n- 动态调整 DOM 结构的视觉表现，而无需修改 HTML。\n\n> 📌 **一句话总结**：  \n> `display: contents` 让元素“隐身”，但把它的孩子“扶正”，直接参与上一级布局。\n\n虽然使用场景相对小众，但在现代 CSS 布局中，它是一个非常优雅的“去壳”解决方案。","source":"_posts/css_display.md","raw":"---\ntitle: css中的display的contents属性\n---\n\n# display 中一个不常用的属性 contents \n\n`display: contents` 是 CSS Display Module Level 3 中引入的一个比较特殊且强大的值。它的作用是：**让一个元素本身不产生任何盒模型（即不渲染），但它的子元素会像直接继承了该元素的父元素一样正常渲染**。\n\n简单来说：**这个元素“消失”了，但它的孩子“冒出来”代替它参与布局**。\n\n---\n\n### 🔍 一、基本语法\n\n```css\n.element {\n  display: contents;\n}\n```\n\n---\n\n### 🧩 二、核心特性\n\n| 特性 | 说明 |\n|------|------|\n| **不渲染自身** | 元素本身不生成任何视觉框（box），即没有背景、边框、大小、定位等。 |\n| **子元素“提升”** | 子元素直接参与父元素的布局，仿佛父元素不存在。 |\n| **保留语义和DOM结构** | DOM 节点仍然存在，JavaScript 和 CSS 选择器仍可访问它。 |\n| **不影响可访问性（需注意）** | 屏幕阅读器仍能读取内容，但布局上“跳过”了该层。 |\n\n---\n\n### ✅ 三、实际例子\n\n#### 示例 1：`display: contents` 的效果\n\n```html\n<div class=\"parent\">\n  <div class=\"wrapper\" style=\"display: contents;\">\n    <p>段落1</p>\n    <p>段落2</p>\n  </div>\n</div>\n```\n\n```css\n.parent {\n  display: flex;\n  gap: 10px;\n  background: #eee;\n  padding: 20px;\n}\n.wrapper {\n  background: red;\n  padding: 10px;\n  border: 1px solid black;\n}\n```\n\n- **没有 `display: contents`**：\n  - `.wrapper` 是一个红色块，包含两个 `<p>`。\n  - 两个 `<p>` 在 `.wrapper` 内部，**不会直接参与 `.parent` 的 flex 布局**。\n\n- **加上 `display: contents`**：\n  - `.wrapper` 的背景、padding、border 全部**消失**。\n  - 两个 `<p>` 直接成为 `.parent` 的 flex item，**直接参与 flex 布局**，间隔 10px，且 `.parent` 的背景可见。\n\n> 💡 效果：`.wrapper` “透明化”，子元素“穿透”上来。\n\n---\n\n### 🎯 四、典型使用场景\n\n#### 1. **绕过不必要的包装容器（Wrapper）**\n当使用某些框架或 CMS 生成了无法修改的嵌套结构时，可以用 `display: contents` “忽略”中间层。\n\n```html\n<!-- 第三方组件生成的结构 -->\n<ul>\n  <li><span class=\"icon\">✅</span> 选项1</li>\n  <li style=\"display: contents;\"> <!-- 去掉这个li的样式影响 -->\n    <span class=\"icon\">❌</span> 选项2（禁用）\n  </li>\n</ul>\n```\n\n可以去掉某个 `<li>` 的布局影响，让其内容直接融入父级。\n\n#### 2. **Grid/Flex 布局中“扁平化”结构**\n\n```html\n<div class=\"grid-container\">\n  <div class=\"item-wrapper\" style=\"display: contents;\">\n    <div class=\"item\">A</div>\n    <div class=\"item\">B</div>\n  </div>\n</div>\n```\n\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n}\n.item {\n  background: blue;\n  color: white;\n}\n```\n\n结果：`.item` 直接成为 grid item，占据两列，而 `.item-wrapper` 不占空间。\n\n#### 3. **与 `::before` / `::after` 配合生成内容**\n由于 `display: contents` 不渲染自身，但子元素可渲染，所以可以配合伪元素“注入”内容而不影响布局。\n\n---\n\n### ⚠️ 五、注意事项与限制\n\n| 问题 | 说明 |\n|------|------|\n| **样式丢失** | 所有应用于该元素的盒模型样式（`background`, `border`, `padding`, `margin`, `width`, `height` 等）**全部失效**。 |\n| **伪元素失效** | `::before` 和 `::after` **不会显示**（因为没有框来承载它们）。 |\n| **可访问性影响** | 虽然内容还在，但结构被“扁平化”，可能影响屏幕阅读器的理解（需测试）。 |\n| **浏览器兼容性** | 大部分现代浏览器支持，但 **IE 完全不支持**。 |\n| | ✅ Chrome 65+, Firefox 63+, Safari 12.1+, Edge 79+ |\n\n---\n\n### 🆚 六、对比其他隐藏方式\n\n| 方式 | 是否占空间 | 子元素是否可见 | 是否渲染 |\n|------|------------|----------------|----------|\n| `display: none` | 否 | 否 | 完全不渲染 |\n| `visibility: hidden` | 是 | 否 | 渲染但不可见 |\n| `opacity: 0` | 是 | 是（透明） | 渲染 |\n| `display: contents` | **否（自身）** | **是（子元素提升）** | **自身不渲染，子元素渲染** |\n\n---\n\n### ✅ 七、总结\n\n`display: contents` 是一个“结构优化”工具，适用于：\n\n- 想去除某个包装元素的视觉样式，但保留其内容。\n- 在 Flex/Grid 布局中避免多余的嵌套层级。\n- 动态调整 DOM 结构的视觉表现，而无需修改 HTML。\n\n> 📌 **一句话总结**：  \n> `display: contents` 让元素“隐身”，但把它的孩子“扶正”，直接参与上一级布局。\n\n虽然使用场景相对小众，但在现代 CSS 布局中，它是一个非常优雅的“去壳”解决方案。","slug":"css_display","published":1,"date":"2025-09-02T02:14:52.131Z","updated":"2025-09-02T03:05:31.694Z","_id":"cmf1w62m9000eq4v93o2dbcen","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"display-中一个不常用的属性-contents\"><a href=\"#display-中一个不常用的属性-contents\" class=\"headerlink\" title=\"display 中一个不常用的属性 contents\"></a>display 中一个不常用的属性 contents</h1><p><code>display: contents</code> 是 CSS Display Module Level 3 中引入的一个比较特殊且强大的值。它的作用是：<strong>让一个元素本身不产生任何盒模型（即不渲染），但它的子元素会像直接继承了该元素的父元素一样正常渲染</strong>。</p>\n<p>简单来说：<strong>这个元素“消失”了，但它的孩子“冒出来”代替它参与布局</strong>。</p>\n<hr>\n<h3 id=\"🔍-一、基本语法\"><a href=\"#🔍-一、基本语法\" class=\"headerlink\" title=\"🔍 一、基本语法\"></a>🔍 一、基本语法</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.element</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: contents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"🧩-二、核心特性\"><a href=\"#🧩-二、核心特性\" class=\"headerlink\" title=\"🧩 二、核心特性\"></a>🧩 二、核心特性</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>不渲染自身</strong></td>\n<td>元素本身不生成任何视觉框（box），即没有背景、边框、大小、定位等。</td>\n</tr>\n<tr>\n<td><strong>子元素“提升”</strong></td>\n<td>子元素直接参与父元素的布局，仿佛父元素不存在。</td>\n</tr>\n<tr>\n<td><strong>保留语义和DOM结构</strong></td>\n<td>DOM 节点仍然存在，JavaScript 和 CSS 选择器仍可访问它。</td>\n</tr>\n<tr>\n<td><strong>不影响可访问性（需注意）</strong></td>\n<td>屏幕阅读器仍能读取内容，但布局上“跳过”了该层。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"✅-三、实际例子\"><a href=\"#✅-三、实际例子\" class=\"headerlink\" title=\"✅ 三、实际例子\"></a>✅ 三、实际例子</h3><h4 id=\"示例-1：display-contents-的效果\"><a href=\"#示例-1：display-contents-的效果\" class=\"headerlink\" title=\"示例 1：display: contents 的效果\"></a>示例 1：<code>display: contents</code> 的效果</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;display: contents;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">gap</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>**没有 <code>display: contents</code>**：</p>\n<ul>\n<li><code>.wrapper</code> 是一个红色块，包含两个 <code>&lt;p&gt;</code>。</li>\n<li>两个 <code>&lt;p&gt;</code> 在 <code>.wrapper</code> 内部，<strong>不会直接参与 <code>.parent</code> 的 flex 布局</strong>。</li>\n</ul>\n</li>\n<li><p>**加上 <code>display: contents</code>**：</p>\n<ul>\n<li><code>.wrapper</code> 的背景、padding、border 全部<strong>消失</strong>。</li>\n<li>两个 <code>&lt;p&gt;</code> 直接成为 <code>.parent</code> 的 flex item，<strong>直接参与 flex 布局</strong>，间隔 10px，且 <code>.parent</code> 的背景可见。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 效果：<code>.wrapper</code> “透明化”，子元素“穿透”上来。</p>\n</blockquote>\n<hr>\n<h3 id=\"🎯-四、典型使用场景\"><a href=\"#🎯-四、典型使用场景\" class=\"headerlink\" title=\"🎯 四、典型使用场景\"></a>🎯 四、典型使用场景</h3><h4 id=\"1-绕过不必要的包装容器（Wrapper）\"><a href=\"#1-绕过不必要的包装容器（Wrapper）\" class=\"headerlink\" title=\"1. 绕过不必要的包装容器（Wrapper）\"></a>1. <strong>绕过不必要的包装容器（Wrapper）</strong></h4><p>当使用某些框架或 CMS 生成了无法修改的嵌套结构时，可以用 <code>display: contents</code> “忽略”中间层。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 第三方组件生成的结构 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;icon&quot;</span>&gt;</span>✅<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> 选项1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;display: contents;&quot;</span>&gt;</span> <span class=\"comment\">&lt;!-- 去掉这个li的样式影响 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;icon&quot;</span>&gt;</span>❌<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> 选项2（禁用）</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以去掉某个 <code>&lt;li&gt;</code> 的布局影响，让其内容直接融入父级。</p>\n<h4 id=\"2-Grid-Flex-布局中“扁平化”结构\"><a href=\"#2-Grid-Flex-布局中“扁平化”结构\" class=\"headerlink\" title=\"2. Grid&#x2F;Flex 布局中“扁平化”结构\"></a>2. <strong>Grid&#x2F;Flex 布局中“扁平化”结构</strong></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;grid-container&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item-wrapper&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;display: contents;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: grid;</span><br><span class=\"line\">  <span class=\"attribute\">grid-template-columns</span>: <span class=\"number\">1</span>fr <span class=\"number\">1</span>fr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：<code>.item</code> 直接成为 grid item，占据两列，而 <code>.item-wrapper</code> 不占空间。</p>\n<h4 id=\"3-与-before-after-配合生成内容\"><a href=\"#3-与-before-after-配合生成内容\" class=\"headerlink\" title=\"3. 与 ::before &#x2F; ::after 配合生成内容\"></a>3. <strong>与 <code>::before</code> &#x2F; <code>::after</code> 配合生成内容</strong></h4><p>由于 <code>display: contents</code> 不渲染自身，但子元素可渲染，所以可以配合伪元素“注入”内容而不影响布局。</p>\n<hr>\n<h3 id=\"⚠️-五、注意事项与限制\"><a href=\"#⚠️-五、注意事项与限制\" class=\"headerlink\" title=\"⚠️ 五、注意事项与限制\"></a>⚠️ 五、注意事项与限制</h3><table>\n<thead>\n<tr>\n<th>问题</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>样式丢失</strong></td>\n<td>所有应用于该元素的盒模型样式（<code>background</code>, <code>border</code>, <code>padding</code>, <code>margin</code>, <code>width</code>, <code>height</code> 等）<strong>全部失效</strong>。</td>\n</tr>\n<tr>\n<td><strong>伪元素失效</strong></td>\n<td><code>::before</code> 和 <code>::after</code> <strong>不会显示</strong>（因为没有框来承载它们）。</td>\n</tr>\n<tr>\n<td><strong>可访问性影响</strong></td>\n<td>虽然内容还在，但结构被“扁平化”，可能影响屏幕阅读器的理解（需测试）。</td>\n</tr>\n<tr>\n<td><strong>浏览器兼容性</strong></td>\n<td>大部分现代浏览器支持，但 <strong>IE 完全不支持</strong>。</td>\n</tr>\n<tr>\n<td></td>\n<td>✅ Chrome 65+, Firefox 63+, Safari 12.1+, Edge 79+</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"🆚-六、对比其他隐藏方式\"><a href=\"#🆚-六、对比其他隐藏方式\" class=\"headerlink\" title=\"🆚 六、对比其他隐藏方式\"></a>🆚 六、对比其他隐藏方式</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>是否占空间</th>\n<th>子元素是否可见</th>\n<th>是否渲染</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>display: none</code></td>\n<td>否</td>\n<td>否</td>\n<td>完全不渲染</td>\n</tr>\n<tr>\n<td><code>visibility: hidden</code></td>\n<td>是</td>\n<td>否</td>\n<td>渲染但不可见</td>\n</tr>\n<tr>\n<td><code>opacity: 0</code></td>\n<td>是</td>\n<td>是（透明）</td>\n<td>渲染</td>\n</tr>\n<tr>\n<td><code>display: contents</code></td>\n<td><strong>否（自身）</strong></td>\n<td><strong>是（子元素提升）</strong></td>\n<td><strong>自身不渲染，子元素渲染</strong></td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"✅-七、总结\"><a href=\"#✅-七、总结\" class=\"headerlink\" title=\"✅ 七、总结\"></a>✅ 七、总结</h3><p><code>display: contents</code> 是一个“结构优化”工具，适用于：</p>\n<ul>\n<li>想去除某个包装元素的视觉样式，但保留其内容。</li>\n<li>在 Flex&#x2F;Grid 布局中避免多余的嵌套层级。</li>\n<li>动态调整 DOM 结构的视觉表现，而无需修改 HTML。</li>\n</ul>\n<blockquote>\n<p>📌 <strong>一句话总结</strong>：<br><code>display: contents</code> 让元素“隐身”，但把它的孩子“扶正”，直接参与上一级布局。</p>\n</blockquote>\n<p>虽然使用场景相对小众，但在现代 CSS 布局中，它是一个非常优雅的“去壳”解决方案。</p>\n","excerpt":"","more":"<h1 id=\"display-中一个不常用的属性-contents\"><a href=\"#display-中一个不常用的属性-contents\" class=\"headerlink\" title=\"display 中一个不常用的属性 contents\"></a>display 中一个不常用的属性 contents</h1><p><code>display: contents</code> 是 CSS Display Module Level 3 中引入的一个比较特殊且强大的值。它的作用是：<strong>让一个元素本身不产生任何盒模型（即不渲染），但它的子元素会像直接继承了该元素的父元素一样正常渲染</strong>。</p>\n<p>简单来说：<strong>这个元素“消失”了，但它的孩子“冒出来”代替它参与布局</strong>。</p>\n<hr>\n<h3 id=\"🔍-一、基本语法\"><a href=\"#🔍-一、基本语法\" class=\"headerlink\" title=\"🔍 一、基本语法\"></a>🔍 一、基本语法</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.element</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: contents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"🧩-二、核心特性\"><a href=\"#🧩-二、核心特性\" class=\"headerlink\" title=\"🧩 二、核心特性\"></a>🧩 二、核心特性</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>不渲染自身</strong></td>\n<td>元素本身不生成任何视觉框（box），即没有背景、边框、大小、定位等。</td>\n</tr>\n<tr>\n<td><strong>子元素“提升”</strong></td>\n<td>子元素直接参与父元素的布局，仿佛父元素不存在。</td>\n</tr>\n<tr>\n<td><strong>保留语义和DOM结构</strong></td>\n<td>DOM 节点仍然存在，JavaScript 和 CSS 选择器仍可访问它。</td>\n</tr>\n<tr>\n<td><strong>不影响可访问性（需注意）</strong></td>\n<td>屏幕阅读器仍能读取内容，但布局上“跳过”了该层。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"✅-三、实际例子\"><a href=\"#✅-三、实际例子\" class=\"headerlink\" title=\"✅ 三、实际例子\"></a>✅ 三、实际例子</h3><h4 id=\"示例-1：display-contents-的效果\"><a href=\"#示例-1：display-contents-的效果\" class=\"headerlink\" title=\"示例 1：display: contents 的效果\"></a>示例 1：<code>display: contents</code> 的效果</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;display: contents;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">gap</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>**没有 <code>display: contents</code>**：</p>\n<ul>\n<li><code>.wrapper</code> 是一个红色块，包含两个 <code>&lt;p&gt;</code>。</li>\n<li>两个 <code>&lt;p&gt;</code> 在 <code>.wrapper</code> 内部，<strong>不会直接参与 <code>.parent</code> 的 flex 布局</strong>。</li>\n</ul>\n</li>\n<li><p>**加上 <code>display: contents</code>**：</p>\n<ul>\n<li><code>.wrapper</code> 的背景、padding、border 全部<strong>消失</strong>。</li>\n<li>两个 <code>&lt;p&gt;</code> 直接成为 <code>.parent</code> 的 flex item，<strong>直接参与 flex 布局</strong>，间隔 10px，且 <code>.parent</code> 的背景可见。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 效果：<code>.wrapper</code> “透明化”，子元素“穿透”上来。</p>\n</blockquote>\n<hr>\n<h3 id=\"🎯-四、典型使用场景\"><a href=\"#🎯-四、典型使用场景\" class=\"headerlink\" title=\"🎯 四、典型使用场景\"></a>🎯 四、典型使用场景</h3><h4 id=\"1-绕过不必要的包装容器（Wrapper）\"><a href=\"#1-绕过不必要的包装容器（Wrapper）\" class=\"headerlink\" title=\"1. 绕过不必要的包装容器（Wrapper）\"></a>1. <strong>绕过不必要的包装容器（Wrapper）</strong></h4><p>当使用某些框架或 CMS 生成了无法修改的嵌套结构时，可以用 <code>display: contents</code> “忽略”中间层。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 第三方组件生成的结构 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;icon&quot;</span>&gt;</span>✅<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> 选项1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;display: contents;&quot;</span>&gt;</span> <span class=\"comment\">&lt;!-- 去掉这个li的样式影响 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;icon&quot;</span>&gt;</span>❌<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> 选项2（禁用）</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以去掉某个 <code>&lt;li&gt;</code> 的布局影响，让其内容直接融入父级。</p>\n<h4 id=\"2-Grid-Flex-布局中“扁平化”结构\"><a href=\"#2-Grid-Flex-布局中“扁平化”结构\" class=\"headerlink\" title=\"2. Grid&#x2F;Flex 布局中“扁平化”结构\"></a>2. <strong>Grid&#x2F;Flex 布局中“扁平化”结构</strong></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;grid-container&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item-wrapper&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;display: contents;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: grid;</span><br><span class=\"line\">  <span class=\"attribute\">grid-template-columns</span>: <span class=\"number\">1</span>fr <span class=\"number\">1</span>fr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：<code>.item</code> 直接成为 grid item，占据两列，而 <code>.item-wrapper</code> 不占空间。</p>\n<h4 id=\"3-与-before-after-配合生成内容\"><a href=\"#3-与-before-after-配合生成内容\" class=\"headerlink\" title=\"3. 与 ::before &#x2F; ::after 配合生成内容\"></a>3. <strong>与 <code>::before</code> &#x2F; <code>::after</code> 配合生成内容</strong></h4><p>由于 <code>display: contents</code> 不渲染自身，但子元素可渲染，所以可以配合伪元素“注入”内容而不影响布局。</p>\n<hr>\n<h3 id=\"⚠️-五、注意事项与限制\"><a href=\"#⚠️-五、注意事项与限制\" class=\"headerlink\" title=\"⚠️ 五、注意事项与限制\"></a>⚠️ 五、注意事项与限制</h3><table>\n<thead>\n<tr>\n<th>问题</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>样式丢失</strong></td>\n<td>所有应用于该元素的盒模型样式（<code>background</code>, <code>border</code>, <code>padding</code>, <code>margin</code>, <code>width</code>, <code>height</code> 等）<strong>全部失效</strong>。</td>\n</tr>\n<tr>\n<td><strong>伪元素失效</strong></td>\n<td><code>::before</code> 和 <code>::after</code> <strong>不会显示</strong>（因为没有框来承载它们）。</td>\n</tr>\n<tr>\n<td><strong>可访问性影响</strong></td>\n<td>虽然内容还在，但结构被“扁平化”，可能影响屏幕阅读器的理解（需测试）。</td>\n</tr>\n<tr>\n<td><strong>浏览器兼容性</strong></td>\n<td>大部分现代浏览器支持，但 <strong>IE 完全不支持</strong>。</td>\n</tr>\n<tr>\n<td></td>\n<td>✅ Chrome 65+, Firefox 63+, Safari 12.1+, Edge 79+</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"🆚-六、对比其他隐藏方式\"><a href=\"#🆚-六、对比其他隐藏方式\" class=\"headerlink\" title=\"🆚 六、对比其他隐藏方式\"></a>🆚 六、对比其他隐藏方式</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>是否占空间</th>\n<th>子元素是否可见</th>\n<th>是否渲染</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>display: none</code></td>\n<td>否</td>\n<td>否</td>\n<td>完全不渲染</td>\n</tr>\n<tr>\n<td><code>visibility: hidden</code></td>\n<td>是</td>\n<td>否</td>\n<td>渲染但不可见</td>\n</tr>\n<tr>\n<td><code>opacity: 0</code></td>\n<td>是</td>\n<td>是（透明）</td>\n<td>渲染</td>\n</tr>\n<tr>\n<td><code>display: contents</code></td>\n<td><strong>否（自身）</strong></td>\n<td><strong>是（子元素提升）</strong></td>\n<td><strong>自身不渲染，子元素渲染</strong></td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"✅-七、总结\"><a href=\"#✅-七、总结\" class=\"headerlink\" title=\"✅ 七、总结\"></a>✅ 七、总结</h3><p><code>display: contents</code> 是一个“结构优化”工具，适用于：</p>\n<ul>\n<li>想去除某个包装元素的视觉样式，但保留其内容。</li>\n<li>在 Flex&#x2F;Grid 布局中避免多余的嵌套层级。</li>\n<li>动态调整 DOM 结构的视觉表现，而无需修改 HTML。</li>\n</ul>\n<blockquote>\n<p>📌 <strong>一句话总结</strong>：<br><code>display: contents</code> 让元素“隐身”，但把它的孩子“扶正”，直接参与上一级布局。</p>\n</blockquote>\n<p>虽然使用场景相对小众，但在现代 CSS 布局中，它是一个非常优雅的“去壳”解决方案。</p>\n"},{"title":"CI/CD","comments":1,"_content":"\n","source":"_posts/CI-CD.md","raw":"---\ntitle: CI/CD \ncomments: true \n---\n\n","slug":"CI-CD","published":1,"date":"2025-09-02T01:50:34.854Z","updated":"2025-09-01T09:54:01.759Z","_id":"cmf1w6ubq000gq4v91f53dk06","layout":"post","photos":[],"content":"","excerpt":"","more":""},{"title":"git的相关命令的解析","_content":"\n# git的相关命令的解析\n\n## ✅ **撤回（add）添加的内容**\n### 语法\n```bash\n  git reset [filename]\n```\n### 📌 作用： \n撤回添加到暂存区文件，不会对工作区的内容产生变化。因为add的时候会将文件转成blob对象，所以这里的reset只是将二进制的对象变成未引用的，具体的内容会由gc处理，reset并不会删除二进制对象。\n\n\n---\n\n## ✅ **查看当前仓库连接的远程仓库地址**\n### 语法\n```bash\ngit remote -v\n```\n**示例输出**：\n```\norigin  https://github.com/naiyniB/yian.git (fetch)\norigin  https://github.com/naiyniB/yian.git (push)\n```\n\n###  📌 作用：  \n列出所有远程仓库的名称和 URL（`-v` 表示 verbose，显示详细地址）。\n\n---\n\n## ✅ **查看当前所在的本地分支**\n### 语法\n```bash\ngit branch --show-current\n```\n💡 也可以用：\n```bash\ngit status\n```\n###  📌 作用：  \n直接输出当前分支名，如 `main` 或 `master`。\n\n第一行会显示：`On branch main`\n\n---\n\n### ✅ 3. **查看所有本地分支**\n\n```bash\ngit branch\n```\n**示例输出**：\n```\n  dev\n* main\n  feature/user-login\n```\n\n\n###  📌 作用：  \n列出所有本地分支，当前分支前会有一个 `*` 号。\n---\n\n## ✅ **查看远程分支（必须先同步）**\n\n### 第一步：获取最新远程分支信息\n#### 语法\n```bash\ngit fetch --all\n```\n> ⚠️ 如果不先 fetch，可能看不到别人新建的分支。\n\n### 第二步：查看所有远程分支\n#### 语法\n```bash\ngit branch -r\n```\n**示例输出**：\n```\n  origin/main\n  origin/dev\n  origin/feature/user-login\n  origin/release/v1.0\n```\n### 📌 作用：  \n列出所有远程分支，通常以 `origin/` 开头。\n\n---\n\n## ✅  **查看本地 + 远程所有分支**\n### 语法：\n```bash\ngit branch -a\n```\n\n### 📌 作用：  \n同时显示本地分支和远程分支（带 `remotes/origin/...`）。\n\n---\n\n## ✅**查看远程仓库的详细信息（含分支跟踪关系）**\n### 语法：\n```bash\ngit remote show origin\n```\n### 📌 作用：  \n显示远程仓库 `origin` 的详细情况，包括：\n- 远程 URL\n- 所有远程分支\n- 哪些分支已关联本地分支（tracking）\n- 哪些分支在远程已被删除\n\n---\n","source":"_posts/git的相关命令.md","raw":"---\ntitle: git的相关命令的解析\n---\n\n# git的相关命令的解析\n\n## ✅ **撤回（add）添加的内容**\n### 语法\n```bash\n  git reset [filename]\n```\n### 📌 作用： \n撤回添加到暂存区文件，不会对工作区的内容产生变化。因为add的时候会将文件转成blob对象，所以这里的reset只是将二进制的对象变成未引用的，具体的内容会由gc处理，reset并不会删除二进制对象。\n\n\n---\n\n## ✅ **查看当前仓库连接的远程仓库地址**\n### 语法\n```bash\ngit remote -v\n```\n**示例输出**：\n```\norigin  https://github.com/naiyniB/yian.git (fetch)\norigin  https://github.com/naiyniB/yian.git (push)\n```\n\n###  📌 作用：  \n列出所有远程仓库的名称和 URL（`-v` 表示 verbose，显示详细地址）。\n\n---\n\n## ✅ **查看当前所在的本地分支**\n### 语法\n```bash\ngit branch --show-current\n```\n💡 也可以用：\n```bash\ngit status\n```\n###  📌 作用：  \n直接输出当前分支名，如 `main` 或 `master`。\n\n第一行会显示：`On branch main`\n\n---\n\n### ✅ 3. **查看所有本地分支**\n\n```bash\ngit branch\n```\n**示例输出**：\n```\n  dev\n* main\n  feature/user-login\n```\n\n\n###  📌 作用：  \n列出所有本地分支，当前分支前会有一个 `*` 号。\n---\n\n## ✅ **查看远程分支（必须先同步）**\n\n### 第一步：获取最新远程分支信息\n#### 语法\n```bash\ngit fetch --all\n```\n> ⚠️ 如果不先 fetch，可能看不到别人新建的分支。\n\n### 第二步：查看所有远程分支\n#### 语法\n```bash\ngit branch -r\n```\n**示例输出**：\n```\n  origin/main\n  origin/dev\n  origin/feature/user-login\n  origin/release/v1.0\n```\n### 📌 作用：  \n列出所有远程分支，通常以 `origin/` 开头。\n\n---\n\n## ✅  **查看本地 + 远程所有分支**\n### 语法：\n```bash\ngit branch -a\n```\n\n### 📌 作用：  \n同时显示本地分支和远程分支（带 `remotes/origin/...`）。\n\n---\n\n## ✅**查看远程仓库的详细信息（含分支跟踪关系）**\n### 语法：\n```bash\ngit remote show origin\n```\n### 📌 作用：  \n显示远程仓库 `origin` 的详细情况，包括：\n- 远程 URL\n- 所有远程分支\n- 哪些分支已关联本地分支（tracking）\n- 哪些分支在远程已被删除\n\n---\n","slug":"git的相关命令","published":1,"date":"2025-09-02T01:50:34.861Z","updated":"2025-09-01T09:54:01.760Z","_id":"cmf1wsyob000hq4v93ufsd0k0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"git的相关命令的解析\"><a href=\"#git的相关命令的解析\" class=\"headerlink\" title=\"git的相关命令的解析\"></a>git的相关命令的解析</h1><h2 id=\"✅-撤回（add）添加的内容\"><a href=\"#✅-撤回（add）添加的内容\" class=\"headerlink\" title=\"✅ 撤回（add）添加的内容\"></a>✅ <strong>撤回（add）添加的内容</strong></h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [filename]</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：\"><a href=\"#📌-作用：\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>撤回添加到暂存区文件，不会对工作区的内容产生变化。因为add的时候会将文件转成blob对象，所以这里的reset只是将二进制的对象变成未引用的，具体的内容会由gc处理，reset并不会删除二进制对象。</p>\n<hr>\n<h2 id=\"✅-查看当前仓库连接的远程仓库地址\"><a href=\"#✅-查看当前仓库连接的远程仓库地址\" class=\"headerlink\" title=\"✅ 查看当前仓库连接的远程仓库地址\"></a>✅ <strong>查看当前仓库连接的远程仓库地址</strong></h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p><strong>示例输出</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin  https://github.com/naiyniB/yian.git (fetch)</span><br><span class=\"line\">origin  https://github.com/naiyniB/yian.git (push)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📌-作用：-1\"><a href=\"#📌-作用：-1\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>列出所有远程仓库的名称和 URL（<code>-v</code> 表示 verbose，显示详细地址）。</p>\n<hr>\n<h2 id=\"✅-查看当前所在的本地分支\"><a href=\"#✅-查看当前所在的本地分支\" class=\"headerlink\" title=\"✅ 查看当前所在的本地分支\"></a>✅ <strong>查看当前所在的本地分支</strong></h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --show-current</span><br></pre></td></tr></table></figure>\n<p>💡 也可以用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：-2\"><a href=\"#📌-作用：-2\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>直接输出当前分支名，如 <code>main</code> 或 <code>master</code>。</p>\n<p>第一行会显示：<code>On branch main</code></p>\n<hr>\n<h3 id=\"✅-3-查看所有本地分支\"><a href=\"#✅-3-查看所有本地分支\" class=\"headerlink\" title=\"✅ 3. 查看所有本地分支\"></a>✅ 3. <strong>查看所有本地分支</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n<p><strong>示例输出</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  dev</span><br><span class=\"line\">* main</span><br><span class=\"line\">  feature/user-login</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"📌-作用：-3\"><a href=\"#📌-作用：-3\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><h2 id=\"列出所有本地分支，当前分支前会有一个-号。\"><a href=\"#列出所有本地分支，当前分支前会有一个-号。\" class=\"headerlink\" title=\"列出所有本地分支，当前分支前会有一个 * 号。\"></a>列出所有本地分支，当前分支前会有一个 <code>*</code> 号。</h2><h2 id=\"✅-查看远程分支（必须先同步）\"><a href=\"#✅-查看远程分支（必须先同步）\" class=\"headerlink\" title=\"✅ 查看远程分支（必须先同步）\"></a>✅ <strong>查看远程分支（必须先同步）</strong></h2><h3 id=\"第一步：获取最新远程分支信息\"><a href=\"#第一步：获取最新远程分支信息\" class=\"headerlink\" title=\"第一步：获取最新远程分支信息\"></a>第一步：获取最新远程分支信息</h3><h4 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>⚠️ 如果不先 fetch，可能看不到别人新建的分支。</p>\n</blockquote>\n<h3 id=\"第二步：查看所有远程分支\"><a href=\"#第二步：查看所有远程分支\" class=\"headerlink\" title=\"第二步：查看所有远程分支\"></a>第二步：查看所有远程分支</h3><h4 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n<p><strong>示例输出</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin/main</span><br><span class=\"line\">origin/dev</span><br><span class=\"line\">origin/feature/user-login</span><br><span class=\"line\">origin/release/v1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：-4\"><a href=\"#📌-作用：-4\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>列出所有远程分支，通常以 <code>origin/</code> 开头。</p>\n<hr>\n<h2 id=\"✅-查看本地-远程所有分支\"><a href=\"#✅-查看本地-远程所有分支\" class=\"headerlink\" title=\"✅  查看本地 + 远程所有分支\"></a>✅  <strong>查看本地 + 远程所有分支</strong></h2><h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📌-作用：-5\"><a href=\"#📌-作用：-5\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>同时显示本地分支和远程分支（带 <code>remotes/origin/...</code>）。</p>\n<hr>\n<h2 id=\"✅查看远程仓库的详细信息（含分支跟踪关系）\"><a href=\"#✅查看远程仓库的详细信息（含分支跟踪关系）\" class=\"headerlink\" title=\"✅查看远程仓库的详细信息（含分支跟踪关系）\"></a>✅<strong>查看远程仓库的详细信息（含分支跟踪关系）</strong></h2><h3 id=\"语法：-1\"><a href=\"#语法：-1\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show origin</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：-6\"><a href=\"#📌-作用：-6\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>显示远程仓库 <code>origin</code> 的详细情况，包括：</p>\n<ul>\n<li>远程 URL</li>\n<li>所有远程分支</li>\n<li>哪些分支已关联本地分支（tracking）</li>\n<li>哪些分支在远程已被删除</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h1 id=\"git的相关命令的解析\"><a href=\"#git的相关命令的解析\" class=\"headerlink\" title=\"git的相关命令的解析\"></a>git的相关命令的解析</h1><h2 id=\"✅-撤回（add）添加的内容\"><a href=\"#✅-撤回（add）添加的内容\" class=\"headerlink\" title=\"✅ 撤回（add）添加的内容\"></a>✅ <strong>撤回（add）添加的内容</strong></h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [filename]</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：\"><a href=\"#📌-作用：\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>撤回添加到暂存区文件，不会对工作区的内容产生变化。因为add的时候会将文件转成blob对象，所以这里的reset只是将二进制的对象变成未引用的，具体的内容会由gc处理，reset并不会删除二进制对象。</p>\n<hr>\n<h2 id=\"✅-查看当前仓库连接的远程仓库地址\"><a href=\"#✅-查看当前仓库连接的远程仓库地址\" class=\"headerlink\" title=\"✅ 查看当前仓库连接的远程仓库地址\"></a>✅ <strong>查看当前仓库连接的远程仓库地址</strong></h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p><strong>示例输出</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin  https://github.com/naiyniB/yian.git (fetch)</span><br><span class=\"line\">origin  https://github.com/naiyniB/yian.git (push)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📌-作用：-1\"><a href=\"#📌-作用：-1\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>列出所有远程仓库的名称和 URL（<code>-v</code> 表示 verbose，显示详细地址）。</p>\n<hr>\n<h2 id=\"✅-查看当前所在的本地分支\"><a href=\"#✅-查看当前所在的本地分支\" class=\"headerlink\" title=\"✅ 查看当前所在的本地分支\"></a>✅ <strong>查看当前所在的本地分支</strong></h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --show-current</span><br></pre></td></tr></table></figure>\n<p>💡 也可以用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：-2\"><a href=\"#📌-作用：-2\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>直接输出当前分支名，如 <code>main</code> 或 <code>master</code>。</p>\n<p>第一行会显示：<code>On branch main</code></p>\n<hr>\n<h3 id=\"✅-3-查看所有本地分支\"><a href=\"#✅-3-查看所有本地分支\" class=\"headerlink\" title=\"✅ 3. 查看所有本地分支\"></a>✅ 3. <strong>查看所有本地分支</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n<p><strong>示例输出</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  dev</span><br><span class=\"line\">* main</span><br><span class=\"line\">  feature/user-login</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"📌-作用：-3\"><a href=\"#📌-作用：-3\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><h2 id=\"列出所有本地分支，当前分支前会有一个-号。\"><a href=\"#列出所有本地分支，当前分支前会有一个-号。\" class=\"headerlink\" title=\"列出所有本地分支，当前分支前会有一个 * 号。\"></a>列出所有本地分支，当前分支前会有一个 <code>*</code> 号。</h2><h2 id=\"✅-查看远程分支（必须先同步）\"><a href=\"#✅-查看远程分支（必须先同步）\" class=\"headerlink\" title=\"✅ 查看远程分支（必须先同步）\"></a>✅ <strong>查看远程分支（必须先同步）</strong></h2><h3 id=\"第一步：获取最新远程分支信息\"><a href=\"#第一步：获取最新远程分支信息\" class=\"headerlink\" title=\"第一步：获取最新远程分支信息\"></a>第一步：获取最新远程分支信息</h3><h4 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>⚠️ 如果不先 fetch，可能看不到别人新建的分支。</p>\n</blockquote>\n<h3 id=\"第二步：查看所有远程分支\"><a href=\"#第二步：查看所有远程分支\" class=\"headerlink\" title=\"第二步：查看所有远程分支\"></a>第二步：查看所有远程分支</h3><h4 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n<p><strong>示例输出</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin/main</span><br><span class=\"line\">origin/dev</span><br><span class=\"line\">origin/feature/user-login</span><br><span class=\"line\">origin/release/v1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：-4\"><a href=\"#📌-作用：-4\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>列出所有远程分支，通常以 <code>origin/</code> 开头。</p>\n<hr>\n<h2 id=\"✅-查看本地-远程所有分支\"><a href=\"#✅-查看本地-远程所有分支\" class=\"headerlink\" title=\"✅  查看本地 + 远程所有分支\"></a>✅  <strong>查看本地 + 远程所有分支</strong></h2><h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📌-作用：-5\"><a href=\"#📌-作用：-5\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>同时显示本地分支和远程分支（带 <code>remotes/origin/...</code>）。</p>\n<hr>\n<h2 id=\"✅查看远程仓库的详细信息（含分支跟踪关系）\"><a href=\"#✅查看远程仓库的详细信息（含分支跟踪关系）\" class=\"headerlink\" title=\"✅查看远程仓库的详细信息（含分支跟踪关系）\"></a>✅<strong>查看远程仓库的详细信息（含分支跟踪关系）</strong></h2><h3 id=\"语法：-1\"><a href=\"#语法：-1\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show origin</span><br></pre></td></tr></table></figure>\n<h3 id=\"📌-作用：-6\"><a href=\"#📌-作用：-6\" class=\"headerlink\" title=\"📌 作用：\"></a>📌 作用：</h3><p>显示远程仓库 <code>origin</code> 的详细情况，包括：</p>\n<ul>\n<li>远程 URL</li>\n<li>所有远程分支</li>\n<li>哪些分支已关联本地分支（tracking）</li>\n<li>哪些分支在远程已被删除</li>\n</ul>\n<hr>\n"},{"title":"🌟 Git 基础知识总结（完整版）","_content":"\n## 一、Git 的核心概念\n\nGit 是一个**分布式版本控制系统**，它通过记录文件的**快照（snapshot）** 而不是差异，来管理代码的历史变化。\n\n### 1. 四大核心对象\n\n| 对象 | 作用 | 特点 |\n|------|------|------|\n| **Blob** | 存储文件内容（不包含文件名） | 内容相同 → 哈希相同 |\n| **Tree** | 存储目录结构（文件名 + 指向 blob 或子 tree） | 目录的“快照” |\n| **Commit** | 代表一次提交，指向一个 tree，记录作者、时间、消息和父提交 | 历史的“节点” |\n| **Tag** | 指向某个 commit 的固定引用，用于标记版本（如 v1.0） | 不会移动 |\n\n> ✅ 所有对象都通过 SHA-1 哈希唯一标识。\n\n---\n\n## 二、暂存（add）\n- `git add` 的作用\n    - 核心功能：将工作目录中的文件变更添加到**暂存区（index）** ，为下一次提交准备内容。\n- 本质操作：\n    - 读取文件内容 → 生成 **Blob** 对象 → 更新 `.git/index` 文件。\n    - 结果：暂存区记录了“下一次提交”的快照。\n- **暂存区（index）** 存放的目录是最新的commit的tree目录和add的\n\n## 三、提交（Commit）与快照\n\n- 每次 `git commit`：\n  - 将**暂存区（index）** 的当前状态打包成一个 **tree**\n  - 创建一个 **commit** 指向这个 tree\n  - commit 记录父提交（形成链）\n- **还原代码**：根据 commit 找到 tree，再根据 tree 还原所有 blob，重建整个项目目录。\n\n> 🎯 Git 不是“记录变化”，而是“记录每一刻的完整状态”。\n\n---\n\n## 四、分支（Branch）\n\n- **分支 = 指向某个 commit 的指针**\n- 默认分支通常是 `main` 或 `master`\n- 分支是**轻量级的**，创建和切换非常快\n\n### 常用命令：\n```bash\ngit branch                  # 查看分支\ngit switch <name>           # 切换分支\ngit switch -b <name>        # 创建并切换\ngit branch -d <name>        # 删除分支\n```\n\n---\n\n## 五、合并（Merge）\n\n将一个分支的修改整合到另一个分支。\n\n### 两种合并方式：\n\n| 类型 | 条件 | 是否创建新 commit | 说明 |\n|------|------|------------------|------|\n| **Fast-forward** | 目标分支无新提交 | ❌ 不创建 | 直接移动分支指针，历史线性 |\n| **True Merge** | 历史已分叉 | ✅ 创建“合并提交” | 新 commit 有两个父节点 |\n\n### 合并提交的特点：\n- 有 **两个父提交**（分别来自两个分支）\n- 用 `git log --graph` 可看到分叉与合并\n- 保留完整的分支历史拓扑\n\n```bash\ngit merge <branch>\n```\n\n> ⚠️ 可能发生**冲突**：需手动解决 → `git add` → `git commit`\n\n---\n\n## 六、推送（Push）与拉取（Pull）\n\n用于**本地仓库**与**远程仓库**（如 GitHub）同步。\n\n### 1. `git push`：本地 → 远程\n- 作用：将本地的 commit 链推送到远程\n- 实质：**增量推送**，只传远程没有的 commit、tree、blob\n- 不是推送整个仓库！\n\n```bash\ngit push origin main\n```\n\n### 2. `git pull`：远程 → 本地\n- 作用：下载远程更新并合并到当前分支\n- 实质：`git pull = git fetch + git merge`\n\n```bash\ngit pull origin main\n```\n\n### 关键理解：\n- **同步的是 commit 链**，不是文件\n- Git 智能分析“缺什么”，只传缺失部分\n- 分支是“同步入口”，指明从哪开始同步\n\n---\n\n## 七、标签（Tag）\n\n- **固定指针**，指向某个 commit，**不会移动**\n- 用于标记发布版本（如 v1.0、v2.1.0）\n\n### 两种类型：\n- **轻量标签**：直接指向 commit\n- **附注标签**：完整对象，含作者、时间、签名（推荐）\n\n```bash\ngit tag v1.0                    # 轻量\ngit tag -a v1.0 -m \"Release\"    # 附注\ngit push origin v1.0            # 推送标签（不会自动推）\n```\n\n---\n\n## 八、核心工作流程（推荐）\n\n```bash\n# 1. 开始工作前：拉取最新\ngit pull\n\n# 2. 创建功能分支\ngit switch -b feature/login\n\n# 3. 开发 & 提交\ngit add .\ngit commit -m \"add login form\"\n\n# 4. 推送前：再拉取一次（避免冲突）\ngit pull\n\n# 5. 推送\ngit push origin feature/login\n```\n\n---\n\n## 九、一句话理解 Git\n\n> **Git 是一个基于 commit 链的分布式快照系统。**\n>\n> - **分支**是移动的指针\n> - **合并**是连接历史\n> - **推送/拉取**是增量同步两个仓库的 commit 链\n\n---\n\n## 🎉 你已经掌握的技能\n\n| 技能 | ✅ 已掌握 |\n|------|---------|\n| 理解 commit、tree、blob 的关系 | ✅ |\n| 使用分支进行并行开发 | ✅ |\n| 合并分支（包括合并提交） | ✅ |\n| 推送和拉取代码 | ✅ |\n| 理解 tag 的作用 | ✅ |\n| 理解 push/pull 是基于 commit 链的增量同步 | ✅ |\n\n---\n\n```mermaid\ngraph LR\n    A[工作目录中的文件] -->|git add| B[Blob 对象]\n    B -->|内容存储| C[.git/objects/]\n    A -->|路径/模式| D[.git/index]\n    D -->|作为输入| E[git commit]\n    E --> F[创建 Tree 对象]\n    F -->|结构快照| C\n    E --> G[创建 Commit 对象]\n    G -->|指向 Tree| F\n    G -->|指向 Parent| H[上一个 Commit]\n    G -->|包含| I[作者/信息/时间]\n    G -->|写入| C\n    G -->|更新| J[分支引用 refs/heads/main]\n\n```\n","source":"_posts/Git.md","raw":"---\ntitle: 🌟 Git 基础知识总结（完整版）\n---\n\n## 一、Git 的核心概念\n\nGit 是一个**分布式版本控制系统**，它通过记录文件的**快照（snapshot）** 而不是差异，来管理代码的历史变化。\n\n### 1. 四大核心对象\n\n| 对象 | 作用 | 特点 |\n|------|------|------|\n| **Blob** | 存储文件内容（不包含文件名） | 内容相同 → 哈希相同 |\n| **Tree** | 存储目录结构（文件名 + 指向 blob 或子 tree） | 目录的“快照” |\n| **Commit** | 代表一次提交，指向一个 tree，记录作者、时间、消息和父提交 | 历史的“节点” |\n| **Tag** | 指向某个 commit 的固定引用，用于标记版本（如 v1.0） | 不会移动 |\n\n> ✅ 所有对象都通过 SHA-1 哈希唯一标识。\n\n---\n\n## 二、暂存（add）\n- `git add` 的作用\n    - 核心功能：将工作目录中的文件变更添加到**暂存区（index）** ，为下一次提交准备内容。\n- 本质操作：\n    - 读取文件内容 → 生成 **Blob** 对象 → 更新 `.git/index` 文件。\n    - 结果：暂存区记录了“下一次提交”的快照。\n- **暂存区（index）** 存放的目录是最新的commit的tree目录和add的\n\n## 三、提交（Commit）与快照\n\n- 每次 `git commit`：\n  - 将**暂存区（index）** 的当前状态打包成一个 **tree**\n  - 创建一个 **commit** 指向这个 tree\n  - commit 记录父提交（形成链）\n- **还原代码**：根据 commit 找到 tree，再根据 tree 还原所有 blob，重建整个项目目录。\n\n> 🎯 Git 不是“记录变化”，而是“记录每一刻的完整状态”。\n\n---\n\n## 四、分支（Branch）\n\n- **分支 = 指向某个 commit 的指针**\n- 默认分支通常是 `main` 或 `master`\n- 分支是**轻量级的**，创建和切换非常快\n\n### 常用命令：\n```bash\ngit branch                  # 查看分支\ngit switch <name>           # 切换分支\ngit switch -b <name>        # 创建并切换\ngit branch -d <name>        # 删除分支\n```\n\n---\n\n## 五、合并（Merge）\n\n将一个分支的修改整合到另一个分支。\n\n### 两种合并方式：\n\n| 类型 | 条件 | 是否创建新 commit | 说明 |\n|------|------|------------------|------|\n| **Fast-forward** | 目标分支无新提交 | ❌ 不创建 | 直接移动分支指针，历史线性 |\n| **True Merge** | 历史已分叉 | ✅ 创建“合并提交” | 新 commit 有两个父节点 |\n\n### 合并提交的特点：\n- 有 **两个父提交**（分别来自两个分支）\n- 用 `git log --graph` 可看到分叉与合并\n- 保留完整的分支历史拓扑\n\n```bash\ngit merge <branch>\n```\n\n> ⚠️ 可能发生**冲突**：需手动解决 → `git add` → `git commit`\n\n---\n\n## 六、推送（Push）与拉取（Pull）\n\n用于**本地仓库**与**远程仓库**（如 GitHub）同步。\n\n### 1. `git push`：本地 → 远程\n- 作用：将本地的 commit 链推送到远程\n- 实质：**增量推送**，只传远程没有的 commit、tree、blob\n- 不是推送整个仓库！\n\n```bash\ngit push origin main\n```\n\n### 2. `git pull`：远程 → 本地\n- 作用：下载远程更新并合并到当前分支\n- 实质：`git pull = git fetch + git merge`\n\n```bash\ngit pull origin main\n```\n\n### 关键理解：\n- **同步的是 commit 链**，不是文件\n- Git 智能分析“缺什么”，只传缺失部分\n- 分支是“同步入口”，指明从哪开始同步\n\n---\n\n## 七、标签（Tag）\n\n- **固定指针**，指向某个 commit，**不会移动**\n- 用于标记发布版本（如 v1.0、v2.1.0）\n\n### 两种类型：\n- **轻量标签**：直接指向 commit\n- **附注标签**：完整对象，含作者、时间、签名（推荐）\n\n```bash\ngit tag v1.0                    # 轻量\ngit tag -a v1.0 -m \"Release\"    # 附注\ngit push origin v1.0            # 推送标签（不会自动推）\n```\n\n---\n\n## 八、核心工作流程（推荐）\n\n```bash\n# 1. 开始工作前：拉取最新\ngit pull\n\n# 2. 创建功能分支\ngit switch -b feature/login\n\n# 3. 开发 & 提交\ngit add .\ngit commit -m \"add login form\"\n\n# 4. 推送前：再拉取一次（避免冲突）\ngit pull\n\n# 5. 推送\ngit push origin feature/login\n```\n\n---\n\n## 九、一句话理解 Git\n\n> **Git 是一个基于 commit 链的分布式快照系统。**\n>\n> - **分支**是移动的指针\n> - **合并**是连接历史\n> - **推送/拉取**是增量同步两个仓库的 commit 链\n\n---\n\n## 🎉 你已经掌握的技能\n\n| 技能 | ✅ 已掌握 |\n|------|---------|\n| 理解 commit、tree、blob 的关系 | ✅ |\n| 使用分支进行并行开发 | ✅ |\n| 合并分支（包括合并提交） | ✅ |\n| 推送和拉取代码 | ✅ |\n| 理解 tag 的作用 | ✅ |\n| 理解 push/pull 是基于 commit 链的增量同步 | ✅ |\n\n---\n\n```mermaid\ngraph LR\n    A[工作目录中的文件] -->|git add| B[Blob 对象]\n    B -->|内容存储| C[.git/objects/]\n    A -->|路径/模式| D[.git/index]\n    D -->|作为输入| E[git commit]\n    E --> F[创建 Tree 对象]\n    F -->|结构快照| C\n    E --> G[创建 Commit 对象]\n    G -->|指向 Tree| F\n    G -->|指向 Parent| H[上一个 Commit]\n    G -->|包含| I[作者/信息/时间]\n    G -->|写入| C\n    G -->|更新| J[分支引用 refs/heads/main]\n\n```\n","slug":"Git","published":1,"date":"2025-09-02T01:50:34.866Z","updated":"2025-09-01T09:54:01.759Z","_id":"cmf1wt3we000iq4v917pzg2rf","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"一、Git-的核心概念\"><a href=\"#一、Git-的核心概念\" class=\"headerlink\" title=\"一、Git 的核心概念\"></a>一、Git 的核心概念</h2><p>Git 是一个<strong>分布式版本控制系统</strong>，它通过记录文件的<strong>快照（snapshot）</strong> 而不是差异，来管理代码的历史变化。</p>\n<h3 id=\"1-四大核心对象\"><a href=\"#1-四大核心对象\" class=\"headerlink\" title=\"1. 四大核心对象\"></a>1. 四大核心对象</h3><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>作用</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Blob</strong></td>\n<td>存储文件内容（不包含文件名）</td>\n<td>内容相同 → 哈希相同</td>\n</tr>\n<tr>\n<td><strong>Tree</strong></td>\n<td>存储目录结构（文件名 + 指向 blob 或子 tree）</td>\n<td>目录的“快照”</td>\n</tr>\n<tr>\n<td><strong>Commit</strong></td>\n<td>代表一次提交，指向一个 tree，记录作者、时间、消息和父提交</td>\n<td>历史的“节点”</td>\n</tr>\n<tr>\n<td><strong>Tag</strong></td>\n<td>指向某个 commit 的固定引用，用于标记版本（如 v1.0）</td>\n<td>不会移动</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ 所有对象都通过 SHA-1 哈希唯一标识。</p>\n</blockquote>\n<hr>\n<h2 id=\"二、暂存（add）\"><a href=\"#二、暂存（add）\" class=\"headerlink\" title=\"二、暂存（add）\"></a>二、暂存（add）</h2><ul>\n<li><code>git add</code> 的作用<ul>\n<li>核心功能：将工作目录中的文件变更添加到<strong>暂存区（index）</strong> ，为下一次提交准备内容。</li>\n</ul>\n</li>\n<li>本质操作：<ul>\n<li>读取文件内容 → 生成 <strong>Blob</strong> 对象 → 更新 <code>.git/index</code> 文件。</li>\n<li>结果：暂存区记录了“下一次提交”的快照。</li>\n</ul>\n</li>\n<li><strong>暂存区（index）</strong> 存放的目录是最新的commit的tree目录和add的</li>\n</ul>\n<h2 id=\"三、提交（Commit）与快照\"><a href=\"#三、提交（Commit）与快照\" class=\"headerlink\" title=\"三、提交（Commit）与快照\"></a>三、提交（Commit）与快照</h2><ul>\n<li>每次 <code>git commit</code>：<ul>\n<li>将<strong>暂存区（index）</strong> 的当前状态打包成一个 <strong>tree</strong></li>\n<li>创建一个 <strong>commit</strong> 指向这个 tree</li>\n<li>commit 记录父提交（形成链）</li>\n</ul>\n</li>\n<li><strong>还原代码</strong>：根据 commit 找到 tree，再根据 tree 还原所有 blob，重建整个项目目录。</li>\n</ul>\n<blockquote>\n<p>🎯 Git 不是“记录变化”，而是“记录每一刻的完整状态”。</p>\n</blockquote>\n<hr>\n<h2 id=\"四、分支（Branch）\"><a href=\"#四、分支（Branch）\" class=\"headerlink\" title=\"四、分支（Branch）\"></a>四、分支（Branch）</h2><ul>\n<li><strong>分支 &#x3D; 指向某个 commit 的指针</strong></li>\n<li>默认分支通常是 <code>main</code> 或 <code>master</code></li>\n<li>分支是<strong>轻量级的</strong>，创建和切换非常快</li>\n</ul>\n<h3 id=\"常用命令：\"><a href=\"#常用命令：\" class=\"headerlink\" title=\"常用命令：\"></a>常用命令：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch                  <span class=\"comment\"># 查看分支</span></span><br><span class=\"line\">git switch &lt;name&gt;           <span class=\"comment\"># 切换分支</span></span><br><span class=\"line\">git switch -b &lt;name&gt;        <span class=\"comment\"># 创建并切换</span></span><br><span class=\"line\">git branch -d &lt;name&gt;        <span class=\"comment\"># 删除分支</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"五、合并（Merge）\"><a href=\"#五、合并（Merge）\" class=\"headerlink\" title=\"五、合并（Merge）\"></a>五、合并（Merge）</h2><p>将一个分支的修改整合到另一个分支。</p>\n<h3 id=\"两种合并方式：\"><a href=\"#两种合并方式：\" class=\"headerlink\" title=\"两种合并方式：\"></a>两种合并方式：</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>条件</th>\n<th>是否创建新 commit</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fast-forward</strong></td>\n<td>目标分支无新提交</td>\n<td>❌ 不创建</td>\n<td>直接移动分支指针，历史线性</td>\n</tr>\n<tr>\n<td><strong>True Merge</strong></td>\n<td>历史已分叉</td>\n<td>✅ 创建“合并提交”</td>\n<td>新 commit 有两个父节点</td>\n</tr>\n</tbody></table>\n<h3 id=\"合并提交的特点：\"><a href=\"#合并提交的特点：\" class=\"headerlink\" title=\"合并提交的特点：\"></a>合并提交的特点：</h3><ul>\n<li>有 <strong>两个父提交</strong>（分别来自两个分支）</li>\n<li>用 <code>git log --graph</code> 可看到分叉与合并</li>\n<li>保留完整的分支历史拓扑</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>⚠️ 可能发生<strong>冲突</strong>：需手动解决 → <code>git add</code> → <code>git commit</code></p>\n</blockquote>\n<hr>\n<h2 id=\"六、推送（Push）与拉取（Pull）\"><a href=\"#六、推送（Push）与拉取（Pull）\" class=\"headerlink\" title=\"六、推送（Push）与拉取（Pull）\"></a>六、推送（Push）与拉取（Pull）</h2><p>用于<strong>本地仓库</strong>与<strong>远程仓库</strong>（如 GitHub）同步。</p>\n<h3 id=\"1-git-push：本地-→-远程\"><a href=\"#1-git-push：本地-→-远程\" class=\"headerlink\" title=\"1. git push：本地 → 远程\"></a>1. <code>git push</code>：本地 → 远程</h3><ul>\n<li>作用：将本地的 commit 链推送到远程</li>\n<li>实质：<strong>增量推送</strong>，只传远程没有的 commit、tree、blob</li>\n<li>不是推送整个仓库！</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-git-pull：远程-→-本地\"><a href=\"#2-git-pull：远程-→-本地\" class=\"headerlink\" title=\"2. git pull：远程 → 本地\"></a>2. <code>git pull</code>：远程 → 本地</h3><ul>\n<li>作用：下载远程更新并合并到当前分支</li>\n<li>实质：<code>git pull = git fetch + git merge</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键理解：\"><a href=\"#关键理解：\" class=\"headerlink\" title=\"关键理解：\"></a>关键理解：</h3><ul>\n<li><strong>同步的是 commit 链</strong>，不是文件</li>\n<li>Git 智能分析“缺什么”，只传缺失部分</li>\n<li>分支是“同步入口”，指明从哪开始同步</li>\n</ul>\n<hr>\n<h2 id=\"七、标签（Tag）\"><a href=\"#七、标签（Tag）\" class=\"headerlink\" title=\"七、标签（Tag）\"></a>七、标签（Tag）</h2><ul>\n<li><strong>固定指针</strong>，指向某个 commit，<strong>不会移动</strong></li>\n<li>用于标记发布版本（如 v1.0、v2.1.0）</li>\n</ul>\n<h3 id=\"两种类型：\"><a href=\"#两种类型：\" class=\"headerlink\" title=\"两种类型：\"></a>两种类型：</h3><ul>\n<li><strong>轻量标签</strong>：直接指向 commit</li>\n<li><strong>附注标签</strong>：完整对象，含作者、时间、签名（推荐）</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0                    <span class=\"comment\"># 轻量</span></span><br><span class=\"line\">git tag -a v1.0 -m <span class=\"string\">&quot;Release&quot;</span>    <span class=\"comment\"># 附注</span></span><br><span class=\"line\">git push origin v1.0            <span class=\"comment\"># 推送标签（不会自动推）</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"八、核心工作流程（推荐）\"><a href=\"#八、核心工作流程（推荐）\" class=\"headerlink\" title=\"八、核心工作流程（推荐）\"></a>八、核心工作流程（推荐）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 开始工作前：拉取最新</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 创建功能分支</span></span><br><span class=\"line\">git switch -b feature/login</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 开发 &amp; 提交</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;add login form&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 推送前：再拉取一次（避免冲突）</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 推送</span></span><br><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"九、一句话理解-Git\"><a href=\"#九、一句话理解-Git\" class=\"headerlink\" title=\"九、一句话理解 Git\"></a>九、一句话理解 Git</h2><blockquote>\n<p><strong>Git 是一个基于 commit 链的分布式快照系统。</strong></p>\n<ul>\n<li><strong>分支</strong>是移动的指针</li>\n<li><strong>合并</strong>是连接历史</li>\n<li><strong>推送&#x2F;拉取</strong>是增量同步两个仓库的 commit 链</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"🎉-你已经掌握的技能\"><a href=\"#🎉-你已经掌握的技能\" class=\"headerlink\" title=\"🎉 你已经掌握的技能\"></a>🎉 你已经掌握的技能</h2><table>\n<thead>\n<tr>\n<th>技能</th>\n<th>✅ 已掌握</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>理解 commit、tree、blob 的关系</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>使用分支进行并行开发</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>合并分支（包括合并提交）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>推送和拉取代码</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>理解 tag 的作用</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>理解 push&#x2F;pull 是基于 commit 链的增量同步</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">    A[工作目录中的文件] --&gt;|git add| B[Blob 对象]</span><br><span class=\"line\">    B --&gt;|内容存储| C[.git/objects/]</span><br><span class=\"line\">    A --&gt;|路径/模式| D[.git/index]</span><br><span class=\"line\">    D --&gt;|作为输入| E[git commit]</span><br><span class=\"line\">    E --&gt; F[创建 Tree 对象]</span><br><span class=\"line\">    F --&gt;|结构快照| C</span><br><span class=\"line\">    E --&gt; G[创建 Commit 对象]</span><br><span class=\"line\">    G --&gt;|指向 Tree| F</span><br><span class=\"line\">    G --&gt;|指向 Parent| H[上一个 Commit]</span><br><span class=\"line\">    G --&gt;|包含| I[作者/信息/时间]</span><br><span class=\"line\">    G --&gt;|写入| C</span><br><span class=\"line\">    G --&gt;|更新| J[分支引用 refs/heads/main]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"一、Git-的核心概念\"><a href=\"#一、Git-的核心概念\" class=\"headerlink\" title=\"一、Git 的核心概念\"></a>一、Git 的核心概念</h2><p>Git 是一个<strong>分布式版本控制系统</strong>，它通过记录文件的<strong>快照（snapshot）</strong> 而不是差异，来管理代码的历史变化。</p>\n<h3 id=\"1-四大核心对象\"><a href=\"#1-四大核心对象\" class=\"headerlink\" title=\"1. 四大核心对象\"></a>1. 四大核心对象</h3><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>作用</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Blob</strong></td>\n<td>存储文件内容（不包含文件名）</td>\n<td>内容相同 → 哈希相同</td>\n</tr>\n<tr>\n<td><strong>Tree</strong></td>\n<td>存储目录结构（文件名 + 指向 blob 或子 tree）</td>\n<td>目录的“快照”</td>\n</tr>\n<tr>\n<td><strong>Commit</strong></td>\n<td>代表一次提交，指向一个 tree，记录作者、时间、消息和父提交</td>\n<td>历史的“节点”</td>\n</tr>\n<tr>\n<td><strong>Tag</strong></td>\n<td>指向某个 commit 的固定引用，用于标记版本（如 v1.0）</td>\n<td>不会移动</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ 所有对象都通过 SHA-1 哈希唯一标识。</p>\n</blockquote>\n<hr>\n<h2 id=\"二、暂存（add）\"><a href=\"#二、暂存（add）\" class=\"headerlink\" title=\"二、暂存（add）\"></a>二、暂存（add）</h2><ul>\n<li><code>git add</code> 的作用<ul>\n<li>核心功能：将工作目录中的文件变更添加到<strong>暂存区（index）</strong> ，为下一次提交准备内容。</li>\n</ul>\n</li>\n<li>本质操作：<ul>\n<li>读取文件内容 → 生成 <strong>Blob</strong> 对象 → 更新 <code>.git/index</code> 文件。</li>\n<li>结果：暂存区记录了“下一次提交”的快照。</li>\n</ul>\n</li>\n<li><strong>暂存区（index）</strong> 存放的目录是最新的commit的tree目录和add的</li>\n</ul>\n<h2 id=\"三、提交（Commit）与快照\"><a href=\"#三、提交（Commit）与快照\" class=\"headerlink\" title=\"三、提交（Commit）与快照\"></a>三、提交（Commit）与快照</h2><ul>\n<li>每次 <code>git commit</code>：<ul>\n<li>将<strong>暂存区（index）</strong> 的当前状态打包成一个 <strong>tree</strong></li>\n<li>创建一个 <strong>commit</strong> 指向这个 tree</li>\n<li>commit 记录父提交（形成链）</li>\n</ul>\n</li>\n<li><strong>还原代码</strong>：根据 commit 找到 tree，再根据 tree 还原所有 blob，重建整个项目目录。</li>\n</ul>\n<blockquote>\n<p>🎯 Git 不是“记录变化”，而是“记录每一刻的完整状态”。</p>\n</blockquote>\n<hr>\n<h2 id=\"四、分支（Branch）\"><a href=\"#四、分支（Branch）\" class=\"headerlink\" title=\"四、分支（Branch）\"></a>四、分支（Branch）</h2><ul>\n<li><strong>分支 &#x3D; 指向某个 commit 的指针</strong></li>\n<li>默认分支通常是 <code>main</code> 或 <code>master</code></li>\n<li>分支是<strong>轻量级的</strong>，创建和切换非常快</li>\n</ul>\n<h3 id=\"常用命令：\"><a href=\"#常用命令：\" class=\"headerlink\" title=\"常用命令：\"></a>常用命令：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch                  <span class=\"comment\"># 查看分支</span></span><br><span class=\"line\">git switch &lt;name&gt;           <span class=\"comment\"># 切换分支</span></span><br><span class=\"line\">git switch -b &lt;name&gt;        <span class=\"comment\"># 创建并切换</span></span><br><span class=\"line\">git branch -d &lt;name&gt;        <span class=\"comment\"># 删除分支</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"五、合并（Merge）\"><a href=\"#五、合并（Merge）\" class=\"headerlink\" title=\"五、合并（Merge）\"></a>五、合并（Merge）</h2><p>将一个分支的修改整合到另一个分支。</p>\n<h3 id=\"两种合并方式：\"><a href=\"#两种合并方式：\" class=\"headerlink\" title=\"两种合并方式：\"></a>两种合并方式：</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>条件</th>\n<th>是否创建新 commit</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fast-forward</strong></td>\n<td>目标分支无新提交</td>\n<td>❌ 不创建</td>\n<td>直接移动分支指针，历史线性</td>\n</tr>\n<tr>\n<td><strong>True Merge</strong></td>\n<td>历史已分叉</td>\n<td>✅ 创建“合并提交”</td>\n<td>新 commit 有两个父节点</td>\n</tr>\n</tbody></table>\n<h3 id=\"合并提交的特点：\"><a href=\"#合并提交的特点：\" class=\"headerlink\" title=\"合并提交的特点：\"></a>合并提交的特点：</h3><ul>\n<li>有 <strong>两个父提交</strong>（分别来自两个分支）</li>\n<li>用 <code>git log --graph</code> 可看到分叉与合并</li>\n<li>保留完整的分支历史拓扑</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>⚠️ 可能发生<strong>冲突</strong>：需手动解决 → <code>git add</code> → <code>git commit</code></p>\n</blockquote>\n<hr>\n<h2 id=\"六、推送（Push）与拉取（Pull）\"><a href=\"#六、推送（Push）与拉取（Pull）\" class=\"headerlink\" title=\"六、推送（Push）与拉取（Pull）\"></a>六、推送（Push）与拉取（Pull）</h2><p>用于<strong>本地仓库</strong>与<strong>远程仓库</strong>（如 GitHub）同步。</p>\n<h3 id=\"1-git-push：本地-→-远程\"><a href=\"#1-git-push：本地-→-远程\" class=\"headerlink\" title=\"1. git push：本地 → 远程\"></a>1. <code>git push</code>：本地 → 远程</h3><ul>\n<li>作用：将本地的 commit 链推送到远程</li>\n<li>实质：<strong>增量推送</strong>，只传远程没有的 commit、tree、blob</li>\n<li>不是推送整个仓库！</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-git-pull：远程-→-本地\"><a href=\"#2-git-pull：远程-→-本地\" class=\"headerlink\" title=\"2. git pull：远程 → 本地\"></a>2. <code>git pull</code>：远程 → 本地</h3><ul>\n<li>作用：下载远程更新并合并到当前分支</li>\n<li>实质：<code>git pull = git fetch + git merge</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键理解：\"><a href=\"#关键理解：\" class=\"headerlink\" title=\"关键理解：\"></a>关键理解：</h3><ul>\n<li><strong>同步的是 commit 链</strong>，不是文件</li>\n<li>Git 智能分析“缺什么”，只传缺失部分</li>\n<li>分支是“同步入口”，指明从哪开始同步</li>\n</ul>\n<hr>\n<h2 id=\"七、标签（Tag）\"><a href=\"#七、标签（Tag）\" class=\"headerlink\" title=\"七、标签（Tag）\"></a>七、标签（Tag）</h2><ul>\n<li><strong>固定指针</strong>，指向某个 commit，<strong>不会移动</strong></li>\n<li>用于标记发布版本（如 v1.0、v2.1.0）</li>\n</ul>\n<h3 id=\"两种类型：\"><a href=\"#两种类型：\" class=\"headerlink\" title=\"两种类型：\"></a>两种类型：</h3><ul>\n<li><strong>轻量标签</strong>：直接指向 commit</li>\n<li><strong>附注标签</strong>：完整对象，含作者、时间、签名（推荐）</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0                    <span class=\"comment\"># 轻量</span></span><br><span class=\"line\">git tag -a v1.0 -m <span class=\"string\">&quot;Release&quot;</span>    <span class=\"comment\"># 附注</span></span><br><span class=\"line\">git push origin v1.0            <span class=\"comment\"># 推送标签（不会自动推）</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"八、核心工作流程（推荐）\"><a href=\"#八、核心工作流程（推荐）\" class=\"headerlink\" title=\"八、核心工作流程（推荐）\"></a>八、核心工作流程（推荐）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 开始工作前：拉取最新</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 创建功能分支</span></span><br><span class=\"line\">git switch -b feature/login</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 开发 &amp; 提交</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;add login form&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 推送前：再拉取一次（避免冲突）</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 推送</span></span><br><span class=\"line\">git push origin feature/login</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"九、一句话理解-Git\"><a href=\"#九、一句话理解-Git\" class=\"headerlink\" title=\"九、一句话理解 Git\"></a>九、一句话理解 Git</h2><blockquote>\n<p><strong>Git 是一个基于 commit 链的分布式快照系统。</strong></p>\n<ul>\n<li><strong>分支</strong>是移动的指针</li>\n<li><strong>合并</strong>是连接历史</li>\n<li><strong>推送&#x2F;拉取</strong>是增量同步两个仓库的 commit 链</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"🎉-你已经掌握的技能\"><a href=\"#🎉-你已经掌握的技能\" class=\"headerlink\" title=\"🎉 你已经掌握的技能\"></a>🎉 你已经掌握的技能</h2><table>\n<thead>\n<tr>\n<th>技能</th>\n<th>✅ 已掌握</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>理解 commit、tree、blob 的关系</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>使用分支进行并行开发</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>合并分支（包括合并提交）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>推送和拉取代码</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>理解 tag 的作用</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>理解 push&#x2F;pull 是基于 commit 链的增量同步</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">    A[工作目录中的文件] --&gt;|git add| B[Blob 对象]</span><br><span class=\"line\">    B --&gt;|内容存储| C[.git/objects/]</span><br><span class=\"line\">    A --&gt;|路径/模式| D[.git/index]</span><br><span class=\"line\">    D --&gt;|作为输入| E[git commit]</span><br><span class=\"line\">    E --&gt; F[创建 Tree 对象]</span><br><span class=\"line\">    F --&gt;|结构快照| C</span><br><span class=\"line\">    E --&gt; G[创建 Commit 对象]</span><br><span class=\"line\">    G --&gt;|指向 Tree| F</span><br><span class=\"line\">    G --&gt;|指向 Parent| H[上一个 Commit]</span><br><span class=\"line\">    G --&gt;|包含| I[作者/信息/时间]</span><br><span class=\"line\">    G --&gt;|写入| C</span><br><span class=\"line\">    G --&gt;|更新| J[分支引用 refs/heads/main]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"微数据和Json-LD","_content":"\n# 微数据和Json-LD\n\n## 用途\n\n让搜索引擎理解网页内容的“含义”\n\n## 怎么用\n\nhttps://schema.org 词汇表\n\n1. JSON-LD描述网页的语义\n```html\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\", // 这是“词典”的地址\n  \"@type\": \"Person\",                // \"Person\" 这个词的定义在 schema.org 上\n  \"name\": \"张三\",\n  \"jobTitle\": \"软件工程师\"\n}\n</script>\n```\n\n\n2. 微数据\n\n- itemtype 描述术语\n- itemprop 描述具体属性\n\n```html\n<div itemscope itemtype=\"https://schema.org/Person\"> <!-- \"Person\" 类型的定义来源 -->\n  <span itemprop=\"name\">张三</span> <!-- \"name\" 属性的定义也在 schema.org 上 -->\n  <span itemprop=\"jobTitle\">软件工程师</span>\n</div>\n\n```\n","source":"_posts/微数据和JSON-LD.md","raw":"---\ntitle: 微数据和Json-LD\n---\n\n# 微数据和Json-LD\n\n## 用途\n\n让搜索引擎理解网页内容的“含义”\n\n## 怎么用\n\nhttps://schema.org 词汇表\n\n1. JSON-LD描述网页的语义\n```html\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\", // 这是“词典”的地址\n  \"@type\": \"Person\",                // \"Person\" 这个词的定义在 schema.org 上\n  \"name\": \"张三\",\n  \"jobTitle\": \"软件工程师\"\n}\n</script>\n```\n\n\n2. 微数据\n\n- itemtype 描述术语\n- itemprop 描述具体属性\n\n```html\n<div itemscope itemtype=\"https://schema.org/Person\"> <!-- \"Person\" 类型的定义来源 -->\n  <span itemprop=\"name\">张三</span> <!-- \"name\" 属性的定义也在 schema.org 上 -->\n  <span itemprop=\"jobTitle\">软件工程师</span>\n</div>\n\n```\n","slug":"微数据和JSON-LD","published":1,"date":"2025-09-02T01:50:34.872Z","updated":"2025-09-01T09:54:01.761Z","_id":"cmf1wt96i000jq4v90o0ef0w2","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"微数据和Json-LD\"><a href=\"#微数据和Json-LD\" class=\"headerlink\" title=\"微数据和Json-LD\"></a>微数据和Json-LD</h1><h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>让搜索引擎理解网页内容的“含义”</p>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p><a href=\"https://schema.org/\">https://schema.org</a> 词汇表</p>\n<ol>\n<li><p>JSON-LD描述网页的语义</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;application/ld+json&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;@context&quot;</span>: <span class=\"string\">&quot;https://schema.org&quot;</span>, <span class=\"comment\">// 这是“词典”的地址</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;@type&quot;</span>: <span class=\"string\">&quot;Person&quot;</span>,                <span class=\"comment\">// &quot;Person&quot; 这个词的定义在 schema.org 上</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;张三&quot;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;jobTitle&quot;</span>: <span class=\"string\">&quot;软件工程师&quot;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>微数据</p>\n</li>\n</ol>\n<ul>\n<li>itemtype 描述术语</li>\n<li>itemprop 描述具体属性</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">itemscope</span> <span class=\"attr\">itemtype</span>=<span class=\"string\">&quot;https://schema.org/Person&quot;</span>&gt;</span> <span class=\"comment\">&lt;!-- &quot;Person&quot; 类型的定义来源 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">itemprop</span>=<span class=\"string\">&quot;name&quot;</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> <span class=\"comment\">&lt;!-- &quot;name&quot; 属性的定义也在 schema.org 上 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">itemprop</span>=<span class=\"string\">&quot;jobTitle&quot;</span>&gt;</span>软件工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"微数据和Json-LD\"><a href=\"#微数据和Json-LD\" class=\"headerlink\" title=\"微数据和Json-LD\"></a>微数据和Json-LD</h1><h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>让搜索引擎理解网页内容的“含义”</p>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p><a href=\"https://schema.org/\">https://schema.org</a> 词汇表</p>\n<ol>\n<li><p>JSON-LD描述网页的语义</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;application/ld+json&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;@context&quot;</span>: <span class=\"string\">&quot;https://schema.org&quot;</span>, <span class=\"comment\">// 这是“词典”的地址</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;@type&quot;</span>: <span class=\"string\">&quot;Person&quot;</span>,                <span class=\"comment\">// &quot;Person&quot; 这个词的定义在 schema.org 上</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;张三&quot;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"string\">&quot;jobTitle&quot;</span>: <span class=\"string\">&quot;软件工程师&quot;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>微数据</p>\n</li>\n</ol>\n<ul>\n<li>itemtype 描述术语</li>\n<li>itemprop 描述具体属性</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">itemscope</span> <span class=\"attr\">itemtype</span>=<span class=\"string\">&quot;https://schema.org/Person&quot;</span>&gt;</span> <span class=\"comment\">&lt;!-- &quot;Person&quot; 类型的定义来源 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">itemprop</span>=<span class=\"string\">&quot;name&quot;</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> <span class=\"comment\">&lt;!-- &quot;name&quot; 属性的定义也在 schema.org 上 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">itemprop</span>=<span class=\"string\">&quot;jobTitle&quot;</span>&gt;</span>软件工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"模块重新导出（桶文件）引出的性能问题分析","_content":"\n# 模块中重新导出的问题\n> [模块中关于桶文件的描述](/notes-Yian-03-模块#四、重新导出（Re-exporting）)\n\n### **什么是“桶文件”（Barrel file）？**\n\n“桶文件”（Barrel file）是一种在 JavaScript/TypeScript 项目中常见的模式。它是一个特殊的模块文件（通常命名为 `index.ts`, `index.js`, `all.ts` 等），它的主要作用是**从当前包（package）或目录下的其他多个模块中重新导出（re-export）它们的成员**，从而创建一个单一的、方便的入口点。\n\n**举个例子：**\n\n假设你有一个名为 `@my-lib/utils` 的工具库包，里面包含几个工具函数文件：\n\n```\n@my-lib/utils/\n├── src/\n│   ├── stringUtils.ts\n│   ├── numberUtils.ts\n│   └── dateUtils.ts\n└── index.ts  <-- 这就是“桶文件”\n```\n\n*   `stringUtils.ts`:\n    ```typescript\n    export function capitalize(str: string): string { ... }\n    export function reverse(str: string): string { ... }\n    ```\n*   `numberUtils.ts`:\n    ```typescript\n    export function add(a: number, b: number): number { ... }\n    export function multiply(a: number, b: number): number { ... }\n    ```\n*   `dateUtils.ts`:\n    ```typescript\n    export function formatDate(date: Date): string { ... }\n    export function isWeekend(date: Date): boolean { ... }\n    ```\n\n**使用“桶文件”前：**\n\n其他项目想要使用这些工具，需要直接导入具体的文件：\n\n```typescript\n// 在另一个项目中\nimport { capitalize } from '@my-lib/utils/src/stringUtils';\nimport { add } from '@my-lib/utils/src/numberUtils';\nimport { formatDate } from '@my-lib/utils/src/dateUtils';\n```\n\n**使用“桶文件”后：**\n\n`index.ts` (桶文件) 的内容是：\n\n```typescript\n// @my-lib/utils/index.ts\nexport * from './src/stringUtils';\nexport * from './src/numberUtils';\nexport * from './src/dateUtils';\n\n// 或者，更精确地导出特定成员\n// export { capitalize, reverse } from './src/stringUtils';\n// export { add, multiply } from './src/numberUtils';\n// export { formatDate, isWeekend } from './src/dateUtils';\n```\n\n现在，其他项目就可以通过包的根路径（通常是 `@my-lib/utils`）来导入所有内容了：\n\n```typescript\n// 在另一个项目中\nimport { capitalize, add, formatDate } from '@my-lib/utils'; // 看起来简洁多了！\n```\n\n### **为什么“桶文件”可能导致性能问题？**\n\n虽然“桶文件”看起来很方便（提供了一个统一的入口），但它在**编译、打包和代码分割**阶段可能会带来性能问题，主要原因如下：\n\n1.  **“全有或全无”（All-or-Nothing）导入**：\n    *   当你使用 `import { add } from '@my-lib/utils';` 时，你**只想要** `add` 函数。\n    *   但是，打包工具（如 Webpack, Vite, Rollup）在解析 `@my-lib/utils` 这个入口时，会加载 `index.ts` 这个桶文件。\n    *   桶文件 `index.ts` 通过 `export * from ...` 或 `export { ... } from ...` 重新导出了 `stringUtils`, `numberUtils`, `dateUtils` 中的所有内容。\n    *   打包工具为了确保 `add` 函数可用，**必须分析整个桶文件及其所有 re-export 的依赖**。即使你只用了一个函数，打包工具也可能无法 100% 确定其他未使用的函数（如 `reverse`, `formatDate`）是安全的、可以被移除的（Tree Shaking）。\n    *   **结果**：最终打包出来的应用代码里，可能包含了整个 `@my-lib/utils` 包的所有代码，即使你只用了其中一小部分。这会显著增加你的应用体积（bundle size），导致加载时间变长，影响性能。\n\n2.  **阻碍 Tree Shaking**：\n    *   Tree Shaking 是一种优化技术，旨在移除代码中未被使用的部分（死代码消除）。\n    *   `export * from './some-module'` 这种语法（通配符 re-export）尤其成问题，因为它创建了一个“命名空间”，使得静态分析工具更难精确地追踪哪些具体的导出是真正被使用的。\n    *   虽然现代打包工具和 ES 模块规范在努力改进这一点，但桶文件，特别是使用通配符的桶文件，仍然是 Tree Shaking 的一个常见障碍。\n\n3.  **循环依赖风险**：\n    *   如果桶文件的设计不当，很容易在包内部引入循环依赖（例如，`moduleA` 导入了桶文件，而桶文件又 re-export 了 `moduleA`），这可能导致运行时错误或构建失败。\n\n","source":"_posts/模块中桶文件的问题.md","raw":"---\ntitle: 模块重新导出（桶文件）引出的性能问题分析\n---\n\n# 模块中重新导出的问题\n> [模块中关于桶文件的描述](/notes-Yian-03-模块#四、重新导出（Re-exporting）)\n\n### **什么是“桶文件”（Barrel file）？**\n\n“桶文件”（Barrel file）是一种在 JavaScript/TypeScript 项目中常见的模式。它是一个特殊的模块文件（通常命名为 `index.ts`, `index.js`, `all.ts` 等），它的主要作用是**从当前包（package）或目录下的其他多个模块中重新导出（re-export）它们的成员**，从而创建一个单一的、方便的入口点。\n\n**举个例子：**\n\n假设你有一个名为 `@my-lib/utils` 的工具库包，里面包含几个工具函数文件：\n\n```\n@my-lib/utils/\n├── src/\n│   ├── stringUtils.ts\n│   ├── numberUtils.ts\n│   └── dateUtils.ts\n└── index.ts  <-- 这就是“桶文件”\n```\n\n*   `stringUtils.ts`:\n    ```typescript\n    export function capitalize(str: string): string { ... }\n    export function reverse(str: string): string { ... }\n    ```\n*   `numberUtils.ts`:\n    ```typescript\n    export function add(a: number, b: number): number { ... }\n    export function multiply(a: number, b: number): number { ... }\n    ```\n*   `dateUtils.ts`:\n    ```typescript\n    export function formatDate(date: Date): string { ... }\n    export function isWeekend(date: Date): boolean { ... }\n    ```\n\n**使用“桶文件”前：**\n\n其他项目想要使用这些工具，需要直接导入具体的文件：\n\n```typescript\n// 在另一个项目中\nimport { capitalize } from '@my-lib/utils/src/stringUtils';\nimport { add } from '@my-lib/utils/src/numberUtils';\nimport { formatDate } from '@my-lib/utils/src/dateUtils';\n```\n\n**使用“桶文件”后：**\n\n`index.ts` (桶文件) 的内容是：\n\n```typescript\n// @my-lib/utils/index.ts\nexport * from './src/stringUtils';\nexport * from './src/numberUtils';\nexport * from './src/dateUtils';\n\n// 或者，更精确地导出特定成员\n// export { capitalize, reverse } from './src/stringUtils';\n// export { add, multiply } from './src/numberUtils';\n// export { formatDate, isWeekend } from './src/dateUtils';\n```\n\n现在，其他项目就可以通过包的根路径（通常是 `@my-lib/utils`）来导入所有内容了：\n\n```typescript\n// 在另一个项目中\nimport { capitalize, add, formatDate } from '@my-lib/utils'; // 看起来简洁多了！\n```\n\n### **为什么“桶文件”可能导致性能问题？**\n\n虽然“桶文件”看起来很方便（提供了一个统一的入口），但它在**编译、打包和代码分割**阶段可能会带来性能问题，主要原因如下：\n\n1.  **“全有或全无”（All-or-Nothing）导入**：\n    *   当你使用 `import { add } from '@my-lib/utils';` 时，你**只想要** `add` 函数。\n    *   但是，打包工具（如 Webpack, Vite, Rollup）在解析 `@my-lib/utils` 这个入口时，会加载 `index.ts` 这个桶文件。\n    *   桶文件 `index.ts` 通过 `export * from ...` 或 `export { ... } from ...` 重新导出了 `stringUtils`, `numberUtils`, `dateUtils` 中的所有内容。\n    *   打包工具为了确保 `add` 函数可用，**必须分析整个桶文件及其所有 re-export 的依赖**。即使你只用了一个函数，打包工具也可能无法 100% 确定其他未使用的函数（如 `reverse`, `formatDate`）是安全的、可以被移除的（Tree Shaking）。\n    *   **结果**：最终打包出来的应用代码里，可能包含了整个 `@my-lib/utils` 包的所有代码，即使你只用了其中一小部分。这会显著增加你的应用体积（bundle size），导致加载时间变长，影响性能。\n\n2.  **阻碍 Tree Shaking**：\n    *   Tree Shaking 是一种优化技术，旨在移除代码中未被使用的部分（死代码消除）。\n    *   `export * from './some-module'` 这种语法（通配符 re-export）尤其成问题，因为它创建了一个“命名空间”，使得静态分析工具更难精确地追踪哪些具体的导出是真正被使用的。\n    *   虽然现代打包工具和 ES 模块规范在努力改进这一点，但桶文件，特别是使用通配符的桶文件，仍然是 Tree Shaking 的一个常见障碍。\n\n3.  **循环依赖风险**：\n    *   如果桶文件的设计不当，很容易在包内部引入循环依赖（例如，`moduleA` 导入了桶文件，而桶文件又 re-export 了 `moduleA`），这可能导致运行时错误或构建失败。\n\n","slug":"模块中桶文件的问题","published":1,"date":"2025-09-02T01:50:34.878Z","updated":"2025-09-01T09:54:01.762Z","_id":"cmf1wtd8q000kq4v9hinle161","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"模块中重新导出的问题\"><a href=\"#模块中重新导出的问题\" class=\"headerlink\" title=\"模块中重新导出的问题\"></a>模块中重新导出的问题</h1><blockquote>\n<p><a href=\"/notes-Yian-03-%E6%A8%A1%E5%9D%97#%E5%9B%9B%E3%80%81%E9%87%8D%E6%96%B0%E5%AF%BC%E5%87%BA%EF%BC%88Re-exporting%EF%BC%89\">模块中关于桶文件的描述</a></p>\n</blockquote>\n<h3 id=\"什么是“桶文件”（Barrel-file）？\"><a href=\"#什么是“桶文件”（Barrel-file）？\" class=\"headerlink\" title=\"什么是“桶文件”（Barrel file）？\"></a><strong>什么是“桶文件”（Barrel file）？</strong></h3><p>“桶文件”（Barrel file）是一种在 JavaScript&#x2F;TypeScript 项目中常见的模式。它是一个特殊的模块文件（通常命名为 <code>index.ts</code>, <code>index.js</code>, <code>all.ts</code> 等），它的主要作用是<strong>从当前包（package）或目录下的其他多个模块中重新导出（re-export）它们的成员</strong>，从而创建一个单一的、方便的入口点。</p>\n<p><strong>举个例子：</strong></p>\n<p>假设你有一个名为 <code>@my-lib/utils</code> 的工具库包，里面包含几个工具函数文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@my-lib/utils/</span><br><span class=\"line\">├── src/</span><br><span class=\"line\">│   ├── stringUtils.ts</span><br><span class=\"line\">│   ├── numberUtils.ts</span><br><span class=\"line\">│   └── dateUtils.ts</span><br><span class=\"line\">└── index.ts  &lt;-- 这就是“桶文件”</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>stringUtils.ts</code>:<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">capitalize</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reverse</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>numberUtils.ts</code>:<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">multiply</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>dateUtils.ts</code>:<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">formatDate</span>(<span class=\"params\"><span class=\"attr\">date</span>: <span class=\"title class_\">Date</span></span>): <span class=\"built_in\">string</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">isWeekend</span>(<span class=\"params\"><span class=\"attr\">date</span>: <span class=\"title class_\">Date</span></span>): <span class=\"built_in\">boolean</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>使用“桶文件”前：</strong></p>\n<p>其他项目想要使用这些工具，需要直接导入具体的文件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在另一个项目中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; capitalize &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils/src/stringUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils/src/numberUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; formatDate &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils/src/dateUtils&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用“桶文件”后：</strong></p>\n<p><code>index.ts</code> (桶文件) 的内容是：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @my-lib/utils/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./src/stringUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./src/numberUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./src/dateUtils&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者，更精确地导出特定成员</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; capitalize, reverse &#125; from &#x27;./src/stringUtils&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; add, multiply &#125; from &#x27;./src/numberUtils&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; formatDate, isWeekend &#125; from &#x27;./src/dateUtils&#x27;;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，其他项目就可以通过包的根路径（通常是 <code>@my-lib/utils</code>）来导入所有内容了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在另一个项目中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; capitalize, add, formatDate &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils&#x27;</span>; <span class=\"comment\">// 看起来简洁多了！</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么“桶文件”可能导致性能问题？\"><a href=\"#为什么“桶文件”可能导致性能问题？\" class=\"headerlink\" title=\"为什么“桶文件”可能导致性能问题？\"></a><strong>为什么“桶文件”可能导致性能问题？</strong></h3><p>虽然“桶文件”看起来很方便（提供了一个统一的入口），但它在<strong>编译、打包和代码分割</strong>阶段可能会带来性能问题，主要原因如下：</p>\n<ol>\n<li><p><strong>“全有或全无”（All-or-Nothing）导入</strong>：</p>\n<ul>\n<li>当你使用 <code>import &#123; add &#125; from &#39;@my-lib/utils&#39;;</code> 时，你<strong>只想要</strong> <code>add</code> 函数。</li>\n<li>但是，打包工具（如 Webpack, Vite, Rollup）在解析 <code>@my-lib/utils</code> 这个入口时，会加载 <code>index.ts</code> 这个桶文件。</li>\n<li>桶文件 <code>index.ts</code> 通过 <code>export * from ...</code> 或 <code>export &#123; ... &#125; from ...</code> 重新导出了 <code>stringUtils</code>, <code>numberUtils</code>, <code>dateUtils</code> 中的所有内容。</li>\n<li>打包工具为了确保 <code>add</code> 函数可用，<strong>必须分析整个桶文件及其所有 re-export 的依赖</strong>。即使你只用了一个函数，打包工具也可能无法 100% 确定其他未使用的函数（如 <code>reverse</code>, <code>formatDate</code>）是安全的、可以被移除的（Tree Shaking）。</li>\n<li><strong>结果</strong>：最终打包出来的应用代码里，可能包含了整个 <code>@my-lib/utils</code> 包的所有代码，即使你只用了其中一小部分。这会显著增加你的应用体积（bundle size），导致加载时间变长，影响性能。</li>\n</ul>\n</li>\n<li><p><strong>阻碍 Tree Shaking</strong>：</p>\n<ul>\n<li>Tree Shaking 是一种优化技术，旨在移除代码中未被使用的部分（死代码消除）。</li>\n<li><code>export * from &#39;./some-module&#39;</code> 这种语法（通配符 re-export）尤其成问题，因为它创建了一个“命名空间”，使得静态分析工具更难精确地追踪哪些具体的导出是真正被使用的。</li>\n<li>虽然现代打包工具和 ES 模块规范在努力改进这一点，但桶文件，特别是使用通配符的桶文件，仍然是 Tree Shaking 的一个常见障碍。</li>\n</ul>\n</li>\n<li><p><strong>循环依赖风险</strong>：</p>\n<ul>\n<li>如果桶文件的设计不当，很容易在包内部引入循环依赖（例如，<code>moduleA</code> 导入了桶文件，而桶文件又 re-export 了 <code>moduleA</code>），这可能导致运行时错误或构建失败。</li>\n</ul>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"模块中重新导出的问题\"><a href=\"#模块中重新导出的问题\" class=\"headerlink\" title=\"模块中重新导出的问题\"></a>模块中重新导出的问题</h1><blockquote>\n<p><a href=\"/notes-Yian-03-%E6%A8%A1%E5%9D%97#%E5%9B%9B%E3%80%81%E9%87%8D%E6%96%B0%E5%AF%BC%E5%87%BA%EF%BC%88Re-exporting%EF%BC%89\">模块中关于桶文件的描述</a></p>\n</blockquote>\n<h3 id=\"什么是“桶文件”（Barrel-file）？\"><a href=\"#什么是“桶文件”（Barrel-file）？\" class=\"headerlink\" title=\"什么是“桶文件”（Barrel file）？\"></a><strong>什么是“桶文件”（Barrel file）？</strong></h3><p>“桶文件”（Barrel file）是一种在 JavaScript&#x2F;TypeScript 项目中常见的模式。它是一个特殊的模块文件（通常命名为 <code>index.ts</code>, <code>index.js</code>, <code>all.ts</code> 等），它的主要作用是<strong>从当前包（package）或目录下的其他多个模块中重新导出（re-export）它们的成员</strong>，从而创建一个单一的、方便的入口点。</p>\n<p><strong>举个例子：</strong></p>\n<p>假设你有一个名为 <code>@my-lib/utils</code> 的工具库包，里面包含几个工具函数文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@my-lib/utils/</span><br><span class=\"line\">├── src/</span><br><span class=\"line\">│   ├── stringUtils.ts</span><br><span class=\"line\">│   ├── numberUtils.ts</span><br><span class=\"line\">│   └── dateUtils.ts</span><br><span class=\"line\">└── index.ts  &lt;-- 这就是“桶文件”</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>stringUtils.ts</code>:<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">capitalize</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reverse</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>numberUtils.ts</code>:<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">multiply</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>dateUtils.ts</code>:<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">formatDate</span>(<span class=\"params\"><span class=\"attr\">date</span>: <span class=\"title class_\">Date</span></span>): <span class=\"built_in\">string</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">isWeekend</span>(<span class=\"params\"><span class=\"attr\">date</span>: <span class=\"title class_\">Date</span></span>): <span class=\"built_in\">boolean</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>使用“桶文件”前：</strong></p>\n<p>其他项目想要使用这些工具，需要直接导入具体的文件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在另一个项目中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; capitalize &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils/src/stringUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils/src/numberUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; formatDate &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils/src/dateUtils&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用“桶文件”后：</strong></p>\n<p><code>index.ts</code> (桶文件) 的内容是：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @my-lib/utils/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./src/stringUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./src/numberUtils&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./src/dateUtils&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者，更精确地导出特定成员</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; capitalize, reverse &#125; from &#x27;./src/stringUtils&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; add, multiply &#125; from &#x27;./src/numberUtils&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; formatDate, isWeekend &#125; from &#x27;./src/dateUtils&#x27;;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，其他项目就可以通过包的根路径（通常是 <code>@my-lib/utils</code>）来导入所有内容了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在另一个项目中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; capitalize, add, formatDate &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@my-lib/utils&#x27;</span>; <span class=\"comment\">// 看起来简洁多了！</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么“桶文件”可能导致性能问题？\"><a href=\"#为什么“桶文件”可能导致性能问题？\" class=\"headerlink\" title=\"为什么“桶文件”可能导致性能问题？\"></a><strong>为什么“桶文件”可能导致性能问题？</strong></h3><p>虽然“桶文件”看起来很方便（提供了一个统一的入口），但它在<strong>编译、打包和代码分割</strong>阶段可能会带来性能问题，主要原因如下：</p>\n<ol>\n<li><p><strong>“全有或全无”（All-or-Nothing）导入</strong>：</p>\n<ul>\n<li>当你使用 <code>import &#123; add &#125; from &#39;@my-lib/utils&#39;;</code> 时，你<strong>只想要</strong> <code>add</code> 函数。</li>\n<li>但是，打包工具（如 Webpack, Vite, Rollup）在解析 <code>@my-lib/utils</code> 这个入口时，会加载 <code>index.ts</code> 这个桶文件。</li>\n<li>桶文件 <code>index.ts</code> 通过 <code>export * from ...</code> 或 <code>export &#123; ... &#125; from ...</code> 重新导出了 <code>stringUtils</code>, <code>numberUtils</code>, <code>dateUtils</code> 中的所有内容。</li>\n<li>打包工具为了确保 <code>add</code> 函数可用，<strong>必须分析整个桶文件及其所有 re-export 的依赖</strong>。即使你只用了一个函数，打包工具也可能无法 100% 确定其他未使用的函数（如 <code>reverse</code>, <code>formatDate</code>）是安全的、可以被移除的（Tree Shaking）。</li>\n<li><strong>结果</strong>：最终打包出来的应用代码里，可能包含了整个 <code>@my-lib/utils</code> 包的所有代码，即使你只用了其中一小部分。这会显著增加你的应用体积（bundle size），导致加载时间变长，影响性能。</li>\n</ul>\n</li>\n<li><p><strong>阻碍 Tree Shaking</strong>：</p>\n<ul>\n<li>Tree Shaking 是一种优化技术，旨在移除代码中未被使用的部分（死代码消除）。</li>\n<li><code>export * from &#39;./some-module&#39;</code> 这种语法（通配符 re-export）尤其成问题，因为它创建了一个“命名空间”，使得静态分析工具更难精确地追踪哪些具体的导出是真正被使用的。</li>\n<li>虽然现代打包工具和 ES 模块规范在努力改进这一点，但桶文件，特别是使用通配符的桶文件，仍然是 Tree Shaking 的一个常见障碍。</li>\n</ul>\n</li>\n<li><p><strong>循环依赖风险</strong>：</p>\n<ul>\n<li>如果桶文件的设计不当，很容易在包内部引入循环依赖（例如，<code>moduleA</code> 导入了桶文件，而桶文件又 re-export 了 <code>moduleA</code>），这可能导致运行时错误或构建失败。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"📚 JavaScript 模块系统深度笔记","date":"2025-09-01T02:00:00.000Z","updated":"2025-09-02T03:00:00.000Z","_content":"\n\n> **| 涵盖：导入导出、执行机制、跨平台设计**\n\n---\n## 零、区分“传统脚本”和“模块脚本”\n\n## 一、模块基础：`import` 与 `export`\n\n### 1. 导出（`export`）\n\n| 类型 | 语法 | 特点 |\n| :--- | :--- | :--- |\n| **命名导出** | `export const name = 'Alice';`<br>`export function greet() {}`<br>`export { name, greet };` | 可多个，导入时名字必须匹配 |\n| **默认导出** | `export default function() {}`<br>`export default obj;` | 每模块最多一个，导入时可自定义名字 |\n\n### 2. 导入（`import`）\n\n| 场景 | 语法 | 说明 |\n| :--- | :--- | :--- |\n| 导入命名导出 | `import { name, greet } from './utils.js';` | 名字必须匹配 |\n| 导入默认导出 | `import main from './utils.js';` | 名字可自定义 |\n| 同时导入 | `import main, { version } from './utils.js';` | 默认 + 命名 |\n| 全部导入 | `import * as utils from './utils.js';` | `utils` 是命名空间对象 |\n| 只执行（副作用） | `import './polyfill.js';` | 不导入值，只执行代码 |\n\n---\n\n## 二、模块的执行机制\n\n### ✅ 模块只会执行一次（单例）\n\n- 第一次 `import`：**执行文件代码**（顶层代码）。\n- 后续 `import`：**不执行**，直接从**模块缓存**中取结果。\n- 所有导入者共享**同一个状态**（如 `let count = 0`）。\n\n```js\n// utils.js\nlet count = 0;\nexport const inc = () => count++;\n```\n\n```js\n// a.js 和 b.js 都 import inc → 共享同一个 count\n```\n\n---\n\n### 🔗 `import` 的本质：创建“实时指针”（Live Binding）\n\n- `import` 不是“拷贝值”，而是创建一个**指向目标变量的指针**。\n- 即使变量后续改变，所有导入者都能看到最新值。\n\n```js\n// counter.js\nexport let count = 0;\nexport const inc = () => count++;\n\n// a.js\nimport { count } from './counter.js';\nconsole.log(count); // 0\ninc();\nconsole.log(count); // 1 ← 自动更新！\n```\n\n---\n\n## 三、模块加载流程（4 阶段）\n\n| 阶段 | 说明 |\n| :--- | :--- |\n| **1. 解析** | 静态分析 `import/export`，构建依赖图，验证语法 |\n| **2. 加载** | 下载模块文件（网络/文件系统） |\n| **3. 链接** | 创建“模块环境记录”，建立“实时绑定”（指针） |\n| **4. 执行** | 执行顶层代码，初始化 `export` 变量 |\n\n> ⚠️ 顺序：深度优先，依赖项先执行。\n\n---\n\n## 四、重新导出（Re-exporting）\n\n| 语法 | 作用 | 是否包含 `default` |\n| :--- | :--- | :--- |\n| `export * from 'x.js'` | 透传 `x.js` 的所有**命名导出** | ❌ 否 |\n| `export { name } from 'x.js'` | 只导出 `x.js` 的 `name` | ❌ 否 |\n| `export { default } from 'x.js'` | 透传 `default` 导出 | ✅ 是 |\n| `export { name as newName } from 'x.js'` | 重命名导出 | ✅ 可重命名 |\n\n> 🎯 用途：创建聚合模块（如 `index.js`）。\n\n---\n\n## 五、`default` vs 命名导出\n\n| 问题 | 答案 |\n| :--- | :--- |\n| `export default` 能用 `{}` 接收吗？ | ❌ 不能！必须用 `import xxx from` |\n| 命名导出能用 `import xxx from` 接收吗？ | ❌ 不能！必须用 `import { xxx } from` |\n| 如何同时导入？ | `import defaultName, { named } from 'module'` |\n| `default` 能重命名吗？ | ✅ `import { default as main } from 'module'` |\n\n---\n\n## 六、模块的跨平台挑战与解决方案\n\n### ❗ 问题：环境差异\n\n| 环境 | 特有全局变量 |\n| :--- | :--- |\n| 浏览器 | `window`, `document`, `localStorage` |\n| Node.js | `process`, `require`, `__dirname` |\n\n> ❌ 模块若依赖 `window`，在 Node.js 中会报错。\n\n---\n\n### ✅ 解决方案 1：分层架构 —— “核心 + 绑定”\n\n```text\n        +------------------+\n        |   应用层         |\n        +--------+---------+\n                 |\n        +--------v---------+\n        |   绑定层 (Bindings)|\n        | - browser.js     |\n        | - node.js        |\n        +--------+---------+\n                 |\n        +--------v---------+\n        |   核心层 (Core)  |\n        | - 纯逻辑：hash, validate |\n        | - 无环境依赖     |\n        +------------------+\n```\n\n#### ✅ 优点：\n- 核心可无限复用。\n- 绑定轻量、可替换。\n- 易测试、易维护。\n\n---\n\n### ✅ 解决方案 2：运行时检测（Feature Detection）\n\n```js\nlet password;\nif (typeof process !== 'undefined' && process.env.PASSWORD) {\n  password = process.env.PASSWORD; // Node.js\n} else if (typeof document !== 'undefined') {\n  password = document.getElementById('password')?.value; // 浏览器\n} else {\n  throw new Error('No password source');\n}\n```\n\n> 🔑 原则：**检测功能，不检测环境**。\n\n---\n\n### ✅ 解决方案 3：Polyfill + 动态导入\n\n```js\n// 确保 fetch 在所有环境可用\nif (typeof fetch === 'undefined') {\n  globalThis.fetch = (await import('node-fetch')).default;\n}\n```\n\n> 🔑 使用 `globalThis`：在所有环境中都指向全局对象。\n\n---\n\n## 七、最佳实践清单\n\n| 原则 | 建议 |\n| :--- | :--- |\n| 🧱 **分离关注点** | 核心逻辑 vs I/O 操作 |\n| 🔍 **检测功能** | `typeof fetch === 'function'` 而非 `window` |\n| 🌐 **使用 `globalThis`** | 安全访问全局对象 |\n| 📦 **小模块，高内聚** | 一个模块只做一件事 |\n| 🧪 **测试核心** | 纯函数易单元测试 |\n| 📚 **文档说明** | 标注模块的环境依赖 |\n\n---\n\n## 🎯 总结口诀\n\n> **“一缓存、二绑定、三核心、四检测”**\n>\n> 1. **一缓存**：模块只执行一次，结果缓存共享。\n> 2. **二绑定**：`import` 是实时指针，不是值拷贝。\n> 3. **三核心**：纯逻辑独立，不依赖环境。\n> 4. **四检测**：用 `typeof` 检测功能，实现跨平台。\n```\n","source":"_posts/模块.md","raw":"---\ntitle: 📚 JavaScript 模块系统深度笔记\ndate: 2025-09-01 10:00:00\nupdated: 2025-09-02 11:00:00\n---\n\n\n> **| 涵盖：导入导出、执行机制、跨平台设计**\n\n---\n## 零、区分“传统脚本”和“模块脚本”\n\n## 一、模块基础：`import` 与 `export`\n\n### 1. 导出（`export`）\n\n| 类型 | 语法 | 特点 |\n| :--- | :--- | :--- |\n| **命名导出** | `export const name = 'Alice';`<br>`export function greet() {}`<br>`export { name, greet };` | 可多个，导入时名字必须匹配 |\n| **默认导出** | `export default function() {}`<br>`export default obj;` | 每模块最多一个，导入时可自定义名字 |\n\n### 2. 导入（`import`）\n\n| 场景 | 语法 | 说明 |\n| :--- | :--- | :--- |\n| 导入命名导出 | `import { name, greet } from './utils.js';` | 名字必须匹配 |\n| 导入默认导出 | `import main from './utils.js';` | 名字可自定义 |\n| 同时导入 | `import main, { version } from './utils.js';` | 默认 + 命名 |\n| 全部导入 | `import * as utils from './utils.js';` | `utils` 是命名空间对象 |\n| 只执行（副作用） | `import './polyfill.js';` | 不导入值，只执行代码 |\n\n---\n\n## 二、模块的执行机制\n\n### ✅ 模块只会执行一次（单例）\n\n- 第一次 `import`：**执行文件代码**（顶层代码）。\n- 后续 `import`：**不执行**，直接从**模块缓存**中取结果。\n- 所有导入者共享**同一个状态**（如 `let count = 0`）。\n\n```js\n// utils.js\nlet count = 0;\nexport const inc = () => count++;\n```\n\n```js\n// a.js 和 b.js 都 import inc → 共享同一个 count\n```\n\n---\n\n### 🔗 `import` 的本质：创建“实时指针”（Live Binding）\n\n- `import` 不是“拷贝值”，而是创建一个**指向目标变量的指针**。\n- 即使变量后续改变，所有导入者都能看到最新值。\n\n```js\n// counter.js\nexport let count = 0;\nexport const inc = () => count++;\n\n// a.js\nimport { count } from './counter.js';\nconsole.log(count); // 0\ninc();\nconsole.log(count); // 1 ← 自动更新！\n```\n\n---\n\n## 三、模块加载流程（4 阶段）\n\n| 阶段 | 说明 |\n| :--- | :--- |\n| **1. 解析** | 静态分析 `import/export`，构建依赖图，验证语法 |\n| **2. 加载** | 下载模块文件（网络/文件系统） |\n| **3. 链接** | 创建“模块环境记录”，建立“实时绑定”（指针） |\n| **4. 执行** | 执行顶层代码，初始化 `export` 变量 |\n\n> ⚠️ 顺序：深度优先，依赖项先执行。\n\n---\n\n## 四、重新导出（Re-exporting）\n\n| 语法 | 作用 | 是否包含 `default` |\n| :--- | :--- | :--- |\n| `export * from 'x.js'` | 透传 `x.js` 的所有**命名导出** | ❌ 否 |\n| `export { name } from 'x.js'` | 只导出 `x.js` 的 `name` | ❌ 否 |\n| `export { default } from 'x.js'` | 透传 `default` 导出 | ✅ 是 |\n| `export { name as newName } from 'x.js'` | 重命名导出 | ✅ 可重命名 |\n\n> 🎯 用途：创建聚合模块（如 `index.js`）。\n\n---\n\n## 五、`default` vs 命名导出\n\n| 问题 | 答案 |\n| :--- | :--- |\n| `export default` 能用 `{}` 接收吗？ | ❌ 不能！必须用 `import xxx from` |\n| 命名导出能用 `import xxx from` 接收吗？ | ❌ 不能！必须用 `import { xxx } from` |\n| 如何同时导入？ | `import defaultName, { named } from 'module'` |\n| `default` 能重命名吗？ | ✅ `import { default as main } from 'module'` |\n\n---\n\n## 六、模块的跨平台挑战与解决方案\n\n### ❗ 问题：环境差异\n\n| 环境 | 特有全局变量 |\n| :--- | :--- |\n| 浏览器 | `window`, `document`, `localStorage` |\n| Node.js | `process`, `require`, `__dirname` |\n\n> ❌ 模块若依赖 `window`，在 Node.js 中会报错。\n\n---\n\n### ✅ 解决方案 1：分层架构 —— “核心 + 绑定”\n\n```text\n        +------------------+\n        |   应用层         |\n        +--------+---------+\n                 |\n        +--------v---------+\n        |   绑定层 (Bindings)|\n        | - browser.js     |\n        | - node.js        |\n        +--------+---------+\n                 |\n        +--------v---------+\n        |   核心层 (Core)  |\n        | - 纯逻辑：hash, validate |\n        | - 无环境依赖     |\n        +------------------+\n```\n\n#### ✅ 优点：\n- 核心可无限复用。\n- 绑定轻量、可替换。\n- 易测试、易维护。\n\n---\n\n### ✅ 解决方案 2：运行时检测（Feature Detection）\n\n```js\nlet password;\nif (typeof process !== 'undefined' && process.env.PASSWORD) {\n  password = process.env.PASSWORD; // Node.js\n} else if (typeof document !== 'undefined') {\n  password = document.getElementById('password')?.value; // 浏览器\n} else {\n  throw new Error('No password source');\n}\n```\n\n> 🔑 原则：**检测功能，不检测环境**。\n\n---\n\n### ✅ 解决方案 3：Polyfill + 动态导入\n\n```js\n// 确保 fetch 在所有环境可用\nif (typeof fetch === 'undefined') {\n  globalThis.fetch = (await import('node-fetch')).default;\n}\n```\n\n> 🔑 使用 `globalThis`：在所有环境中都指向全局对象。\n\n---\n\n## 七、最佳实践清单\n\n| 原则 | 建议 |\n| :--- | :--- |\n| 🧱 **分离关注点** | 核心逻辑 vs I/O 操作 |\n| 🔍 **检测功能** | `typeof fetch === 'function'` 而非 `window` |\n| 🌐 **使用 `globalThis`** | 安全访问全局对象 |\n| 📦 **小模块，高内聚** | 一个模块只做一件事 |\n| 🧪 **测试核心** | 纯函数易单元测试 |\n| 📚 **文档说明** | 标注模块的环境依赖 |\n\n---\n\n## 🎯 总结口诀\n\n> **“一缓存、二绑定、三核心、四检测”**\n>\n> 1. **一缓存**：模块只执行一次，结果缓存共享。\n> 2. **二绑定**：`import` 是实时指针，不是值拷贝。\n> 3. **三核心**：纯逻辑独立，不依赖环境。\n> 4. **四检测**：用 `typeof` 检测功能，实现跨平台。\n```\n","slug":"模块","published":1,"_id":"cmf1wtgso000lq4v924wffp3p","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><strong>| 涵盖：导入导出、执行机制、跨平台设计</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"零、区分“传统脚本”和“模块脚本”\"><a href=\"#零、区分“传统脚本”和“模块脚本”\" class=\"headerlink\" title=\"零、区分“传统脚本”和“模块脚本”\"></a>零、区分“传统脚本”和“模块脚本”</h2><h2 id=\"一、模块基础：import-与-export\"><a href=\"#一、模块基础：import-与-export\" class=\"headerlink\" title=\"一、模块基础：import 与 export\"></a>一、模块基础：<code>import</code> 与 <code>export</code></h2><h3 id=\"1-导出（export）\"><a href=\"#1-导出（export）\" class=\"headerlink\" title=\"1. 导出（export）\"></a>1. 导出（<code>export</code>）</h3><table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">语法</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>命名导出</strong></td>\n<td align=\"left\"><code>export const name = &#39;Alice&#39;;</code><br><code>export function greet() &#123;&#125;</code><br><code>export &#123; name, greet &#125;;</code></td>\n<td align=\"left\">可多个，导入时名字必须匹配</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>默认导出</strong></td>\n<td align=\"left\"><code>export default function() &#123;&#125;</code><br><code>export default obj;</code></td>\n<td align=\"left\">每模块最多一个，导入时可自定义名字</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-导入（import）\"><a href=\"#2-导入（import）\" class=\"headerlink\" title=\"2. 导入（import）\"></a>2. 导入（<code>import</code>）</h3><table>\n<thead>\n<tr>\n<th align=\"left\">场景</th>\n<th align=\"left\">语法</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">导入命名导出</td>\n<td align=\"left\"><code>import &#123; name, greet &#125; from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\">名字必须匹配</td>\n</tr>\n<tr>\n<td align=\"left\">导入默认导出</td>\n<td align=\"left\"><code>import main from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\">名字可自定义</td>\n</tr>\n<tr>\n<td align=\"left\">同时导入</td>\n<td align=\"left\"><code>import main, &#123; version &#125; from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\">默认 + 命名</td>\n</tr>\n<tr>\n<td align=\"left\">全部导入</td>\n<td align=\"left\"><code>import * as utils from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\"><code>utils</code> 是命名空间对象</td>\n</tr>\n<tr>\n<td align=\"left\">只执行（副作用）</td>\n<td align=\"left\"><code>import &#39;./polyfill.js&#39;;</code></td>\n<td align=\"left\">不导入值，只执行代码</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"二、模块的执行机制\"><a href=\"#二、模块的执行机制\" class=\"headerlink\" title=\"二、模块的执行机制\"></a>二、模块的执行机制</h2><h3 id=\"✅-模块只会执行一次（单例）\"><a href=\"#✅-模块只会执行一次（单例）\" class=\"headerlink\" title=\"✅ 模块只会执行一次（单例）\"></a>✅ 模块只会执行一次（单例）</h3><ul>\n<li>第一次 <code>import</code>：<strong>执行文件代码</strong>（顶层代码）。</li>\n<li>后续 <code>import</code>：<strong>不执行</strong>，直接从<strong>模块缓存</strong>中取结果。</li>\n<li>所有导入者共享<strong>同一个状态</strong>（如 <code>let count = 0</code>）。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">inc</span> = (<span class=\"params\"></span>) =&gt; count++;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js 和 b.js 都 import inc → 共享同一个 count</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"🔗-import-的本质：创建“实时指针”（Live-Binding）\"><a href=\"#🔗-import-的本质：创建“实时指针”（Live-Binding）\" class=\"headerlink\" title=\"🔗 import 的本质：创建“实时指针”（Live Binding）\"></a>🔗 <code>import</code> 的本质：创建“实时指针”（Live Binding）</h3><ul>\n<li><code>import</code> 不是“拷贝值”，而是创建一个<strong>指向目标变量的指针</strong>。</li>\n<li>即使变量后续改变，所有导入者都能看到最新值。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// counter.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">inc</span> = (<span class=\"params\"></span>) =&gt; count++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; count &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./counter.js&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title function_\">inc</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 1 ← 自动更新！</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"三、模块加载流程（4-阶段）\"><a href=\"#三、模块加载流程（4-阶段）\" class=\"headerlink\" title=\"三、模块加载流程（4 阶段）\"></a>三、模块加载流程（4 阶段）</h2><table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>1. 解析</strong></td>\n<td align=\"left\">静态分析 <code>import/export</code>，构建依赖图，验证语法</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>2. 加载</strong></td>\n<td align=\"left\">下载模块文件（网络&#x2F;文件系统）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>3. 链接</strong></td>\n<td align=\"left\">创建“模块环境记录”，建立“实时绑定”（指针）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>4. 执行</strong></td>\n<td align=\"left\">执行顶层代码，初始化 <code>export</code> 变量</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ 顺序：深度优先，依赖项先执行。</p>\n</blockquote>\n<hr>\n<h2 id=\"四、重新导出（Re-exporting）\"><a href=\"#四、重新导出（Re-exporting）\" class=\"headerlink\" title=\"四、重新导出（Re-exporting）\"></a>四、重新导出（Re-exporting）</h2><table>\n<thead>\n<tr>\n<th align=\"left\">语法</th>\n<th align=\"left\">作用</th>\n<th align=\"left\">是否包含 <code>default</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>export * from &#39;x.js&#39;</code></td>\n<td align=\"left\">透传 <code>x.js</code> 的所有<strong>命名导出</strong></td>\n<td align=\"left\">❌ 否</td>\n</tr>\n<tr>\n<td align=\"left\"><code>export &#123; name &#125; from &#39;x.js&#39;</code></td>\n<td align=\"left\">只导出 <code>x.js</code> 的 <code>name</code></td>\n<td align=\"left\">❌ 否</td>\n</tr>\n<tr>\n<td align=\"left\"><code>export &#123; default &#125; from &#39;x.js&#39;</code></td>\n<td align=\"left\">透传 <code>default</code> 导出</td>\n<td align=\"left\">✅ 是</td>\n</tr>\n<tr>\n<td align=\"left\"><code>export &#123; name as newName &#125; from &#39;x.js&#39;</code></td>\n<td align=\"left\">重命名导出</td>\n<td align=\"left\">✅ 可重命名</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>🎯 用途：创建聚合模块（如 <code>index.js</code>）。</p>\n</blockquote>\n<hr>\n<h2 id=\"五、default-vs-命名导出\"><a href=\"#五、default-vs-命名导出\" class=\"headerlink\" title=\"五、default vs 命名导出\"></a>五、<code>default</code> vs 命名导出</h2><table>\n<thead>\n<tr>\n<th align=\"left\">问题</th>\n<th align=\"left\">答案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>export default</code> 能用 <code>&#123;&#125;</code> 接收吗？</td>\n<td align=\"left\">❌ 不能！必须用 <code>import xxx from</code></td>\n</tr>\n<tr>\n<td align=\"left\">命名导出能用 <code>import xxx from</code> 接收吗？</td>\n<td align=\"left\">❌ 不能！必须用 <code>import &#123; xxx &#125; from</code></td>\n</tr>\n<tr>\n<td align=\"left\">如何同时导入？</td>\n<td align=\"left\"><code>import defaultName, &#123; named &#125; from &#39;module&#39;</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>default</code> 能重命名吗？</td>\n<td align=\"left\">✅ <code>import &#123; default as main &#125; from &#39;module&#39;</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"六、模块的跨平台挑战与解决方案\"><a href=\"#六、模块的跨平台挑战与解决方案\" class=\"headerlink\" title=\"六、模块的跨平台挑战与解决方案\"></a>六、模块的跨平台挑战与解决方案</h2><h3 id=\"❗-问题：环境差异\"><a href=\"#❗-问题：环境差异\" class=\"headerlink\" title=\"❗ 问题：环境差异\"></a>❗ 问题：环境差异</h3><table>\n<thead>\n<tr>\n<th align=\"left\">环境</th>\n<th align=\"left\">特有全局变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">浏览器</td>\n<td align=\"left\"><code>window</code>, <code>document</code>, <code>localStorage</code></td>\n</tr>\n<tr>\n<td align=\"left\">Node.js</td>\n<td align=\"left\"><code>process</code>, <code>require</code>, <code>__dirname</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>❌ 模块若依赖 <code>window</code>，在 Node.js 中会报错。</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-解决方案-1：分层架构-——-“核心-绑定”\"><a href=\"#✅-解决方案-1：分层架构-——-“核心-绑定”\" class=\"headerlink\" title=\"✅ 解决方案 1：分层架构 —— “核心 + 绑定”\"></a>✅ 解决方案 1：分层架构 —— “核心 + 绑定”</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">|   应用层         |</span><br><span class=\"line\">+--------+---------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">+--------v---------+</span><br><span class=\"line\">|   绑定层 (Bindings)|</span><br><span class=\"line\">| - browser.js     |</span><br><span class=\"line\">| - node.js        |</span><br><span class=\"line\">+--------+---------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">+--------v---------+</span><br><span class=\"line\">|   核心层 (Core)  |</span><br><span class=\"line\">| - 纯逻辑：hash, validate |</span><br><span class=\"line\">| - 无环境依赖     |</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"✅-优点：\"><a href=\"#✅-优点：\" class=\"headerlink\" title=\"✅ 优点：\"></a>✅ 优点：</h4><ul>\n<li>核心可无限复用。</li>\n<li>绑定轻量、可替换。</li>\n<li>易测试、易维护。</li>\n</ul>\n<hr>\n<h3 id=\"✅-解决方案-2：运行时检测（Feature-Detection）\"><a href=\"#✅-解决方案-2：运行时检测（Feature-Detection）\" class=\"headerlink\" title=\"✅ 解决方案 2：运行时检测（Feature Detection）\"></a>✅ 解决方案 2：运行时检测（Feature Detection）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> password;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> process !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; process.<span class=\"property\">env</span>.<span class=\"property\">PASSWORD</span>) &#123;</span><br><span class=\"line\">  password = process.<span class=\"property\">env</span>.<span class=\"property\">PASSWORD</span>; <span class=\"comment\">// Node.js</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">document</span> !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  password = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;password&#x27;</span>)?.<span class=\"property\">value</span>; <span class=\"comment\">// 浏览器</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;No password source&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>🔑 原则：<strong>检测功能，不检测环境</strong>。</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-解决方案-3：Polyfill-动态导入\"><a href=\"#✅-解决方案-3：Polyfill-动态导入\" class=\"headerlink\" title=\"✅ 解决方案 3：Polyfill + 动态导入\"></a>✅ 解决方案 3：Polyfill + 动态导入</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 确保 fetch 在所有环境可用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fetch === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  globalThis.<span class=\"property\">fetch</span> = (<span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;node-fetch&#x27;</span>)).<span class=\"property\">default</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>🔑 使用 <code>globalThis</code>：在所有环境中都指向全局对象。</p>\n</blockquote>\n<hr>\n<h2 id=\"七、最佳实践清单\"><a href=\"#七、最佳实践清单\" class=\"headerlink\" title=\"七、最佳实践清单\"></a>七、最佳实践清单</h2><table>\n<thead>\n<tr>\n<th align=\"left\">原则</th>\n<th align=\"left\">建议</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">🧱 <strong>分离关注点</strong></td>\n<td align=\"left\">核心逻辑 vs I&#x2F;O 操作</td>\n</tr>\n<tr>\n<td align=\"left\">🔍 <strong>检测功能</strong></td>\n<td align=\"left\"><code>typeof fetch === &#39;function&#39;</code> 而非 <code>window</code></td>\n</tr>\n<tr>\n<td align=\"left\">🌐 <strong>使用 <code>globalThis</code></strong></td>\n<td align=\"left\">安全访问全局对象</td>\n</tr>\n<tr>\n<td align=\"left\">📦 <strong>小模块，高内聚</strong></td>\n<td align=\"left\">一个模块只做一件事</td>\n</tr>\n<tr>\n<td align=\"left\">🧪 <strong>测试核心</strong></td>\n<td align=\"left\">纯函数易单元测试</td>\n</tr>\n<tr>\n<td align=\"left\">📚 <strong>文档说明</strong></td>\n<td align=\"left\">标注模块的环境依赖</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🎯-总结口诀\"><a href=\"#🎯-总结口诀\" class=\"headerlink\" title=\"🎯 总结口诀\"></a>🎯 总结口诀</h2><blockquote>\n<p><strong>“一缓存、二绑定、三核心、四检测”</strong></p>\n<ol>\n<li><strong>一缓存</strong>：模块只执行一次，结果缓存共享。</li>\n<li><strong>二绑定</strong>：<code>import</code> 是实时指针，不是值拷贝。</li>\n<li><strong>三核心</strong>：纯逻辑独立，不依赖环境。</li>\n<li><strong>四检测</strong>：用 <code>typeof</code> 检测功能，实现跨平台。</li>\n</ol>\n</blockquote>\n<pre><code>\n</code></pre>\n","excerpt":"","more":"<blockquote>\n<p><strong>| 涵盖：导入导出、执行机制、跨平台设计</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"零、区分“传统脚本”和“模块脚本”\"><a href=\"#零、区分“传统脚本”和“模块脚本”\" class=\"headerlink\" title=\"零、区分“传统脚本”和“模块脚本”\"></a>零、区分“传统脚本”和“模块脚本”</h2><h2 id=\"一、模块基础：import-与-export\"><a href=\"#一、模块基础：import-与-export\" class=\"headerlink\" title=\"一、模块基础：import 与 export\"></a>一、模块基础：<code>import</code> 与 <code>export</code></h2><h3 id=\"1-导出（export）\"><a href=\"#1-导出（export）\" class=\"headerlink\" title=\"1. 导出（export）\"></a>1. 导出（<code>export</code>）</h3><table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">语法</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>命名导出</strong></td>\n<td align=\"left\"><code>export const name = &#39;Alice&#39;;</code><br><code>export function greet() &#123;&#125;</code><br><code>export &#123; name, greet &#125;;</code></td>\n<td align=\"left\">可多个，导入时名字必须匹配</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>默认导出</strong></td>\n<td align=\"left\"><code>export default function() &#123;&#125;</code><br><code>export default obj;</code></td>\n<td align=\"left\">每模块最多一个，导入时可自定义名字</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-导入（import）\"><a href=\"#2-导入（import）\" class=\"headerlink\" title=\"2. 导入（import）\"></a>2. 导入（<code>import</code>）</h3><table>\n<thead>\n<tr>\n<th align=\"left\">场景</th>\n<th align=\"left\">语法</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">导入命名导出</td>\n<td align=\"left\"><code>import &#123; name, greet &#125; from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\">名字必须匹配</td>\n</tr>\n<tr>\n<td align=\"left\">导入默认导出</td>\n<td align=\"left\"><code>import main from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\">名字可自定义</td>\n</tr>\n<tr>\n<td align=\"left\">同时导入</td>\n<td align=\"left\"><code>import main, &#123; version &#125; from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\">默认 + 命名</td>\n</tr>\n<tr>\n<td align=\"left\">全部导入</td>\n<td align=\"left\"><code>import * as utils from &#39;./utils.js&#39;;</code></td>\n<td align=\"left\"><code>utils</code> 是命名空间对象</td>\n</tr>\n<tr>\n<td align=\"left\">只执行（副作用）</td>\n<td align=\"left\"><code>import &#39;./polyfill.js&#39;;</code></td>\n<td align=\"left\">不导入值，只执行代码</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"二、模块的执行机制\"><a href=\"#二、模块的执行机制\" class=\"headerlink\" title=\"二、模块的执行机制\"></a>二、模块的执行机制</h2><h3 id=\"✅-模块只会执行一次（单例）\"><a href=\"#✅-模块只会执行一次（单例）\" class=\"headerlink\" title=\"✅ 模块只会执行一次（单例）\"></a>✅ 模块只会执行一次（单例）</h3><ul>\n<li>第一次 <code>import</code>：<strong>执行文件代码</strong>（顶层代码）。</li>\n<li>后续 <code>import</code>：<strong>不执行</strong>，直接从<strong>模块缓存</strong>中取结果。</li>\n<li>所有导入者共享<strong>同一个状态</strong>（如 <code>let count = 0</code>）。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">inc</span> = (<span class=\"params\"></span>) =&gt; count++;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js 和 b.js 都 import inc → 共享同一个 count</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"🔗-import-的本质：创建“实时指针”（Live-Binding）\"><a href=\"#🔗-import-的本质：创建“实时指针”（Live-Binding）\" class=\"headerlink\" title=\"🔗 import 的本质：创建“实时指针”（Live Binding）\"></a>🔗 <code>import</code> 的本质：创建“实时指针”（Live Binding）</h3><ul>\n<li><code>import</code> 不是“拷贝值”，而是创建一个<strong>指向目标变量的指针</strong>。</li>\n<li>即使变量后续改变，所有导入者都能看到最新值。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// counter.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">inc</span> = (<span class=\"params\"></span>) =&gt; count++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; count &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./counter.js&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title function_\">inc</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 1 ← 自动更新！</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"三、模块加载流程（4-阶段）\"><a href=\"#三、模块加载流程（4-阶段）\" class=\"headerlink\" title=\"三、模块加载流程（4 阶段）\"></a>三、模块加载流程（4 阶段）</h2><table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>1. 解析</strong></td>\n<td align=\"left\">静态分析 <code>import/export</code>，构建依赖图，验证语法</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>2. 加载</strong></td>\n<td align=\"left\">下载模块文件（网络&#x2F;文件系统）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>3. 链接</strong></td>\n<td align=\"left\">创建“模块环境记录”，建立“实时绑定”（指针）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>4. 执行</strong></td>\n<td align=\"left\">执行顶层代码，初始化 <code>export</code> 变量</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ 顺序：深度优先，依赖项先执行。</p>\n</blockquote>\n<hr>\n<h2 id=\"四、重新导出（Re-exporting）\"><a href=\"#四、重新导出（Re-exporting）\" class=\"headerlink\" title=\"四、重新导出（Re-exporting）\"></a>四、重新导出（Re-exporting）</h2><table>\n<thead>\n<tr>\n<th align=\"left\">语法</th>\n<th align=\"left\">作用</th>\n<th align=\"left\">是否包含 <code>default</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>export * from &#39;x.js&#39;</code></td>\n<td align=\"left\">透传 <code>x.js</code> 的所有<strong>命名导出</strong></td>\n<td align=\"left\">❌ 否</td>\n</tr>\n<tr>\n<td align=\"left\"><code>export &#123; name &#125; from &#39;x.js&#39;</code></td>\n<td align=\"left\">只导出 <code>x.js</code> 的 <code>name</code></td>\n<td align=\"left\">❌ 否</td>\n</tr>\n<tr>\n<td align=\"left\"><code>export &#123; default &#125; from &#39;x.js&#39;</code></td>\n<td align=\"left\">透传 <code>default</code> 导出</td>\n<td align=\"left\">✅ 是</td>\n</tr>\n<tr>\n<td align=\"left\"><code>export &#123; name as newName &#125; from &#39;x.js&#39;</code></td>\n<td align=\"left\">重命名导出</td>\n<td align=\"left\">✅ 可重命名</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>🎯 用途：创建聚合模块（如 <code>index.js</code>）。</p>\n</blockquote>\n<hr>\n<h2 id=\"五、default-vs-命名导出\"><a href=\"#五、default-vs-命名导出\" class=\"headerlink\" title=\"五、default vs 命名导出\"></a>五、<code>default</code> vs 命名导出</h2><table>\n<thead>\n<tr>\n<th align=\"left\">问题</th>\n<th align=\"left\">答案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>export default</code> 能用 <code>&#123;&#125;</code> 接收吗？</td>\n<td align=\"left\">❌ 不能！必须用 <code>import xxx from</code></td>\n</tr>\n<tr>\n<td align=\"left\">命名导出能用 <code>import xxx from</code> 接收吗？</td>\n<td align=\"left\">❌ 不能！必须用 <code>import &#123; xxx &#125; from</code></td>\n</tr>\n<tr>\n<td align=\"left\">如何同时导入？</td>\n<td align=\"left\"><code>import defaultName, &#123; named &#125; from &#39;module&#39;</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>default</code> 能重命名吗？</td>\n<td align=\"left\">✅ <code>import &#123; default as main &#125; from &#39;module&#39;</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"六、模块的跨平台挑战与解决方案\"><a href=\"#六、模块的跨平台挑战与解决方案\" class=\"headerlink\" title=\"六、模块的跨平台挑战与解决方案\"></a>六、模块的跨平台挑战与解决方案</h2><h3 id=\"❗-问题：环境差异\"><a href=\"#❗-问题：环境差异\" class=\"headerlink\" title=\"❗ 问题：环境差异\"></a>❗ 问题：环境差异</h3><table>\n<thead>\n<tr>\n<th align=\"left\">环境</th>\n<th align=\"left\">特有全局变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">浏览器</td>\n<td align=\"left\"><code>window</code>, <code>document</code>, <code>localStorage</code></td>\n</tr>\n<tr>\n<td align=\"left\">Node.js</td>\n<td align=\"left\"><code>process</code>, <code>require</code>, <code>__dirname</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>❌ 模块若依赖 <code>window</code>，在 Node.js 中会报错。</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-解决方案-1：分层架构-——-“核心-绑定”\"><a href=\"#✅-解决方案-1：分层架构-——-“核心-绑定”\" class=\"headerlink\" title=\"✅ 解决方案 1：分层架构 —— “核心 + 绑定”\"></a>✅ 解决方案 1：分层架构 —— “核心 + 绑定”</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">|   应用层         |</span><br><span class=\"line\">+--------+---------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">+--------v---------+</span><br><span class=\"line\">|   绑定层 (Bindings)|</span><br><span class=\"line\">| - browser.js     |</span><br><span class=\"line\">| - node.js        |</span><br><span class=\"line\">+--------+---------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">+--------v---------+</span><br><span class=\"line\">|   核心层 (Core)  |</span><br><span class=\"line\">| - 纯逻辑：hash, validate |</span><br><span class=\"line\">| - 无环境依赖     |</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"✅-优点：\"><a href=\"#✅-优点：\" class=\"headerlink\" title=\"✅ 优点：\"></a>✅ 优点：</h4><ul>\n<li>核心可无限复用。</li>\n<li>绑定轻量、可替换。</li>\n<li>易测试、易维护。</li>\n</ul>\n<hr>\n<h3 id=\"✅-解决方案-2：运行时检测（Feature-Detection）\"><a href=\"#✅-解决方案-2：运行时检测（Feature-Detection）\" class=\"headerlink\" title=\"✅ 解决方案 2：运行时检测（Feature Detection）\"></a>✅ 解决方案 2：运行时检测（Feature Detection）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> password;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> process !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; process.<span class=\"property\">env</span>.<span class=\"property\">PASSWORD</span>) &#123;</span><br><span class=\"line\">  password = process.<span class=\"property\">env</span>.<span class=\"property\">PASSWORD</span>; <span class=\"comment\">// Node.js</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">document</span> !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  password = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;password&#x27;</span>)?.<span class=\"property\">value</span>; <span class=\"comment\">// 浏览器</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;No password source&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>🔑 原则：<strong>检测功能，不检测环境</strong>。</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-解决方案-3：Polyfill-动态导入\"><a href=\"#✅-解决方案-3：Polyfill-动态导入\" class=\"headerlink\" title=\"✅ 解决方案 3：Polyfill + 动态导入\"></a>✅ 解决方案 3：Polyfill + 动态导入</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 确保 fetch 在所有环境可用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fetch === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  globalThis.<span class=\"property\">fetch</span> = (<span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;node-fetch&#x27;</span>)).<span class=\"property\">default</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>🔑 使用 <code>globalThis</code>：在所有环境中都指向全局对象。</p>\n</blockquote>\n<hr>\n<h2 id=\"七、最佳实践清单\"><a href=\"#七、最佳实践清单\" class=\"headerlink\" title=\"七、最佳实践清单\"></a>七、最佳实践清单</h2><table>\n<thead>\n<tr>\n<th align=\"left\">原则</th>\n<th align=\"left\">建议</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">🧱 <strong>分离关注点</strong></td>\n<td align=\"left\">核心逻辑 vs I&#x2F;O 操作</td>\n</tr>\n<tr>\n<td align=\"left\">🔍 <strong>检测功能</strong></td>\n<td align=\"left\"><code>typeof fetch === &#39;function&#39;</code> 而非 <code>window</code></td>\n</tr>\n<tr>\n<td align=\"left\">🌐 <strong>使用 <code>globalThis</code></strong></td>\n<td align=\"left\">安全访问全局对象</td>\n</tr>\n<tr>\n<td align=\"left\">📦 <strong>小模块，高内聚</strong></td>\n<td align=\"left\">一个模块只做一件事</td>\n</tr>\n<tr>\n<td align=\"left\">🧪 <strong>测试核心</strong></td>\n<td align=\"left\">纯函数易单元测试</td>\n</tr>\n<tr>\n<td align=\"left\">📚 <strong>文档说明</strong></td>\n<td align=\"left\">标注模块的环境依赖</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🎯-总结口诀\"><a href=\"#🎯-总结口诀\" class=\"headerlink\" title=\"🎯 总结口诀\"></a>🎯 总结口诀</h2><blockquote>\n<p><strong>“一缓存、二绑定、三核心、四检测”</strong></p>\n<ol>\n<li><strong>一缓存</strong>：模块只执行一次，结果缓存共享。</li>\n<li><strong>二绑定</strong>：<code>import</code> 是实时指针，不是值拷贝。</li>\n<li><strong>三核心</strong>：纯逻辑独立，不依赖环境。</li>\n<li><strong>四检测</strong>：用 <code>typeof</code> 检测功能，实现跨平台。</li>\n</ol>\n</blockquote>\n<pre><code>\n</code></pre>\n"},{"title":"📚 npm 包上传机制笔记","_content":"> **核心思想：`npm publish` 就是把本地项目打包并上传到 npm 服务器，别人通过 `package.json.name` 安装和引用。而 `npm pack` 是理解这一过程的“关键钥匙”。**\n\n---\n\n## 1️⃣ 什么是 `npm pack`？\n\n`npm pack` 是一个 **本地打包命令**，它会：\n\n1. 读取当前目录下的 `package.json`\n2. 根据配置打包项目文件\n3. 生成一个 `.tgz` 压缩包文件（tarball）\n4. **不会上传到任何地方**，只在本地生成文件\n\n> 🔧 类比：就像你写了一本书，`npm pack` 相当于把你写的书打包成一个 ZIP 文件，存在自己电脑上，还没寄给出版社。\n\n---\n\n## 2️⃣ `npm pack` 能做什么？（核心用途）\n\n| 用途 | 说明 |\n|------|------|\n| ✅ **预演发布** | 检查最终发布的内容是否正确 |\n| ✅ **验证打包范围** | 看看哪些文件被打包了（有没有误包含 `node_modules`？） |\n| ✅ **检查包名和版本** | 确认生成的 `.tgz` 文件名是否符合预期 |\n| ✅ **离线分发** | 把 `.tgz` 文件发给同事，他们可以用 `npm install ./xxx.tgz` 安装 |\n| ✅ **CI/CD 流程测试** | 在自动化流程中验证包的完整性 |\n\n---\n\n## 3️⃣ `npm pack` 详细执行流程\n\n当你运行：\n\n```bash\nnpm pack\n```\n\nnpm 会执行以下步骤：\n\n### 步骤 1：读取 `package.json`\n- 获取 `name` → 决定包名\n- 获取 `version` → 决定版本\n- 获取 `main`, `bin`, `files` 等配置\n\n### 步骤 2：确定要打包的文件\nnpm 会根据以下规则决定哪些文件进入包中：\n\n| 规则 | 说明 |\n|------|------|\n| 1. `.npmignore` 文件 | 如果存在，按它列出的规则忽略文件（优先级最高） |\n| 2. `package.json` 中的 `files` 字段 | 显式声明要包含的文件/目录 |\n| 3. 默认规则 | 除了以下文件，其他都打包：<br>• `node_modules`<br>• `.git`<br>• `npm-debug.log`<br>• `.env`<br>• `*.log`<br>• `*.tgz` |\n\n> 💡 建议：使用 `files` 字段精确控制打包内容，避免误传敏感文件。\n\n### 步骤 3：生成 `.tgz` 文件\n- 文件名格式：`<name>-<version>.tgz`\n- 例如：`my-utils-1.0.0.tgz`\n- 生成在当前目录\n\n### 步骤 4：输出打包详情\n```bash\nnpm notice \nnpm notice 📦  my-utils@1.0.0\nnpm notice === Tarball Contents === \nnpm notice 234B  package.json\nnpm notice 88B   index.js\nnpm notice 45B   lib/helper.js\nnpm notice === Tarball Details === \nnpm notice name:      my-utils\nnpm notice version:   1.0.0\nnpm notice filename:  my-utils-1.0.0.tgz\nnpm notice total files: 3\nnpm notice \nmy-utils-1.0.0.tgz\n```\n\n---\n\n## 4️⃣ 实战：使用 `npm pack` 验证你的包\n\n### ① 先“干跑”查看会打包哪些文件\n```bash\nnpm pack --dry-run\n```\n👉 输出打包内容列表，但不生成 `.tgz` 文件，安全预览。\n\n### ② 正式打包\n```bash\nnpm pack\n```\n👉 生成 `my-utils-1.0.0.tgz`\n\n### ③ 解压查看内容（验证真相）\n```bash\nmkdir unpacked\ntar -xzf my-utils-1.0.0.tgz -C unpacked\nls unpacked/package\n# 输出：package.json  index.js  lib/\n```\n✅ 看见了吧？包的内容就是你项目里的文件！\n\n---\n\n## 5️⃣ `npm pack` 与 `npm publish` 的关系\n\n| 对比项 | `npm pack` | `npm publish` |\n|--------|-----------|---------------|\n| 是否生成 `.tgz` | ✅ 是 | ✅ 是（在服务器） |\n| 是否上传 | ❌ 否 | ✅ 是 |\n| 是否需要登录 | ❌ 否 | ✅ 是（`npm login`） |\n| 是否影响他人 | ❌ 否 | ✅ 是（全球可安装） |\n| 是否修改本地文件 | ❌ 否 | ❌ 否 |\n| **核心作用** | 🔍 **预演、验证、调试** | 🚀 **正式发布** |\n\n> ✅ **结论：`npm publish` = `npm pack` 的内容 + 上传到 npm 服务器**\n\n---\n\n## 6️⃣ 使用建议：发布前必做\n\n```bash\n# 1. 干跑，查看打包内容\nnpm pack --dry-run\n\n# 2. 正式打包，生成 .tgz\nnpm pack\n\n# 3. 检查生成的文件名\nls *.tgz\n\n# 4. （可选）解压验证\ntar -tzf my-utils-1.0.0.tgz\n\n# 5. 确认无误后发布\nnpm publish\n```\n\n---\n\n\n","source":"_posts/npm 包上传机制.md","raw":"---\ntitle: 📚 npm 包上传机制笔记\n---\n> **核心思想：`npm publish` 就是把本地项目打包并上传到 npm 服务器，别人通过 `package.json.name` 安装和引用。而 `npm pack` 是理解这一过程的“关键钥匙”。**\n\n---\n\n## 1️⃣ 什么是 `npm pack`？\n\n`npm pack` 是一个 **本地打包命令**，它会：\n\n1. 读取当前目录下的 `package.json`\n2. 根据配置打包项目文件\n3. 生成一个 `.tgz` 压缩包文件（tarball）\n4. **不会上传到任何地方**，只在本地生成文件\n\n> 🔧 类比：就像你写了一本书，`npm pack` 相当于把你写的书打包成一个 ZIP 文件，存在自己电脑上，还没寄给出版社。\n\n---\n\n## 2️⃣ `npm pack` 能做什么？（核心用途）\n\n| 用途 | 说明 |\n|------|------|\n| ✅ **预演发布** | 检查最终发布的内容是否正确 |\n| ✅ **验证打包范围** | 看看哪些文件被打包了（有没有误包含 `node_modules`？） |\n| ✅ **检查包名和版本** | 确认生成的 `.tgz` 文件名是否符合预期 |\n| ✅ **离线分发** | 把 `.tgz` 文件发给同事，他们可以用 `npm install ./xxx.tgz` 安装 |\n| ✅ **CI/CD 流程测试** | 在自动化流程中验证包的完整性 |\n\n---\n\n## 3️⃣ `npm pack` 详细执行流程\n\n当你运行：\n\n```bash\nnpm pack\n```\n\nnpm 会执行以下步骤：\n\n### 步骤 1：读取 `package.json`\n- 获取 `name` → 决定包名\n- 获取 `version` → 决定版本\n- 获取 `main`, `bin`, `files` 等配置\n\n### 步骤 2：确定要打包的文件\nnpm 会根据以下规则决定哪些文件进入包中：\n\n| 规则 | 说明 |\n|------|------|\n| 1. `.npmignore` 文件 | 如果存在，按它列出的规则忽略文件（优先级最高） |\n| 2. `package.json` 中的 `files` 字段 | 显式声明要包含的文件/目录 |\n| 3. 默认规则 | 除了以下文件，其他都打包：<br>• `node_modules`<br>• `.git`<br>• `npm-debug.log`<br>• `.env`<br>• `*.log`<br>• `*.tgz` |\n\n> 💡 建议：使用 `files` 字段精确控制打包内容，避免误传敏感文件。\n\n### 步骤 3：生成 `.tgz` 文件\n- 文件名格式：`<name>-<version>.tgz`\n- 例如：`my-utils-1.0.0.tgz`\n- 生成在当前目录\n\n### 步骤 4：输出打包详情\n```bash\nnpm notice \nnpm notice 📦  my-utils@1.0.0\nnpm notice === Tarball Contents === \nnpm notice 234B  package.json\nnpm notice 88B   index.js\nnpm notice 45B   lib/helper.js\nnpm notice === Tarball Details === \nnpm notice name:      my-utils\nnpm notice version:   1.0.0\nnpm notice filename:  my-utils-1.0.0.tgz\nnpm notice total files: 3\nnpm notice \nmy-utils-1.0.0.tgz\n```\n\n---\n\n## 4️⃣ 实战：使用 `npm pack` 验证你的包\n\n### ① 先“干跑”查看会打包哪些文件\n```bash\nnpm pack --dry-run\n```\n👉 输出打包内容列表，但不生成 `.tgz` 文件，安全预览。\n\n### ② 正式打包\n```bash\nnpm pack\n```\n👉 生成 `my-utils-1.0.0.tgz`\n\n### ③ 解压查看内容（验证真相）\n```bash\nmkdir unpacked\ntar -xzf my-utils-1.0.0.tgz -C unpacked\nls unpacked/package\n# 输出：package.json  index.js  lib/\n```\n✅ 看见了吧？包的内容就是你项目里的文件！\n\n---\n\n## 5️⃣ `npm pack` 与 `npm publish` 的关系\n\n| 对比项 | `npm pack` | `npm publish` |\n|--------|-----------|---------------|\n| 是否生成 `.tgz` | ✅ 是 | ✅ 是（在服务器） |\n| 是否上传 | ❌ 否 | ✅ 是 |\n| 是否需要登录 | ❌ 否 | ✅ 是（`npm login`） |\n| 是否影响他人 | ❌ 否 | ✅ 是（全球可安装） |\n| 是否修改本地文件 | ❌ 否 | ❌ 否 |\n| **核心作用** | 🔍 **预演、验证、调试** | 🚀 **正式发布** |\n\n> ✅ **结论：`npm publish` = `npm pack` 的内容 + 上传到 npm 服务器**\n\n---\n\n## 6️⃣ 使用建议：发布前必做\n\n```bash\n# 1. 干跑，查看打包内容\nnpm pack --dry-run\n\n# 2. 正式打包，生成 .tgz\nnpm pack\n\n# 3. 检查生成的文件名\nls *.tgz\n\n# 4. （可选）解压验证\ntar -tzf my-utils-1.0.0.tgz\n\n# 5. 确认无误后发布\nnpm publish\n```\n\n---\n\n\n","slug":"npm 包上传机制","published":1,"date":"2025-09-02T01:50:34.894Z","updated":"2025-09-01T09:54:01.765Z","_id":"cmf1wtkpe000mq4v94s4b6ry8","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><strong>核心思想：<code>npm publish</code> 就是把本地项目打包并上传到 npm 服务器，别人通过 <code>package.json.name</code> 安装和引用。而 <code>npm pack</code> 是理解这一过程的“关键钥匙”。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"1️⃣-什么是-npm-pack？\"><a href=\"#1️⃣-什么是-npm-pack？\" class=\"headerlink\" title=\"1️⃣ 什么是 npm pack？\"></a>1️⃣ 什么是 <code>npm pack</code>？</h2><p><code>npm pack</code> 是一个 <strong>本地打包命令</strong>，它会：</p>\n<ol>\n<li>读取当前目录下的 <code>package.json</code></li>\n<li>根据配置打包项目文件</li>\n<li>生成一个 <code>.tgz</code> 压缩包文件（tarball）</li>\n<li><strong>不会上传到任何地方</strong>，只在本地生成文件</li>\n</ol>\n<blockquote>\n<p>🔧 类比：就像你写了一本书，<code>npm pack</code> 相当于把你写的书打包成一个 ZIP 文件，存在自己电脑上，还没寄给出版社。</p>\n</blockquote>\n<hr>\n<h2 id=\"2️⃣-npm-pack-能做什么？（核心用途）\"><a href=\"#2️⃣-npm-pack-能做什么？（核心用途）\" class=\"headerlink\" title=\"2️⃣ npm pack 能做什么？（核心用途）\"></a>2️⃣ <code>npm pack</code> 能做什么？（核心用途）</h2><table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>✅ <strong>预演发布</strong></td>\n<td>检查最终发布的内容是否正确</td>\n</tr>\n<tr>\n<td>✅ <strong>验证打包范围</strong></td>\n<td>看看哪些文件被打包了（有没有误包含 <code>node_modules</code>？）</td>\n</tr>\n<tr>\n<td>✅ <strong>检查包名和版本</strong></td>\n<td>确认生成的 <code>.tgz</code> 文件名是否符合预期</td>\n</tr>\n<tr>\n<td>✅ <strong>离线分发</strong></td>\n<td>把 <code>.tgz</code> 文件发给同事，他们可以用 <code>npm install ./xxx.tgz</code> 安装</td>\n</tr>\n<tr>\n<td>✅ <strong>CI&#x2F;CD 流程测试</strong></td>\n<td>在自动化流程中验证包的完整性</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"3️⃣-npm-pack-详细执行流程\"><a href=\"#3️⃣-npm-pack-详细执行流程\" class=\"headerlink\" title=\"3️⃣ npm pack 详细执行流程\"></a>3️⃣ <code>npm pack</code> 详细执行流程</h2><p>当你运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm pack</span><br></pre></td></tr></table></figure>\n\n<p>npm 会执行以下步骤：</p>\n<h3 id=\"步骤-1：读取-package-json\"><a href=\"#步骤-1：读取-package-json\" class=\"headerlink\" title=\"步骤 1：读取 package.json\"></a>步骤 1：读取 <code>package.json</code></h3><ul>\n<li>获取 <code>name</code> → 决定包名</li>\n<li>获取 <code>version</code> → 决定版本</li>\n<li>获取 <code>main</code>, <code>bin</code>, <code>files</code> 等配置</li>\n</ul>\n<h3 id=\"步骤-2：确定要打包的文件\"><a href=\"#步骤-2：确定要打包的文件\" class=\"headerlink\" title=\"步骤 2：确定要打包的文件\"></a>步骤 2：确定要打包的文件</h3><p>npm 会根据以下规则决定哪些文件进入包中：</p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <code>.npmignore</code> 文件</td>\n<td>如果存在，按它列出的规则忽略文件（优先级最高）</td>\n</tr>\n<tr>\n<td>2. <code>package.json</code> 中的 <code>files</code> 字段</td>\n<td>显式声明要包含的文件&#x2F;目录</td>\n</tr>\n<tr>\n<td>3. 默认规则</td>\n<td>除了以下文件，其他都打包：<br>• <code>node_modules</code><br>• <code>.git</code><br>• <code>npm-debug.log</code><br>• <code>.env</code><br>• <code>*.log</code><br>• <code>*.tgz</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>💡 建议：使用 <code>files</code> 字段精确控制打包内容，避免误传敏感文件。</p>\n</blockquote>\n<h3 id=\"步骤-3：生成-tgz-文件\"><a href=\"#步骤-3：生成-tgz-文件\" class=\"headerlink\" title=\"步骤 3：生成 .tgz 文件\"></a>步骤 3：生成 <code>.tgz</code> 文件</h3><ul>\n<li>文件名格式：<code>&lt;name&gt;-&lt;version&gt;.tgz</code></li>\n<li>例如：<code>my-utils-1.0.0.tgz</code></li>\n<li>生成在当前目录</li>\n</ul>\n<h3 id=\"步骤-4：输出打包详情\"><a href=\"#步骤-4：输出打包详情\" class=\"headerlink\" title=\"步骤 4：输出打包详情\"></a>步骤 4：输出打包详情</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm notice </span><br><span class=\"line\">npm notice 📦  my-utils@1.0.0</span><br><span class=\"line\">npm notice === Tarball Contents === </span><br><span class=\"line\">npm notice 234B  package.json</span><br><span class=\"line\">npm notice 88B   index.js</span><br><span class=\"line\">npm notice 45B   lib/helper.js</span><br><span class=\"line\">npm notice === Tarball Details === </span><br><span class=\"line\">npm notice name:      my-utils</span><br><span class=\"line\">npm notice version:   1.0.0</span><br><span class=\"line\">npm notice filename:  my-utils-1.0.0.tgz</span><br><span class=\"line\">npm notice total files: 3</span><br><span class=\"line\">npm notice </span><br><span class=\"line\">my-utils-1.0.0.tgz</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4️⃣-实战：使用-npm-pack-验证你的包\"><a href=\"#4️⃣-实战：使用-npm-pack-验证你的包\" class=\"headerlink\" title=\"4️⃣ 实战：使用 npm pack 验证你的包\"></a>4️⃣ 实战：使用 <code>npm pack</code> 验证你的包</h2><h3 id=\"①-先“干跑”查看会打包哪些文件\"><a href=\"#①-先“干跑”查看会打包哪些文件\" class=\"headerlink\" title=\"① 先“干跑”查看会打包哪些文件\"></a>① 先“干跑”查看会打包哪些文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm pack --dry-run</span><br></pre></td></tr></table></figure>\n<p>👉 输出打包内容列表，但不生成 <code>.tgz</code> 文件，安全预览。</p>\n<h3 id=\"②-正式打包\"><a href=\"#②-正式打包\" class=\"headerlink\" title=\"② 正式打包\"></a>② 正式打包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm pack</span><br></pre></td></tr></table></figure>\n<p>👉 生成 <code>my-utils-1.0.0.tgz</code></p>\n<h3 id=\"③-解压查看内容（验证真相）\"><a href=\"#③-解压查看内容（验证真相）\" class=\"headerlink\" title=\"③ 解压查看内容（验证真相）\"></a>③ 解压查看内容（验证真相）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> unpacked</span><br><span class=\"line\">tar -xzf my-utils-1.0.0.tgz -C unpacked</span><br><span class=\"line\"><span class=\"built_in\">ls</span> unpacked/package</span><br><span class=\"line\"><span class=\"comment\"># 输出：package.json  index.js  lib/</span></span><br></pre></td></tr></table></figure>\n<p>✅ 看见了吧？包的内容就是你项目里的文件！</p>\n<hr>\n<h2 id=\"5️⃣-npm-pack-与-npm-publish-的关系\"><a href=\"#5️⃣-npm-pack-与-npm-publish-的关系\" class=\"headerlink\" title=\"5️⃣ npm pack 与 npm publish 的关系\"></a>5️⃣ <code>npm pack</code> 与 <code>npm publish</code> 的关系</h2><table>\n<thead>\n<tr>\n<th>对比项</th>\n<th><code>npm pack</code></th>\n<th><code>npm publish</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否生成 <code>.tgz</code></td>\n<td>✅ 是</td>\n<td>✅ 是（在服务器）</td>\n</tr>\n<tr>\n<td>是否上传</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>是否需要登录</td>\n<td>❌ 否</td>\n<td>✅ 是（<code>npm login</code>）</td>\n</tr>\n<tr>\n<td>是否影响他人</td>\n<td>❌ 否</td>\n<td>✅ 是（全球可安装）</td>\n</tr>\n<tr>\n<td>是否修改本地文件</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><strong>核心作用</strong></td>\n<td>🔍 <strong>预演、验证、调试</strong></td>\n<td>🚀 <strong>正式发布</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ <strong>结论：<code>npm publish</code> &#x3D; <code>npm pack</code> 的内容 + 上传到 npm 服务器</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"6️⃣-使用建议：发布前必做\"><a href=\"#6️⃣-使用建议：发布前必做\" class=\"headerlink\" title=\"6️⃣ 使用建议：发布前必做\"></a>6️⃣ 使用建议：发布前必做</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 干跑，查看打包内容</span></span><br><span class=\"line\">npm pack --dry-run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 正式打包，生成 .tgz</span></span><br><span class=\"line\">npm pack</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 检查生成的文件名</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> *.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. （可选）解压验证</span></span><br><span class=\"line\">tar -tzf my-utils-1.0.0.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 确认无误后发布</span></span><br><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><strong>核心思想：<code>npm publish</code> 就是把本地项目打包并上传到 npm 服务器，别人通过 <code>package.json.name</code> 安装和引用。而 <code>npm pack</code> 是理解这一过程的“关键钥匙”。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"1️⃣-什么是-npm-pack？\"><a href=\"#1️⃣-什么是-npm-pack？\" class=\"headerlink\" title=\"1️⃣ 什么是 npm pack？\"></a>1️⃣ 什么是 <code>npm pack</code>？</h2><p><code>npm pack</code> 是一个 <strong>本地打包命令</strong>，它会：</p>\n<ol>\n<li>读取当前目录下的 <code>package.json</code></li>\n<li>根据配置打包项目文件</li>\n<li>生成一个 <code>.tgz</code> 压缩包文件（tarball）</li>\n<li><strong>不会上传到任何地方</strong>，只在本地生成文件</li>\n</ol>\n<blockquote>\n<p>🔧 类比：就像你写了一本书，<code>npm pack</code> 相当于把你写的书打包成一个 ZIP 文件，存在自己电脑上，还没寄给出版社。</p>\n</blockquote>\n<hr>\n<h2 id=\"2️⃣-npm-pack-能做什么？（核心用途）\"><a href=\"#2️⃣-npm-pack-能做什么？（核心用途）\" class=\"headerlink\" title=\"2️⃣ npm pack 能做什么？（核心用途）\"></a>2️⃣ <code>npm pack</code> 能做什么？（核心用途）</h2><table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>✅ <strong>预演发布</strong></td>\n<td>检查最终发布的内容是否正确</td>\n</tr>\n<tr>\n<td>✅ <strong>验证打包范围</strong></td>\n<td>看看哪些文件被打包了（有没有误包含 <code>node_modules</code>？）</td>\n</tr>\n<tr>\n<td>✅ <strong>检查包名和版本</strong></td>\n<td>确认生成的 <code>.tgz</code> 文件名是否符合预期</td>\n</tr>\n<tr>\n<td>✅ <strong>离线分发</strong></td>\n<td>把 <code>.tgz</code> 文件发给同事，他们可以用 <code>npm install ./xxx.tgz</code> 安装</td>\n</tr>\n<tr>\n<td>✅ <strong>CI&#x2F;CD 流程测试</strong></td>\n<td>在自动化流程中验证包的完整性</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"3️⃣-npm-pack-详细执行流程\"><a href=\"#3️⃣-npm-pack-详细执行流程\" class=\"headerlink\" title=\"3️⃣ npm pack 详细执行流程\"></a>3️⃣ <code>npm pack</code> 详细执行流程</h2><p>当你运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm pack</span><br></pre></td></tr></table></figure>\n\n<p>npm 会执行以下步骤：</p>\n<h3 id=\"步骤-1：读取-package-json\"><a href=\"#步骤-1：读取-package-json\" class=\"headerlink\" title=\"步骤 1：读取 package.json\"></a>步骤 1：读取 <code>package.json</code></h3><ul>\n<li>获取 <code>name</code> → 决定包名</li>\n<li>获取 <code>version</code> → 决定版本</li>\n<li>获取 <code>main</code>, <code>bin</code>, <code>files</code> 等配置</li>\n</ul>\n<h3 id=\"步骤-2：确定要打包的文件\"><a href=\"#步骤-2：确定要打包的文件\" class=\"headerlink\" title=\"步骤 2：确定要打包的文件\"></a>步骤 2：确定要打包的文件</h3><p>npm 会根据以下规则决定哪些文件进入包中：</p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <code>.npmignore</code> 文件</td>\n<td>如果存在，按它列出的规则忽略文件（优先级最高）</td>\n</tr>\n<tr>\n<td>2. <code>package.json</code> 中的 <code>files</code> 字段</td>\n<td>显式声明要包含的文件&#x2F;目录</td>\n</tr>\n<tr>\n<td>3. 默认规则</td>\n<td>除了以下文件，其他都打包：<br>• <code>node_modules</code><br>• <code>.git</code><br>• <code>npm-debug.log</code><br>• <code>.env</code><br>• <code>*.log</code><br>• <code>*.tgz</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>💡 建议：使用 <code>files</code> 字段精确控制打包内容，避免误传敏感文件。</p>\n</blockquote>\n<h3 id=\"步骤-3：生成-tgz-文件\"><a href=\"#步骤-3：生成-tgz-文件\" class=\"headerlink\" title=\"步骤 3：生成 .tgz 文件\"></a>步骤 3：生成 <code>.tgz</code> 文件</h3><ul>\n<li>文件名格式：<code>&lt;name&gt;-&lt;version&gt;.tgz</code></li>\n<li>例如：<code>my-utils-1.0.0.tgz</code></li>\n<li>生成在当前目录</li>\n</ul>\n<h3 id=\"步骤-4：输出打包详情\"><a href=\"#步骤-4：输出打包详情\" class=\"headerlink\" title=\"步骤 4：输出打包详情\"></a>步骤 4：输出打包详情</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm notice </span><br><span class=\"line\">npm notice 📦  my-utils@1.0.0</span><br><span class=\"line\">npm notice === Tarball Contents === </span><br><span class=\"line\">npm notice 234B  package.json</span><br><span class=\"line\">npm notice 88B   index.js</span><br><span class=\"line\">npm notice 45B   lib/helper.js</span><br><span class=\"line\">npm notice === Tarball Details === </span><br><span class=\"line\">npm notice name:      my-utils</span><br><span class=\"line\">npm notice version:   1.0.0</span><br><span class=\"line\">npm notice filename:  my-utils-1.0.0.tgz</span><br><span class=\"line\">npm notice total files: 3</span><br><span class=\"line\">npm notice </span><br><span class=\"line\">my-utils-1.0.0.tgz</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4️⃣-实战：使用-npm-pack-验证你的包\"><a href=\"#4️⃣-实战：使用-npm-pack-验证你的包\" class=\"headerlink\" title=\"4️⃣ 实战：使用 npm pack 验证你的包\"></a>4️⃣ 实战：使用 <code>npm pack</code> 验证你的包</h2><h3 id=\"①-先“干跑”查看会打包哪些文件\"><a href=\"#①-先“干跑”查看会打包哪些文件\" class=\"headerlink\" title=\"① 先“干跑”查看会打包哪些文件\"></a>① 先“干跑”查看会打包哪些文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm pack --dry-run</span><br></pre></td></tr></table></figure>\n<p>👉 输出打包内容列表，但不生成 <code>.tgz</code> 文件，安全预览。</p>\n<h3 id=\"②-正式打包\"><a href=\"#②-正式打包\" class=\"headerlink\" title=\"② 正式打包\"></a>② 正式打包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm pack</span><br></pre></td></tr></table></figure>\n<p>👉 生成 <code>my-utils-1.0.0.tgz</code></p>\n<h3 id=\"③-解压查看内容（验证真相）\"><a href=\"#③-解压查看内容（验证真相）\" class=\"headerlink\" title=\"③ 解压查看内容（验证真相）\"></a>③ 解压查看内容（验证真相）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> unpacked</span><br><span class=\"line\">tar -xzf my-utils-1.0.0.tgz -C unpacked</span><br><span class=\"line\"><span class=\"built_in\">ls</span> unpacked/package</span><br><span class=\"line\"><span class=\"comment\"># 输出：package.json  index.js  lib/</span></span><br></pre></td></tr></table></figure>\n<p>✅ 看见了吧？包的内容就是你项目里的文件！</p>\n<hr>\n<h2 id=\"5️⃣-npm-pack-与-npm-publish-的关系\"><a href=\"#5️⃣-npm-pack-与-npm-publish-的关系\" class=\"headerlink\" title=\"5️⃣ npm pack 与 npm publish 的关系\"></a>5️⃣ <code>npm pack</code> 与 <code>npm publish</code> 的关系</h2><table>\n<thead>\n<tr>\n<th>对比项</th>\n<th><code>npm pack</code></th>\n<th><code>npm publish</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否生成 <code>.tgz</code></td>\n<td>✅ 是</td>\n<td>✅ 是（在服务器）</td>\n</tr>\n<tr>\n<td>是否上传</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>是否需要登录</td>\n<td>❌ 否</td>\n<td>✅ 是（<code>npm login</code>）</td>\n</tr>\n<tr>\n<td>是否影响他人</td>\n<td>❌ 否</td>\n<td>✅ 是（全球可安装）</td>\n</tr>\n<tr>\n<td>是否修改本地文件</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><strong>核心作用</strong></td>\n<td>🔍 <strong>预演、验证、调试</strong></td>\n<td>🚀 <strong>正式发布</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ <strong>结论：<code>npm publish</code> &#x3D; <code>npm pack</code> 的内容 + 上传到 npm 服务器</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"6️⃣-使用建议：发布前必做\"><a href=\"#6️⃣-使用建议：发布前必做\" class=\"headerlink\" title=\"6️⃣ 使用建议：发布前必做\"></a>6️⃣ 使用建议：发布前必做</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 干跑，查看打包内容</span></span><br><span class=\"line\">npm pack --dry-run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 正式打包，生成 .tgz</span></span><br><span class=\"line\">npm pack</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 检查生成的文件名</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> *.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. （可选）解压验证</span></span><br><span class=\"line\">tar -tzf my-utils-1.0.0.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 确认无误后发布</span></span><br><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n\n<hr>\n"},{"title":"🧭 package.json 入口机制完全指南","_content":"\n> **“入口”是别人使用你的 npm 包时，程序从哪个文件开始加载。它是包的“正门”。**\n\n\n\n## 🔑 一、核心入口字段\n\n| 字段 | 用途 | 使用场景 |\n|------|------|----------|\n| `main` | CommonJS 入口（Node.js 默认） | `require('pkg')` |\n| `module` | ES Module 入口（打包工具优先） | `import 'pkg'`（Webpack/Vite） |\n| `exports` | 精细控制多入口（现代推荐） | 现代项目首选 |\n| `browser` | 浏览器环境入口（旧方式） | 兼容老项目 |\n\n---\n\n## 🧩 二、字段详解\n\n### 1. `main` —— Node.js 的“老朋友”\n- ✅ 作用：定义 `require('your-pkg')` 时加载的文件\n- ✅ 默认值：`index.js`（不推荐依赖默认）\n- ✅ 格式：CommonJS（`module.exports`）\n- ❌ 问题：不支持 tree-shaking（打包工具无法“摇掉”未用代码）\n\n```json\n{\n  \"main\": \"dist/index.js\"\n}\n```\n\n---\n\n### 2. `module` —— 打包工具的“新宠”\n- ✅ 作用：为 Webpack、Vite 等工具提供 **ES Module** 入口\n- ✅ 格式：ES6 `export` / `import`\n- ✅ 优势：支持 **tree-shaking**，减小最终打包体积\n- ⚠️ 注意：必须提供 `.js` 文件（ESM 语法）\n\n```json\n{\n  \"module\": \"dist/esm/index.js\"\n}\n```\n\n---\n\n### 3. `exports` —— 现代推荐方式（Node.js 12+）\n- ✅ 作用：**精确控制入口行为**，支持条件导出\n- ✅ 优势：\n  - 支持 `import` / `require` 分别指向不同文件\n  - 可定义多个子入口（如 `pkg/helpers`）\n  - 隐藏内部文件（如 `src/`）\n- ✅ 推荐新项目使用\n\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/esm/index.js\",   // ESM 用户\n      \"require\": \"./dist/cjs/index.js\"  // CJS 用户\n    },\n    \"./helpers\": \"./dist/esm/helpers.js\"\n  }\n}\n```\n\n使用：\n```js\nimport main from 'pkg';           // 走 \".\"\nimport { helper } from 'pkg/helpers'; // 走 \"./helpers\"\n```\n\n---\n\n## 🔄 三、入口查找优先级\n\n### 1. 打包工具（Webpack/Vite）查找顺序：\n```\nexports → module → main → index.js\n```\n\n### 2. Node.js 查找顺序：\n```\nexports → main → index.js\n```\n\n> ✅ 建议：同时提供 `exports` + `main`，确保最大兼容性。\n\n---\n\n## 🌐 四、不同用户如何使用你的包？\n\n| 用户类型 | 使用方式 | 加载哪个字段？ |\n|--------|----------|----------------|\n| Node.js `require` 用户 | `const pkg = require('pkg')` | `main` 或 `exports.require` |\n| Webpack/Vite `import` 用户 | `import pkg from 'pkg'` | `module` 或 `exports.import` |\n| 浏览器原生 `import` | `<script type=\"module\">import from 'pkg'</script>` | `module` 或 `exports.import` |\n| TypeScript 用户 | `import { x } from 'pkg'` | 同上 + `types` 字段 |\n\n---\n\n## ⚠️ 五、常见误区澄清\n\n| 误区 | 正确认知 |\n|------|----------|\n| “只写 `main` 就行” | ✅ 功能正常，但前端用户无法 tree-shaking ❌ |\n| “浏览器能用 `require`” | ❌ 原生不支持！必须用打包工具转换 |\n| “Node.js 不能用 `import`” | ❌ 可以！需 `.mjs` 或 `\"type\": \"module\"` |\n| “`module` 字段是给浏览器用的” | ❌ 是给**打包工具**用的，不是浏览器原生用 |\n\n---\n\n## ✅ 六、最佳实践建议\n\n1. **新项目必用 `exports`**  \n   → 精细控制，未来兼容\n\n2. **通用库必须同时提供 `main` 和 `module`**  \n   → 服务 Node 用户 和 前端用户\n\n3. **前端库优先优化 `module` / `exports.import`**  \n   → 确保支持 tree-shaking\n\n4. **入口文件只暴露公共 API**  \n   → 不要让用户直接引用 `src/utils.js`\n\n5. **发布前用 `npm pack --dry-run` 验证**  \n   → 看看 `.tgz` 里有没有入口文件\n\n---\n\n## 🎯 总结：入口设计原则\n\n> - **兼容性**：让 `require` 和 `import` 用户都能用\n> - **性能**：让前端项目能 tree-shaking\n> - **安全**：用 `exports` 隐藏内部实现\n> - **清晰**：入口文件只导出该导出的内容\n\n---\n\n✅ **一句话收尾**：  \n**“入口”不是技术细节，而是你与使用者的“契约”——你决定他们如何开始使用你的代码。**\n\n---\n","source":"_posts/npm入口.md","raw":"---\ntitle:  🧭 package.json 入口机制完全指南\n---\n\n> **“入口”是别人使用你的 npm 包时，程序从哪个文件开始加载。它是包的“正门”。**\n\n\n\n## 🔑 一、核心入口字段\n\n| 字段 | 用途 | 使用场景 |\n|------|------|----------|\n| `main` | CommonJS 入口（Node.js 默认） | `require('pkg')` |\n| `module` | ES Module 入口（打包工具优先） | `import 'pkg'`（Webpack/Vite） |\n| `exports` | 精细控制多入口（现代推荐） | 现代项目首选 |\n| `browser` | 浏览器环境入口（旧方式） | 兼容老项目 |\n\n---\n\n## 🧩 二、字段详解\n\n### 1. `main` —— Node.js 的“老朋友”\n- ✅ 作用：定义 `require('your-pkg')` 时加载的文件\n- ✅ 默认值：`index.js`（不推荐依赖默认）\n- ✅ 格式：CommonJS（`module.exports`）\n- ❌ 问题：不支持 tree-shaking（打包工具无法“摇掉”未用代码）\n\n```json\n{\n  \"main\": \"dist/index.js\"\n}\n```\n\n---\n\n### 2. `module` —— 打包工具的“新宠”\n- ✅ 作用：为 Webpack、Vite 等工具提供 **ES Module** 入口\n- ✅ 格式：ES6 `export` / `import`\n- ✅ 优势：支持 **tree-shaking**，减小最终打包体积\n- ⚠️ 注意：必须提供 `.js` 文件（ESM 语法）\n\n```json\n{\n  \"module\": \"dist/esm/index.js\"\n}\n```\n\n---\n\n### 3. `exports` —— 现代推荐方式（Node.js 12+）\n- ✅ 作用：**精确控制入口行为**，支持条件导出\n- ✅ 优势：\n  - 支持 `import` / `require` 分别指向不同文件\n  - 可定义多个子入口（如 `pkg/helpers`）\n  - 隐藏内部文件（如 `src/`）\n- ✅ 推荐新项目使用\n\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/esm/index.js\",   // ESM 用户\n      \"require\": \"./dist/cjs/index.js\"  // CJS 用户\n    },\n    \"./helpers\": \"./dist/esm/helpers.js\"\n  }\n}\n```\n\n使用：\n```js\nimport main from 'pkg';           // 走 \".\"\nimport { helper } from 'pkg/helpers'; // 走 \"./helpers\"\n```\n\n---\n\n## 🔄 三、入口查找优先级\n\n### 1. 打包工具（Webpack/Vite）查找顺序：\n```\nexports → module → main → index.js\n```\n\n### 2. Node.js 查找顺序：\n```\nexports → main → index.js\n```\n\n> ✅ 建议：同时提供 `exports` + `main`，确保最大兼容性。\n\n---\n\n## 🌐 四、不同用户如何使用你的包？\n\n| 用户类型 | 使用方式 | 加载哪个字段？ |\n|--------|----------|----------------|\n| Node.js `require` 用户 | `const pkg = require('pkg')` | `main` 或 `exports.require` |\n| Webpack/Vite `import` 用户 | `import pkg from 'pkg'` | `module` 或 `exports.import` |\n| 浏览器原生 `import` | `<script type=\"module\">import from 'pkg'</script>` | `module` 或 `exports.import` |\n| TypeScript 用户 | `import { x } from 'pkg'` | 同上 + `types` 字段 |\n\n---\n\n## ⚠️ 五、常见误区澄清\n\n| 误区 | 正确认知 |\n|------|----------|\n| “只写 `main` 就行” | ✅ 功能正常，但前端用户无法 tree-shaking ❌ |\n| “浏览器能用 `require`” | ❌ 原生不支持！必须用打包工具转换 |\n| “Node.js 不能用 `import`” | ❌ 可以！需 `.mjs` 或 `\"type\": \"module\"` |\n| “`module` 字段是给浏览器用的” | ❌ 是给**打包工具**用的，不是浏览器原生用 |\n\n---\n\n## ✅ 六、最佳实践建议\n\n1. **新项目必用 `exports`**  \n   → 精细控制，未来兼容\n\n2. **通用库必须同时提供 `main` 和 `module`**  \n   → 服务 Node 用户 和 前端用户\n\n3. **前端库优先优化 `module` / `exports.import`**  \n   → 确保支持 tree-shaking\n\n4. **入口文件只暴露公共 API**  \n   → 不要让用户直接引用 `src/utils.js`\n\n5. **发布前用 `npm pack --dry-run` 验证**  \n   → 看看 `.tgz` 里有没有入口文件\n\n---\n\n## 🎯 总结：入口设计原则\n\n> - **兼容性**：让 `require` 和 `import` 用户都能用\n> - **性能**：让前端项目能 tree-shaking\n> - **安全**：用 `exports` 隐藏内部实现\n> - **清晰**：入口文件只导出该导出的内容\n\n---\n\n✅ **一句话收尾**：  \n**“入口”不是技术细节，而是你与使用者的“契约”——你决定他们如何开始使用你的代码。**\n\n---\n","slug":"npm入口","published":1,"date":"2025-09-02T01:50:34.900Z","updated":"2025-09-01T09:54:01.766Z","_id":"cmf1wtpbq000nq4v9g4he1ggu","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><strong>“入口”是别人使用你的 npm 包时，程序从哪个文件开始加载。它是包的“正门”。</strong></p>\n</blockquote>\n<h2 id=\"🔑-一、核心入口字段\"><a href=\"#🔑-一、核心入口字段\" class=\"headerlink\" title=\"🔑 一、核心入口字段\"></a>🔑 一、核心入口字段</h2><table>\n<thead>\n<tr>\n<th>字段</th>\n<th>用途</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>main</code></td>\n<td>CommonJS 入口（Node.js 默认）</td>\n<td><code>require(&#39;pkg&#39;)</code></td>\n</tr>\n<tr>\n<td><code>module</code></td>\n<td>ES Module 入口（打包工具优先）</td>\n<td><code>import &#39;pkg&#39;</code>（Webpack&#x2F;Vite）</td>\n</tr>\n<tr>\n<td><code>exports</code></td>\n<td>精细控制多入口（现代推荐）</td>\n<td>现代项目首选</td>\n</tr>\n<tr>\n<td><code>browser</code></td>\n<td>浏览器环境入口（旧方式）</td>\n<td>兼容老项目</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧩-二、字段详解\"><a href=\"#🧩-二、字段详解\" class=\"headerlink\" title=\"🧩 二、字段详解\"></a>🧩 二、字段详解</h2><h3 id=\"1-main-——-Node-js-的“老朋友”\"><a href=\"#1-main-——-Node-js-的“老朋友”\" class=\"headerlink\" title=\"1. main —— Node.js 的“老朋友”\"></a>1. <code>main</code> —— Node.js 的“老朋友”</h3><ul>\n<li>✅ 作用：定义 <code>require(&#39;your-pkg&#39;)</code> 时加载的文件</li>\n<li>✅ 默认值：<code>index.js</code>（不推荐依赖默认）</li>\n<li>✅ 格式：CommonJS（<code>module.exports</code>）</li>\n<li>❌ 问题：不支持 tree-shaking（打包工具无法“摇掉”未用代码）</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dist/index.js&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-module-——-打包工具的“新宠”\"><a href=\"#2-module-——-打包工具的“新宠”\" class=\"headerlink\" title=\"2. module —— 打包工具的“新宠”\"></a>2. <code>module</code> —— 打包工具的“新宠”</h3><ul>\n<li>✅ 作用：为 Webpack、Vite 等工具提供 <strong>ES Module</strong> 入口</li>\n<li>✅ 格式：ES6 <code>export</code> &#x2F; <code>import</code></li>\n<li>✅ 优势：支持 <strong>tree-shaking</strong>，减小最终打包体积</li>\n<li>⚠️ 注意：必须提供 <code>.js</code> 文件（ESM 语法）</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dist/esm/index.js&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-exports-——-现代推荐方式（Node-js-12-）\"><a href=\"#3-exports-——-现代推荐方式（Node-js-12-）\" class=\"headerlink\" title=\"3. exports —— 现代推荐方式（Node.js 12+）\"></a>3. <code>exports</code> —— 现代推荐方式（Node.js 12+）</h3><ul>\n<li>✅ 作用：<strong>精确控制入口行为</strong>，支持条件导出</li>\n<li>✅ 优势：<ul>\n<li>支持 <code>import</code> &#x2F; <code>require</code> 分别指向不同文件</li>\n<li>可定义多个子入口（如 <code>pkg/helpers</code>）</li>\n<li>隐藏内部文件（如 <code>src/</code>）</li>\n</ul>\n</li>\n<li>✅ 推荐新项目使用</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;exports&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;.&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;import&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist/esm/index.js&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// ESM 用户</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;require&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist/cjs/index.js&quot;</span>  <span class=\"comment\">// CJS 用户</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;./helpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist/esm/helpers.js&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> main <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pkg&#x27;</span>;           <span class=\"comment\">// 走 &quot;.&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; helper &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pkg/helpers&#x27;</span>; <span class=\"comment\">// 走 &quot;./helpers&quot;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔄-三、入口查找优先级\"><a href=\"#🔄-三、入口查找优先级\" class=\"headerlink\" title=\"🔄 三、入口查找优先级\"></a>🔄 三、入口查找优先级</h2><h3 id=\"1-打包工具（Webpack-Vite）查找顺序：\"><a href=\"#1-打包工具（Webpack-Vite）查找顺序：\" class=\"headerlink\" title=\"1. 打包工具（Webpack&#x2F;Vite）查找顺序：\"></a>1. 打包工具（Webpack&#x2F;Vite）查找顺序：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports → module → main → index.js</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Node-js-查找顺序：\"><a href=\"#2-Node-js-查找顺序：\" class=\"headerlink\" title=\"2. Node.js 查找顺序：\"></a>2. Node.js 查找顺序：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports → main → index.js</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 建议：同时提供 <code>exports</code> + <code>main</code>，确保最大兼容性。</p>\n</blockquote>\n<hr>\n<h2 id=\"🌐-四、不同用户如何使用你的包？\"><a href=\"#🌐-四、不同用户如何使用你的包？\" class=\"headerlink\" title=\"🌐 四、不同用户如何使用你的包？\"></a>🌐 四、不同用户如何使用你的包？</h2><table>\n<thead>\n<tr>\n<th>用户类型</th>\n<th>使用方式</th>\n<th>加载哪个字段？</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.js <code>require</code> 用户</td>\n<td><code>const pkg = require(&#39;pkg&#39;)</code></td>\n<td><code>main</code> 或 <code>exports.require</code></td>\n</tr>\n<tr>\n<td>Webpack&#x2F;Vite <code>import</code> 用户</td>\n<td><code>import pkg from &#39;pkg&#39;</code></td>\n<td><code>module</code> 或 <code>exports.import</code></td>\n</tr>\n<tr>\n<td>浏览器原生 <code>import</code></td>\n<td><code>&lt;script type=&quot;module&quot;&gt;import from &#39;pkg&#39;&lt;/script&gt;</code></td>\n<td><code>module</code> 或 <code>exports.import</code></td>\n</tr>\n<tr>\n<td>TypeScript 用户</td>\n<td><code>import &#123; x &#125; from &#39;pkg&#39;</code></td>\n<td>同上 + <code>types</code> 字段</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"⚠️-五、常见误区澄清\"><a href=\"#⚠️-五、常见误区澄清\" class=\"headerlink\" title=\"⚠️ 五、常见误区澄清\"></a>⚠️ 五、常见误区澄清</h2><table>\n<thead>\n<tr>\n<th>误区</th>\n<th>正确认知</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“只写 <code>main</code> 就行”</td>\n<td>✅ 功能正常，但前端用户无法 tree-shaking ❌</td>\n</tr>\n<tr>\n<td>“浏览器能用 <code>require</code>”</td>\n<td>❌ 原生不支持！必须用打包工具转换</td>\n</tr>\n<tr>\n<td>“Node.js 不能用 <code>import</code>”</td>\n<td>❌ 可以！需 <code>.mjs</code> 或 <code>&quot;type&quot;: &quot;module&quot;</code></td>\n</tr>\n<tr>\n<td>“<code>module</code> 字段是给浏览器用的”</td>\n<td>❌ 是给<strong>打包工具</strong>用的，不是浏览器原生用</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-六、最佳实践建议\"><a href=\"#✅-六、最佳实践建议\" class=\"headerlink\" title=\"✅ 六、最佳实践建议\"></a>✅ 六、最佳实践建议</h2><ol>\n<li><p><strong>新项目必用 <code>exports</code></strong><br>→ 精细控制，未来兼容</p>\n</li>\n<li><p><strong>通用库必须同时提供 <code>main</code> 和 <code>module</code></strong><br>→ 服务 Node 用户 和 前端用户</p>\n</li>\n<li><p><strong>前端库优先优化 <code>module</code> &#x2F; <code>exports.import</code></strong><br>→ 确保支持 tree-shaking</p>\n</li>\n<li><p><strong>入口文件只暴露公共 API</strong><br>→ 不要让用户直接引用 <code>src/utils.js</code></p>\n</li>\n<li><p><strong>发布前用 <code>npm pack --dry-run</code> 验证</strong><br>→ 看看 <code>.tgz</code> 里有没有入口文件</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"🎯-总结：入口设计原则\"><a href=\"#🎯-总结：入口设计原则\" class=\"headerlink\" title=\"🎯 总结：入口设计原则\"></a>🎯 总结：入口设计原则</h2><blockquote>\n<ul>\n<li><strong>兼容性</strong>：让 <code>require</code> 和 <code>import</code> 用户都能用</li>\n<li><strong>性能</strong>：让前端项目能 tree-shaking</li>\n<li><strong>安全</strong>：用 <code>exports</code> 隐藏内部实现</li>\n<li><strong>清晰</strong>：入口文件只导出该导出的内容</li>\n</ul>\n</blockquote>\n<hr>\n<p>✅ <strong>一句话收尾</strong>：<br><strong>“入口”不是技术细节，而是你与使用者的“契约”——你决定他们如何开始使用你的代码。</strong></p>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><strong>“入口”是别人使用你的 npm 包时，程序从哪个文件开始加载。它是包的“正门”。</strong></p>\n</blockquote>\n<h2 id=\"🔑-一、核心入口字段\"><a href=\"#🔑-一、核心入口字段\" class=\"headerlink\" title=\"🔑 一、核心入口字段\"></a>🔑 一、核心入口字段</h2><table>\n<thead>\n<tr>\n<th>字段</th>\n<th>用途</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>main</code></td>\n<td>CommonJS 入口（Node.js 默认）</td>\n<td><code>require(&#39;pkg&#39;)</code></td>\n</tr>\n<tr>\n<td><code>module</code></td>\n<td>ES Module 入口（打包工具优先）</td>\n<td><code>import &#39;pkg&#39;</code>（Webpack&#x2F;Vite）</td>\n</tr>\n<tr>\n<td><code>exports</code></td>\n<td>精细控制多入口（现代推荐）</td>\n<td>现代项目首选</td>\n</tr>\n<tr>\n<td><code>browser</code></td>\n<td>浏览器环境入口（旧方式）</td>\n<td>兼容老项目</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧩-二、字段详解\"><a href=\"#🧩-二、字段详解\" class=\"headerlink\" title=\"🧩 二、字段详解\"></a>🧩 二、字段详解</h2><h3 id=\"1-main-——-Node-js-的“老朋友”\"><a href=\"#1-main-——-Node-js-的“老朋友”\" class=\"headerlink\" title=\"1. main —— Node.js 的“老朋友”\"></a>1. <code>main</code> —— Node.js 的“老朋友”</h3><ul>\n<li>✅ 作用：定义 <code>require(&#39;your-pkg&#39;)</code> 时加载的文件</li>\n<li>✅ 默认值：<code>index.js</code>（不推荐依赖默认）</li>\n<li>✅ 格式：CommonJS（<code>module.exports</code>）</li>\n<li>❌ 问题：不支持 tree-shaking（打包工具无法“摇掉”未用代码）</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dist/index.js&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-module-——-打包工具的“新宠”\"><a href=\"#2-module-——-打包工具的“新宠”\" class=\"headerlink\" title=\"2. module —— 打包工具的“新宠”\"></a>2. <code>module</code> —— 打包工具的“新宠”</h3><ul>\n<li>✅ 作用：为 Webpack、Vite 等工具提供 <strong>ES Module</strong> 入口</li>\n<li>✅ 格式：ES6 <code>export</code> &#x2F; <code>import</code></li>\n<li>✅ 优势：支持 <strong>tree-shaking</strong>，减小最终打包体积</li>\n<li>⚠️ 注意：必须提供 <code>.js</code> 文件（ESM 语法）</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dist/esm/index.js&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-exports-——-现代推荐方式（Node-js-12-）\"><a href=\"#3-exports-——-现代推荐方式（Node-js-12-）\" class=\"headerlink\" title=\"3. exports —— 现代推荐方式（Node.js 12+）\"></a>3. <code>exports</code> —— 现代推荐方式（Node.js 12+）</h3><ul>\n<li>✅ 作用：<strong>精确控制入口行为</strong>，支持条件导出</li>\n<li>✅ 优势：<ul>\n<li>支持 <code>import</code> &#x2F; <code>require</code> 分别指向不同文件</li>\n<li>可定义多个子入口（如 <code>pkg/helpers</code>）</li>\n<li>隐藏内部文件（如 <code>src/</code>）</li>\n</ul>\n</li>\n<li>✅ 推荐新项目使用</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;exports&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;.&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;import&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist/esm/index.js&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// ESM 用户</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;require&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist/cjs/index.js&quot;</span>  <span class=\"comment\">// CJS 用户</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;./helpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist/esm/helpers.js&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> main <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pkg&#x27;</span>;           <span class=\"comment\">// 走 &quot;.&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; helper &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pkg/helpers&#x27;</span>; <span class=\"comment\">// 走 &quot;./helpers&quot;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔄-三、入口查找优先级\"><a href=\"#🔄-三、入口查找优先级\" class=\"headerlink\" title=\"🔄 三、入口查找优先级\"></a>🔄 三、入口查找优先级</h2><h3 id=\"1-打包工具（Webpack-Vite）查找顺序：\"><a href=\"#1-打包工具（Webpack-Vite）查找顺序：\" class=\"headerlink\" title=\"1. 打包工具（Webpack&#x2F;Vite）查找顺序：\"></a>1. 打包工具（Webpack&#x2F;Vite）查找顺序：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports → module → main → index.js</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Node-js-查找顺序：\"><a href=\"#2-Node-js-查找顺序：\" class=\"headerlink\" title=\"2. Node.js 查找顺序：\"></a>2. Node.js 查找顺序：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports → main → index.js</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 建议：同时提供 <code>exports</code> + <code>main</code>，确保最大兼容性。</p>\n</blockquote>\n<hr>\n<h2 id=\"🌐-四、不同用户如何使用你的包？\"><a href=\"#🌐-四、不同用户如何使用你的包？\" class=\"headerlink\" title=\"🌐 四、不同用户如何使用你的包？\"></a>🌐 四、不同用户如何使用你的包？</h2><table>\n<thead>\n<tr>\n<th>用户类型</th>\n<th>使用方式</th>\n<th>加载哪个字段？</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.js <code>require</code> 用户</td>\n<td><code>const pkg = require(&#39;pkg&#39;)</code></td>\n<td><code>main</code> 或 <code>exports.require</code></td>\n</tr>\n<tr>\n<td>Webpack&#x2F;Vite <code>import</code> 用户</td>\n<td><code>import pkg from &#39;pkg&#39;</code></td>\n<td><code>module</code> 或 <code>exports.import</code></td>\n</tr>\n<tr>\n<td>浏览器原生 <code>import</code></td>\n<td><code>&lt;script type=&quot;module&quot;&gt;import from &#39;pkg&#39;&lt;/script&gt;</code></td>\n<td><code>module</code> 或 <code>exports.import</code></td>\n</tr>\n<tr>\n<td>TypeScript 用户</td>\n<td><code>import &#123; x &#125; from &#39;pkg&#39;</code></td>\n<td>同上 + <code>types</code> 字段</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"⚠️-五、常见误区澄清\"><a href=\"#⚠️-五、常见误区澄清\" class=\"headerlink\" title=\"⚠️ 五、常见误区澄清\"></a>⚠️ 五、常见误区澄清</h2><table>\n<thead>\n<tr>\n<th>误区</th>\n<th>正确认知</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“只写 <code>main</code> 就行”</td>\n<td>✅ 功能正常，但前端用户无法 tree-shaking ❌</td>\n</tr>\n<tr>\n<td>“浏览器能用 <code>require</code>”</td>\n<td>❌ 原生不支持！必须用打包工具转换</td>\n</tr>\n<tr>\n<td>“Node.js 不能用 <code>import</code>”</td>\n<td>❌ 可以！需 <code>.mjs</code> 或 <code>&quot;type&quot;: &quot;module&quot;</code></td>\n</tr>\n<tr>\n<td>“<code>module</code> 字段是给浏览器用的”</td>\n<td>❌ 是给<strong>打包工具</strong>用的，不是浏览器原生用</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-六、最佳实践建议\"><a href=\"#✅-六、最佳实践建议\" class=\"headerlink\" title=\"✅ 六、最佳实践建议\"></a>✅ 六、最佳实践建议</h2><ol>\n<li><p><strong>新项目必用 <code>exports</code></strong><br>→ 精细控制，未来兼容</p>\n</li>\n<li><p><strong>通用库必须同时提供 <code>main</code> 和 <code>module</code></strong><br>→ 服务 Node 用户 和 前端用户</p>\n</li>\n<li><p><strong>前端库优先优化 <code>module</code> &#x2F; <code>exports.import</code></strong><br>→ 确保支持 tree-shaking</p>\n</li>\n<li><p><strong>入口文件只暴露公共 API</strong><br>→ 不要让用户直接引用 <code>src/utils.js</code></p>\n</li>\n<li><p><strong>发布前用 <code>npm pack --dry-run</code> 验证</strong><br>→ 看看 <code>.tgz</code> 里有没有入口文件</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"🎯-总结：入口设计原则\"><a href=\"#🎯-总结：入口设计原则\" class=\"headerlink\" title=\"🎯 总结：入口设计原则\"></a>🎯 总结：入口设计原则</h2><blockquote>\n<ul>\n<li><strong>兼容性</strong>：让 <code>require</code> 和 <code>import</code> 用户都能用</li>\n<li><strong>性能</strong>：让前端项目能 tree-shaking</li>\n<li><strong>安全</strong>：用 <code>exports</code> 隐藏内部实现</li>\n<li><strong>清晰</strong>：入口文件只导出该导出的内容</li>\n</ul>\n</blockquote>\n<hr>\n<p>✅ <strong>一句话收尾</strong>：<br><strong>“入口”不是技术细节，而是你与使用者的“契约”——你决定他们如何开始使用你的代码。</strong></p>\n<hr>\n"},{"title":"npm开发库 本地测试的几种方案","_content":"\n> [npm包上传机制](/notes-Yian-04_1-npm%20包上传机制)\n\n**Q:** 使用npm开发一个组件库 但是每次都需要上传 然后install 这样改下 就要下载重新测试 极其麻烦\n\n# ✅ 总结\n\n| 方法         | 是否需要发布 | 实时性 | 推荐度 |\n|--------------|-------------|--------|--------|\n| `npm publish` + install | ✅ 需要     | ❌ 差   | ⭐☆☆☆☆ |\n| `npm link`           | ❌ 不需要   | ✅ 好   | ⭐⭐⭐⭐☆ |\n| `yalc`               | ❌ 不需要   | ✅ 好   | ⭐⭐⭐⭐☆ |\n| pnpm workspace       | ❌ 不需要   | ✅ 最佳 | ⭐⭐⭐⭐⭐ |\n\n---\n\n---\n\n## 1. `npm link`（最原生，最常用）\n\n### 📌 原理\n`npm link` 利用操作系统的 **符号链接（symlink）**，将你本地的组件库项目“链接”到另一个项目的 `node_modules` 中，就像真的安装了一样。\n\n### 🔧 使用步骤\n\n#### 步骤 1：在组件库项目中注册为可链接\n```bash\ncd your-component-lib\nnpm link\n```\n> 这会把你的库注册到全局的 npm 链接列表中（类似全局安装了一个软链接）。\n\n#### 步骤 2：在测试项目中链接该库\n```bash\ncd your-test-app\nnpm link your-component-lib-name\n```\n> `your-component-lib-name` 是组件库 `package.json` 中的 `name` 字段。\n\n#### ✅ 完成\n现在 `your-test-app/node_modules/your-component-lib-name` 是一个指向你本地组件库的软链接。\n\n---\n\n### ✅ 优点\n- 原生支持，无需额外工具。\n- 实时生效：组件库修改后，只要构建完成，测试项目就能看到变化（配合 `--watch` 模式更佳）。\n- 适合快速验证。\n\n### ❌ 缺点\n- **Node Modules 双重解析问题**：如果组件库和测试项目依赖了不同版本的 React/Vue，可能导致 `Invalid Hook Call` 等错误。\n- **权限问题**：在某些系统（如 Windows）或 Docker 环境中，创建软链接可能需要管理员权限。\n- **调试路径混乱**：IDE 可能跳转到 `node_modules` 的链接，而不是源码。\n- **不能模拟真实的 `npm install` 行为**（比如 `files` 字段过滤）。\n\n---\n\n### 🛠️ 最佳实践\n- 组件库使用 `npm run build --watch` 监听构建。\n- 测试项目使用 `npm start` 启动开发服务器。\n- 修改组件 → 自动构建 → 测试项目热更新。\n\n---\n\n## 2. `yalc`（现代替代方案）\n> 实际上使用的是file协议 [file协议](06-flle协议.md)\n\n### 📌 原理\n`yalc` 模拟了 `npm install` 的行为，但它从本地文件系统复制构建后的文件到测试项目的 `.yalc/` 目录，并修改 `package.json` 和 `node_modules`，**不使用软链接**。\n\n### 🔧 安装与使用\n\n#### 安装 yalc\n```bash\nnpm install -g yalc\n```\n\n#### 步骤 1：在组件库中“发布”到本地仓库\n\n```bash\ncd your-component-lib\n# 先构建（确保 dist 存在）\nnpm run build\n# 推送到 yalc 本地仓库\nyalc push\n```\n\n> `yalc push` 会把 `dist/` 或 `lib/` 等打包后的文件复制到 `~/.yalc/`。\n\n#### 步骤 2：在测试项目中“安装”\n```bash\ncd your-test-app\nyalc add your-component-lib-name\n```\n> 这会：\n> - 在 `package.json` 中添加 `\"your-component-lib-name\": \"file:.yalc/your-component-lib-name\"`\n> - 把文件复制到 `.yalc/your-component-lib-name`\n> - 创建 `node_modules` 链接\n\n#### ✅ 完成\n现在你可以像使用 npm 包一样使用它。\n\n#### 更新组件库后\n```bash\n# 在组件库中修改并重新构建\nnpm run build\nyalc push  # 推送更新\n```\n\n在测试项目中：\n```bash\nyalc update your-component-lib-name\n```\n\n---\n\n### ✅ 优点\n- 不依赖软链接，避免权限问题。\n- 更接近真实 `npm install` 的行为（只复制 `files` 字段指定的文件）。\n- 支持版本管理（`yalc push --version 1.0.1`）。\n- 可以同时测试多个版本。\n\n### ❌ 缺点\n- 需要手动 `push` 和 `update`，不是完全实时。\n- 多了一层 `.yalc` 目录，项目略显复杂。\n- 需要全局安装 `yalc`。\n\n---\n\n### 🎯 适用场景\n- 你希望更真实地模拟 `npm install`。\n- 你在 Windows 或 Docker 中遇到 `npm link` 权限问题。\n- 你需要测试多个版本的组件库。\n\n---\n\n## 3. `pnpm workspace`（最推荐的长期方案）\n\n### 📌 原理\n`pnpm` 支持 **workspace（工作区）**，允许你在一个 monorepo 中管理多个包。你可以把组件库和测试项目放在同一个 workspace 中，`pnpm` 会自动用软链接连接它们。\n\n### 📁 项目结构示例\n```\nmy-monorepo/\n├── package.json        # 根目录，定义 workspace\n├── pnpm-workspace.yaml\n├── packages/\n│   ├── component-lib/  # 组件库\n│   └── demo-app/       # 测试项目\n```\n\n### 🔧 配置步骤\n\n#### 1. 根目录 `package.json`\n```json\n{\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ]\n}\n```\n\n#### 2. 根目录 `pnpm-workspace.yaml`\n```yaml\npackages:\n  - 'packages/*'\n```\n\n#### 3. 在 `demo-app/package.json` 中添加依赖\n```json\n{\n  \"dependencies\": {\n    \"component-lib\": \"*\"\n  }\n}\n```\n\n#### 4. 安装依赖\n```bash\ncd my-monorepo\npnpm install\n```\n\n> `pnpm` 会自动识别 workspace 内的包，并创建软链接。\n\n---\n\n### ✅ 优点\n- **完全自动化**：安装、链接、更新都由 `pnpm` 管理。\n- **支持多包管理**：适合未来扩展更多组件或工具。\n- **性能好**：`pnpm` 使用硬链接 + 内容寻址，节省磁盘空间。\n- **生态完善**：可与 Turborepo、Nx 等工具集成，实现任务调度（如 `build`、`test`）。\n\n### ❌ 缺点\n- 需要切换到 `pnpm` 包管理器（如果你原来用 `npm` 或 `yarn`）。\n- 初期配置稍复杂。\n- 团队协作需要统一使用 `pnpm`。\n\n---\n\n### 🎯 适用场景\n- 你计划长期维护组件库，甚至发展为 UI 库、设计系统。\n- 你有多个相关项目需要联动开发。\n- 你追求最佳开发体验和工程化规范。\n\n---\n\n\n## 🏁 建议\n\n- **临时测试 / 快速验证** → 用 `npm link`\n- **遇到 link 问题 / 想更真实模拟 install** → 用 `yalc`\n- **长期开发 / 团队项目 / 构建组件体系** → 用 `pnpm workspace`\n\n---\n\n","source":"_posts/npm开发库 本地测试的几种方案.md","raw":"---\ntitle: npm开发库 本地测试的几种方案\n---\n\n> [npm包上传机制](/notes-Yian-04_1-npm%20包上传机制)\n\n**Q:** 使用npm开发一个组件库 但是每次都需要上传 然后install 这样改下 就要下载重新测试 极其麻烦\n\n# ✅ 总结\n\n| 方法         | 是否需要发布 | 实时性 | 推荐度 |\n|--------------|-------------|--------|--------|\n| `npm publish` + install | ✅ 需要     | ❌ 差   | ⭐☆☆☆☆ |\n| `npm link`           | ❌ 不需要   | ✅ 好   | ⭐⭐⭐⭐☆ |\n| `yalc`               | ❌ 不需要   | ✅ 好   | ⭐⭐⭐⭐☆ |\n| pnpm workspace       | ❌ 不需要   | ✅ 最佳 | ⭐⭐⭐⭐⭐ |\n\n---\n\n---\n\n## 1. `npm link`（最原生，最常用）\n\n### 📌 原理\n`npm link` 利用操作系统的 **符号链接（symlink）**，将你本地的组件库项目“链接”到另一个项目的 `node_modules` 中，就像真的安装了一样。\n\n### 🔧 使用步骤\n\n#### 步骤 1：在组件库项目中注册为可链接\n```bash\ncd your-component-lib\nnpm link\n```\n> 这会把你的库注册到全局的 npm 链接列表中（类似全局安装了一个软链接）。\n\n#### 步骤 2：在测试项目中链接该库\n```bash\ncd your-test-app\nnpm link your-component-lib-name\n```\n> `your-component-lib-name` 是组件库 `package.json` 中的 `name` 字段。\n\n#### ✅ 完成\n现在 `your-test-app/node_modules/your-component-lib-name` 是一个指向你本地组件库的软链接。\n\n---\n\n### ✅ 优点\n- 原生支持，无需额外工具。\n- 实时生效：组件库修改后，只要构建完成，测试项目就能看到变化（配合 `--watch` 模式更佳）。\n- 适合快速验证。\n\n### ❌ 缺点\n- **Node Modules 双重解析问题**：如果组件库和测试项目依赖了不同版本的 React/Vue，可能导致 `Invalid Hook Call` 等错误。\n- **权限问题**：在某些系统（如 Windows）或 Docker 环境中，创建软链接可能需要管理员权限。\n- **调试路径混乱**：IDE 可能跳转到 `node_modules` 的链接，而不是源码。\n- **不能模拟真实的 `npm install` 行为**（比如 `files` 字段过滤）。\n\n---\n\n### 🛠️ 最佳实践\n- 组件库使用 `npm run build --watch` 监听构建。\n- 测试项目使用 `npm start` 启动开发服务器。\n- 修改组件 → 自动构建 → 测试项目热更新。\n\n---\n\n## 2. `yalc`（现代替代方案）\n> 实际上使用的是file协议 [file协议](06-flle协议.md)\n\n### 📌 原理\n`yalc` 模拟了 `npm install` 的行为，但它从本地文件系统复制构建后的文件到测试项目的 `.yalc/` 目录，并修改 `package.json` 和 `node_modules`，**不使用软链接**。\n\n### 🔧 安装与使用\n\n#### 安装 yalc\n```bash\nnpm install -g yalc\n```\n\n#### 步骤 1：在组件库中“发布”到本地仓库\n\n```bash\ncd your-component-lib\n# 先构建（确保 dist 存在）\nnpm run build\n# 推送到 yalc 本地仓库\nyalc push\n```\n\n> `yalc push` 会把 `dist/` 或 `lib/` 等打包后的文件复制到 `~/.yalc/`。\n\n#### 步骤 2：在测试项目中“安装”\n```bash\ncd your-test-app\nyalc add your-component-lib-name\n```\n> 这会：\n> - 在 `package.json` 中添加 `\"your-component-lib-name\": \"file:.yalc/your-component-lib-name\"`\n> - 把文件复制到 `.yalc/your-component-lib-name`\n> - 创建 `node_modules` 链接\n\n#### ✅ 完成\n现在你可以像使用 npm 包一样使用它。\n\n#### 更新组件库后\n```bash\n# 在组件库中修改并重新构建\nnpm run build\nyalc push  # 推送更新\n```\n\n在测试项目中：\n```bash\nyalc update your-component-lib-name\n```\n\n---\n\n### ✅ 优点\n- 不依赖软链接，避免权限问题。\n- 更接近真实 `npm install` 的行为（只复制 `files` 字段指定的文件）。\n- 支持版本管理（`yalc push --version 1.0.1`）。\n- 可以同时测试多个版本。\n\n### ❌ 缺点\n- 需要手动 `push` 和 `update`，不是完全实时。\n- 多了一层 `.yalc` 目录，项目略显复杂。\n- 需要全局安装 `yalc`。\n\n---\n\n### 🎯 适用场景\n- 你希望更真实地模拟 `npm install`。\n- 你在 Windows 或 Docker 中遇到 `npm link` 权限问题。\n- 你需要测试多个版本的组件库。\n\n---\n\n## 3. `pnpm workspace`（最推荐的长期方案）\n\n### 📌 原理\n`pnpm` 支持 **workspace（工作区）**，允许你在一个 monorepo 中管理多个包。你可以把组件库和测试项目放在同一个 workspace 中，`pnpm` 会自动用软链接连接它们。\n\n### 📁 项目结构示例\n```\nmy-monorepo/\n├── package.json        # 根目录，定义 workspace\n├── pnpm-workspace.yaml\n├── packages/\n│   ├── component-lib/  # 组件库\n│   └── demo-app/       # 测试项目\n```\n\n### 🔧 配置步骤\n\n#### 1. 根目录 `package.json`\n```json\n{\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ]\n}\n```\n\n#### 2. 根目录 `pnpm-workspace.yaml`\n```yaml\npackages:\n  - 'packages/*'\n```\n\n#### 3. 在 `demo-app/package.json` 中添加依赖\n```json\n{\n  \"dependencies\": {\n    \"component-lib\": \"*\"\n  }\n}\n```\n\n#### 4. 安装依赖\n```bash\ncd my-monorepo\npnpm install\n```\n\n> `pnpm` 会自动识别 workspace 内的包，并创建软链接。\n\n---\n\n### ✅ 优点\n- **完全自动化**：安装、链接、更新都由 `pnpm` 管理。\n- **支持多包管理**：适合未来扩展更多组件或工具。\n- **性能好**：`pnpm` 使用硬链接 + 内容寻址，节省磁盘空间。\n- **生态完善**：可与 Turborepo、Nx 等工具集成，实现任务调度（如 `build`、`test`）。\n\n### ❌ 缺点\n- 需要切换到 `pnpm` 包管理器（如果你原来用 `npm` 或 `yarn`）。\n- 初期配置稍复杂。\n- 团队协作需要统一使用 `pnpm`。\n\n---\n\n### 🎯 适用场景\n- 你计划长期维护组件库，甚至发展为 UI 库、设计系统。\n- 你有多个相关项目需要联动开发。\n- 你追求最佳开发体验和工程化规范。\n\n---\n\n\n## 🏁 建议\n\n- **临时测试 / 快速验证** → 用 `npm link`\n- **遇到 link 问题 / 想更真实模拟 install** → 用 `yalc`\n- **长期开发 / 团队项目 / 构建组件体系** → 用 `pnpm workspace`\n\n---\n\n","slug":"npm开发库 本地测试的几种方案","published":1,"date":"2025-09-02T01:50:34.906Z","updated":"2025-09-01T09:54:01.766Z","_id":"cmf1wtvkk000oq4v957z71224","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><a href=\"/notes-Yian-04_1-npm%20%E5%8C%85%E4%B8%8A%E4%BC%A0%E6%9C%BA%E5%88%B6\">npm包上传机制</a></p>\n</blockquote>\n<p><strong>Q:</strong> 使用npm开发一个组件库 但是每次都需要上传 然后install 这样改下 就要下载重新测试 极其麻烦</p>\n<h1 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h1><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>是否需要发布</th>\n<th>实时性</th>\n<th>推荐度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>npm publish</code> + install</td>\n<td>✅ 需要</td>\n<td>❌ 差</td>\n<td>⭐☆☆☆☆</td>\n</tr>\n<tr>\n<td><code>npm link</code></td>\n<td>❌ 不需要</td>\n<td>✅ 好</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td><code>yalc</code></td>\n<td>❌ 不需要</td>\n<td>✅ 好</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td>pnpm workspace</td>\n<td>❌ 不需要</td>\n<td>✅ 最佳</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n</tbody></table>\n<hr>\n<hr>\n<h2 id=\"1-npm-link（最原生，最常用）\"><a href=\"#1-npm-link（最原生，最常用）\" class=\"headerlink\" title=\"1. npm link（最原生，最常用）\"></a>1. <code>npm link</code>（最原生，最常用）</h2><h3 id=\"📌-原理\"><a href=\"#📌-原理\" class=\"headerlink\" title=\"📌 原理\"></a>📌 原理</h3><p><code>npm link</code> 利用操作系统的 <strong>符号链接（symlink）</strong>，将你本地的组件库项目“链接”到另一个项目的 <code>node_modules</code> 中，就像真的安装了一样。</p>\n<h3 id=\"🔧-使用步骤\"><a href=\"#🔧-使用步骤\" class=\"headerlink\" title=\"🔧 使用步骤\"></a>🔧 使用步骤</h3><h4 id=\"步骤-1：在组件库项目中注册为可链接\"><a href=\"#步骤-1：在组件库项目中注册为可链接\" class=\"headerlink\" title=\"步骤 1：在组件库项目中注册为可链接\"></a>步骤 1：在组件库项目中注册为可链接</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-component-lib</span><br><span class=\"line\">npm <span class=\"built_in\">link</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这会把你的库注册到全局的 npm 链接列表中（类似全局安装了一个软链接）。</p>\n</blockquote>\n<h4 id=\"步骤-2：在测试项目中链接该库\"><a href=\"#步骤-2：在测试项目中链接该库\" class=\"headerlink\" title=\"步骤 2：在测试项目中链接该库\"></a>步骤 2：在测试项目中链接该库</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-test-app</span><br><span class=\"line\">npm <span class=\"built_in\">link</span> your-component-lib-name</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>your-component-lib-name</code> 是组件库 <code>package.json</code> 中的 <code>name</code> 字段。</p>\n</blockquote>\n<h4 id=\"✅-完成\"><a href=\"#✅-完成\" class=\"headerlink\" title=\"✅ 完成\"></a>✅ 完成</h4><p>现在 <code>your-test-app/node_modules/your-component-lib-name</code> 是一个指向你本地组件库的软链接。</p>\n<hr>\n<h3 id=\"✅-优点\"><a href=\"#✅-优点\" class=\"headerlink\" title=\"✅ 优点\"></a>✅ 优点</h3><ul>\n<li>原生支持，无需额外工具。</li>\n<li>实时生效：组件库修改后，只要构建完成，测试项目就能看到变化（配合 <code>--watch</code> 模式更佳）。</li>\n<li>适合快速验证。</li>\n</ul>\n<h3 id=\"❌-缺点\"><a href=\"#❌-缺点\" class=\"headerlink\" title=\"❌ 缺点\"></a>❌ 缺点</h3><ul>\n<li><strong>Node Modules 双重解析问题</strong>：如果组件库和测试项目依赖了不同版本的 React&#x2F;Vue，可能导致 <code>Invalid Hook Call</code> 等错误。</li>\n<li><strong>权限问题</strong>：在某些系统（如 Windows）或 Docker 环境中，创建软链接可能需要管理员权限。</li>\n<li><strong>调试路径混乱</strong>：IDE 可能跳转到 <code>node_modules</code> 的链接，而不是源码。</li>\n<li><strong>不能模拟真实的 <code>npm install</code> 行为</strong>（比如 <code>files</code> 字段过滤）。</li>\n</ul>\n<hr>\n<h3 id=\"🛠️-最佳实践\"><a href=\"#🛠️-最佳实践\" class=\"headerlink\" title=\"🛠️ 最佳实践\"></a>🛠️ 最佳实践</h3><ul>\n<li>组件库使用 <code>npm run build --watch</code> 监听构建。</li>\n<li>测试项目使用 <code>npm start</code> 启动开发服务器。</li>\n<li>修改组件 → 自动构建 → 测试项目热更新。</li>\n</ul>\n<hr>\n<h2 id=\"2-yalc（现代替代方案）\"><a href=\"#2-yalc（现代替代方案）\" class=\"headerlink\" title=\"2. yalc（现代替代方案）\"></a>2. <code>yalc</code>（现代替代方案）</h2><blockquote>\n<p>实际上使用的是file协议 <a href=\"06-flle%E5%8D%8F%E8%AE%AE.md\">file协议</a></p>\n</blockquote>\n<h3 id=\"📌-原理-1\"><a href=\"#📌-原理-1\" class=\"headerlink\" title=\"📌 原理\"></a>📌 原理</h3><p><code>yalc</code> 模拟了 <code>npm install</code> 的行为，但它从本地文件系统复制构建后的文件到测试项目的 <code>.yalc/</code> 目录，并修改 <code>package.json</code> 和 <code>node_modules</code>，<strong>不使用软链接</strong>。</p>\n<h3 id=\"🔧-安装与使用\"><a href=\"#🔧-安装与使用\" class=\"headerlink\" title=\"🔧 安装与使用\"></a>🔧 安装与使用</h3><h4 id=\"安装-yalc\"><a href=\"#安装-yalc\" class=\"headerlink\" title=\"安装 yalc\"></a>安装 yalc</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g yalc</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤-1：在组件库中“发布”到本地仓库\"><a href=\"#步骤-1：在组件库中“发布”到本地仓库\" class=\"headerlink\" title=\"步骤 1：在组件库中“发布”到本地仓库\"></a>步骤 1：在组件库中“发布”到本地仓库</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-component-lib</span><br><span class=\"line\"><span class=\"comment\"># 先构建（确保 dist 存在）</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\"><span class=\"comment\"># 推送到 yalc 本地仓库</span></span><br><span class=\"line\">yalc push</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>yalc push</code> 会把 <code>dist/</code> 或 <code>lib/</code> 等打包后的文件复制到 <code>~/.yalc/</code>。</p>\n</blockquote>\n<h4 id=\"步骤-2：在测试项目中“安装”\"><a href=\"#步骤-2：在测试项目中“安装”\" class=\"headerlink\" title=\"步骤 2：在测试项目中“安装”\"></a>步骤 2：在测试项目中“安装”</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-test-app</span><br><span class=\"line\">yalc add your-component-lib-name</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这会：</p>\n<ul>\n<li>在 <code>package.json</code> 中添加 <code>&quot;your-component-lib-name&quot;: &quot;file:.yalc/your-component-lib-name&quot;</code></li>\n<li>把文件复制到 <code>.yalc/your-component-lib-name</code></li>\n<li>创建 <code>node_modules</code> 链接</li>\n</ul>\n</blockquote>\n<h4 id=\"✅-完成-1\"><a href=\"#✅-完成-1\" class=\"headerlink\" title=\"✅ 完成\"></a>✅ 完成</h4><p>现在你可以像使用 npm 包一样使用它。</p>\n<h4 id=\"更新组件库后\"><a href=\"#更新组件库后\" class=\"headerlink\" title=\"更新组件库后\"></a>更新组件库后</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在组件库中修改并重新构建</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\">yalc push  <span class=\"comment\"># 推送更新</span></span><br></pre></td></tr></table></figure>\n\n<p>在测试项目中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yalc update your-component-lib-name</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"✅-优点-1\"><a href=\"#✅-优点-1\" class=\"headerlink\" title=\"✅ 优点\"></a>✅ 优点</h3><ul>\n<li>不依赖软链接，避免权限问题。</li>\n<li>更接近真实 <code>npm install</code> 的行为（只复制 <code>files</code> 字段指定的文件）。</li>\n<li>支持版本管理（<code>yalc push --version 1.0.1</code>）。</li>\n<li>可以同时测试多个版本。</li>\n</ul>\n<h3 id=\"❌-缺点-1\"><a href=\"#❌-缺点-1\" class=\"headerlink\" title=\"❌ 缺点\"></a>❌ 缺点</h3><ul>\n<li>需要手动 <code>push</code> 和 <code>update</code>，不是完全实时。</li>\n<li>多了一层 <code>.yalc</code> 目录，项目略显复杂。</li>\n<li>需要全局安装 <code>yalc</code>。</li>\n</ul>\n<hr>\n<h3 id=\"🎯-适用场景\"><a href=\"#🎯-适用场景\" class=\"headerlink\" title=\"🎯 适用场景\"></a>🎯 适用场景</h3><ul>\n<li>你希望更真实地模拟 <code>npm install</code>。</li>\n<li>你在 Windows 或 Docker 中遇到 <code>npm link</code> 权限问题。</li>\n<li>你需要测试多个版本的组件库。</li>\n</ul>\n<hr>\n<h2 id=\"3-pnpm-workspace（最推荐的长期方案）\"><a href=\"#3-pnpm-workspace（最推荐的长期方案）\" class=\"headerlink\" title=\"3. pnpm workspace（最推荐的长期方案）\"></a>3. <code>pnpm workspace</code>（最推荐的长期方案）</h2><h3 id=\"📌-原理-2\"><a href=\"#📌-原理-2\" class=\"headerlink\" title=\"📌 原理\"></a>📌 原理</h3><p><code>pnpm</code> 支持 <strong>workspace（工作区）</strong>，允许你在一个 monorepo 中管理多个包。你可以把组件库和测试项目放在同一个 workspace 中，<code>pnpm</code> 会自动用软链接连接它们。</p>\n<h3 id=\"📁-项目结构示例\"><a href=\"#📁-项目结构示例\" class=\"headerlink\" title=\"📁 项目结构示例\"></a>📁 项目结构示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json        # 根目录，定义 workspace</span><br><span class=\"line\">├── pnpm-workspace.yaml</span><br><span class=\"line\">├── packages/</span><br><span class=\"line\">│   ├── component-lib/  # 组件库</span><br><span class=\"line\">│   └── demo-app/       # 测试项目</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔧-配置步骤\"><a href=\"#🔧-配置步骤\" class=\"headerlink\" title=\"🔧 配置步骤\"></a>🔧 配置步骤</h3><h4 id=\"1-根目录-package-json\"><a href=\"#1-根目录-package-json\" class=\"headerlink\" title=\"1. 根目录 package.json\"></a>1. 根目录 <code>package.json</code></h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;workspaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;packages/*&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-根目录-pnpm-workspace-yaml\"><a href=\"#2-根目录-pnpm-workspace-yaml\" class=\"headerlink\" title=\"2. 根目录 pnpm-workspace.yaml\"></a>2. 根目录 <code>pnpm-workspace.yaml</code></h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">packages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">&#x27;packages/*&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-在-demo-app-package-json-中添加依赖\"><a href=\"#3-在-demo-app-package-json-中添加依赖\" class=\"headerlink\" title=\"3. 在 demo-app/package.json 中添加依赖\"></a>3. 在 <code>demo-app/package.json</code> 中添加依赖</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;component-lib&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-安装依赖\"><a href=\"#4-安装依赖\" class=\"headerlink\" title=\"4. 安装依赖\"></a>4. 安装依赖</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> my-monorepo</span><br><span class=\"line\">pnpm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>pnpm</code> 会自动识别 workspace 内的包，并创建软链接。</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-优点-2\"><a href=\"#✅-优点-2\" class=\"headerlink\" title=\"✅ 优点\"></a>✅ 优点</h3><ul>\n<li><strong>完全自动化</strong>：安装、链接、更新都由 <code>pnpm</code> 管理。</li>\n<li><strong>支持多包管理</strong>：适合未来扩展更多组件或工具。</li>\n<li><strong>性能好</strong>：<code>pnpm</code> 使用硬链接 + 内容寻址，节省磁盘空间。</li>\n<li><strong>生态完善</strong>：可与 Turborepo、Nx 等工具集成，实现任务调度（如 <code>build</code>、<code>test</code>）。</li>\n</ul>\n<h3 id=\"❌-缺点-2\"><a href=\"#❌-缺点-2\" class=\"headerlink\" title=\"❌ 缺点\"></a>❌ 缺点</h3><ul>\n<li>需要切换到 <code>pnpm</code> 包管理器（如果你原来用 <code>npm</code> 或 <code>yarn</code>）。</li>\n<li>初期配置稍复杂。</li>\n<li>团队协作需要统一使用 <code>pnpm</code>。</li>\n</ul>\n<hr>\n<h3 id=\"🎯-适用场景-1\"><a href=\"#🎯-适用场景-1\" class=\"headerlink\" title=\"🎯 适用场景\"></a>🎯 适用场景</h3><ul>\n<li>你计划长期维护组件库，甚至发展为 UI 库、设计系统。</li>\n<li>你有多个相关项目需要联动开发。</li>\n<li>你追求最佳开发体验和工程化规范。</li>\n</ul>\n<hr>\n<h2 id=\"🏁-建议\"><a href=\"#🏁-建议\" class=\"headerlink\" title=\"🏁 建议\"></a>🏁 建议</h2><ul>\n<li><strong>临时测试 &#x2F; 快速验证</strong> → 用 <code>npm link</code></li>\n<li><strong>遇到 link 问题 &#x2F; 想更真实模拟 install</strong> → 用 <code>yalc</code></li>\n<li><strong>长期开发 &#x2F; 团队项目 &#x2F; 构建组件体系</strong> → 用 <code>pnpm workspace</code></li>\n</ul>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"/notes-Yian-04_1-npm%20%E5%8C%85%E4%B8%8A%E4%BC%A0%E6%9C%BA%E5%88%B6\">npm包上传机制</a></p>\n</blockquote>\n<p><strong>Q:</strong> 使用npm开发一个组件库 但是每次都需要上传 然后install 这样改下 就要下载重新测试 极其麻烦</p>\n<h1 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h1><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>是否需要发布</th>\n<th>实时性</th>\n<th>推荐度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>npm publish</code> + install</td>\n<td>✅ 需要</td>\n<td>❌ 差</td>\n<td>⭐☆☆☆☆</td>\n</tr>\n<tr>\n<td><code>npm link</code></td>\n<td>❌ 不需要</td>\n<td>✅ 好</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td><code>yalc</code></td>\n<td>❌ 不需要</td>\n<td>✅ 好</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td>pnpm workspace</td>\n<td>❌ 不需要</td>\n<td>✅ 最佳</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n</tbody></table>\n<hr>\n<hr>\n<h2 id=\"1-npm-link（最原生，最常用）\"><a href=\"#1-npm-link（最原生，最常用）\" class=\"headerlink\" title=\"1. npm link（最原生，最常用）\"></a>1. <code>npm link</code>（最原生，最常用）</h2><h3 id=\"📌-原理\"><a href=\"#📌-原理\" class=\"headerlink\" title=\"📌 原理\"></a>📌 原理</h3><p><code>npm link</code> 利用操作系统的 <strong>符号链接（symlink）</strong>，将你本地的组件库项目“链接”到另一个项目的 <code>node_modules</code> 中，就像真的安装了一样。</p>\n<h3 id=\"🔧-使用步骤\"><a href=\"#🔧-使用步骤\" class=\"headerlink\" title=\"🔧 使用步骤\"></a>🔧 使用步骤</h3><h4 id=\"步骤-1：在组件库项目中注册为可链接\"><a href=\"#步骤-1：在组件库项目中注册为可链接\" class=\"headerlink\" title=\"步骤 1：在组件库项目中注册为可链接\"></a>步骤 1：在组件库项目中注册为可链接</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-component-lib</span><br><span class=\"line\">npm <span class=\"built_in\">link</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这会把你的库注册到全局的 npm 链接列表中（类似全局安装了一个软链接）。</p>\n</blockquote>\n<h4 id=\"步骤-2：在测试项目中链接该库\"><a href=\"#步骤-2：在测试项目中链接该库\" class=\"headerlink\" title=\"步骤 2：在测试项目中链接该库\"></a>步骤 2：在测试项目中链接该库</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-test-app</span><br><span class=\"line\">npm <span class=\"built_in\">link</span> your-component-lib-name</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>your-component-lib-name</code> 是组件库 <code>package.json</code> 中的 <code>name</code> 字段。</p>\n</blockquote>\n<h4 id=\"✅-完成\"><a href=\"#✅-完成\" class=\"headerlink\" title=\"✅ 完成\"></a>✅ 完成</h4><p>现在 <code>your-test-app/node_modules/your-component-lib-name</code> 是一个指向你本地组件库的软链接。</p>\n<hr>\n<h3 id=\"✅-优点\"><a href=\"#✅-优点\" class=\"headerlink\" title=\"✅ 优点\"></a>✅ 优点</h3><ul>\n<li>原生支持，无需额外工具。</li>\n<li>实时生效：组件库修改后，只要构建完成，测试项目就能看到变化（配合 <code>--watch</code> 模式更佳）。</li>\n<li>适合快速验证。</li>\n</ul>\n<h3 id=\"❌-缺点\"><a href=\"#❌-缺点\" class=\"headerlink\" title=\"❌ 缺点\"></a>❌ 缺点</h3><ul>\n<li><strong>Node Modules 双重解析问题</strong>：如果组件库和测试项目依赖了不同版本的 React&#x2F;Vue，可能导致 <code>Invalid Hook Call</code> 等错误。</li>\n<li><strong>权限问题</strong>：在某些系统（如 Windows）或 Docker 环境中，创建软链接可能需要管理员权限。</li>\n<li><strong>调试路径混乱</strong>：IDE 可能跳转到 <code>node_modules</code> 的链接，而不是源码。</li>\n<li><strong>不能模拟真实的 <code>npm install</code> 行为</strong>（比如 <code>files</code> 字段过滤）。</li>\n</ul>\n<hr>\n<h3 id=\"🛠️-最佳实践\"><a href=\"#🛠️-最佳实践\" class=\"headerlink\" title=\"🛠️ 最佳实践\"></a>🛠️ 最佳实践</h3><ul>\n<li>组件库使用 <code>npm run build --watch</code> 监听构建。</li>\n<li>测试项目使用 <code>npm start</code> 启动开发服务器。</li>\n<li>修改组件 → 自动构建 → 测试项目热更新。</li>\n</ul>\n<hr>\n<h2 id=\"2-yalc（现代替代方案）\"><a href=\"#2-yalc（现代替代方案）\" class=\"headerlink\" title=\"2. yalc（现代替代方案）\"></a>2. <code>yalc</code>（现代替代方案）</h2><blockquote>\n<p>实际上使用的是file协议 <a href=\"06-flle%E5%8D%8F%E8%AE%AE.md\">file协议</a></p>\n</blockquote>\n<h3 id=\"📌-原理-1\"><a href=\"#📌-原理-1\" class=\"headerlink\" title=\"📌 原理\"></a>📌 原理</h3><p><code>yalc</code> 模拟了 <code>npm install</code> 的行为，但它从本地文件系统复制构建后的文件到测试项目的 <code>.yalc/</code> 目录，并修改 <code>package.json</code> 和 <code>node_modules</code>，<strong>不使用软链接</strong>。</p>\n<h3 id=\"🔧-安装与使用\"><a href=\"#🔧-安装与使用\" class=\"headerlink\" title=\"🔧 安装与使用\"></a>🔧 安装与使用</h3><h4 id=\"安装-yalc\"><a href=\"#安装-yalc\" class=\"headerlink\" title=\"安装 yalc\"></a>安装 yalc</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g yalc</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤-1：在组件库中“发布”到本地仓库\"><a href=\"#步骤-1：在组件库中“发布”到本地仓库\" class=\"headerlink\" title=\"步骤 1：在组件库中“发布”到本地仓库\"></a>步骤 1：在组件库中“发布”到本地仓库</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-component-lib</span><br><span class=\"line\"><span class=\"comment\"># 先构建（确保 dist 存在）</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\"><span class=\"comment\"># 推送到 yalc 本地仓库</span></span><br><span class=\"line\">yalc push</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>yalc push</code> 会把 <code>dist/</code> 或 <code>lib/</code> 等打包后的文件复制到 <code>~/.yalc/</code>。</p>\n</blockquote>\n<h4 id=\"步骤-2：在测试项目中“安装”\"><a href=\"#步骤-2：在测试项目中“安装”\" class=\"headerlink\" title=\"步骤 2：在测试项目中“安装”\"></a>步骤 2：在测试项目中“安装”</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> your-test-app</span><br><span class=\"line\">yalc add your-component-lib-name</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这会：</p>\n<ul>\n<li>在 <code>package.json</code> 中添加 <code>&quot;your-component-lib-name&quot;: &quot;file:.yalc/your-component-lib-name&quot;</code></li>\n<li>把文件复制到 <code>.yalc/your-component-lib-name</code></li>\n<li>创建 <code>node_modules</code> 链接</li>\n</ul>\n</blockquote>\n<h4 id=\"✅-完成-1\"><a href=\"#✅-完成-1\" class=\"headerlink\" title=\"✅ 完成\"></a>✅ 完成</h4><p>现在你可以像使用 npm 包一样使用它。</p>\n<h4 id=\"更新组件库后\"><a href=\"#更新组件库后\" class=\"headerlink\" title=\"更新组件库后\"></a>更新组件库后</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在组件库中修改并重新构建</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\">yalc push  <span class=\"comment\"># 推送更新</span></span><br></pre></td></tr></table></figure>\n\n<p>在测试项目中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yalc update your-component-lib-name</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"✅-优点-1\"><a href=\"#✅-优点-1\" class=\"headerlink\" title=\"✅ 优点\"></a>✅ 优点</h3><ul>\n<li>不依赖软链接，避免权限问题。</li>\n<li>更接近真实 <code>npm install</code> 的行为（只复制 <code>files</code> 字段指定的文件）。</li>\n<li>支持版本管理（<code>yalc push --version 1.0.1</code>）。</li>\n<li>可以同时测试多个版本。</li>\n</ul>\n<h3 id=\"❌-缺点-1\"><a href=\"#❌-缺点-1\" class=\"headerlink\" title=\"❌ 缺点\"></a>❌ 缺点</h3><ul>\n<li>需要手动 <code>push</code> 和 <code>update</code>，不是完全实时。</li>\n<li>多了一层 <code>.yalc</code> 目录，项目略显复杂。</li>\n<li>需要全局安装 <code>yalc</code>。</li>\n</ul>\n<hr>\n<h3 id=\"🎯-适用场景\"><a href=\"#🎯-适用场景\" class=\"headerlink\" title=\"🎯 适用场景\"></a>🎯 适用场景</h3><ul>\n<li>你希望更真实地模拟 <code>npm install</code>。</li>\n<li>你在 Windows 或 Docker 中遇到 <code>npm link</code> 权限问题。</li>\n<li>你需要测试多个版本的组件库。</li>\n</ul>\n<hr>\n<h2 id=\"3-pnpm-workspace（最推荐的长期方案）\"><a href=\"#3-pnpm-workspace（最推荐的长期方案）\" class=\"headerlink\" title=\"3. pnpm workspace（最推荐的长期方案）\"></a>3. <code>pnpm workspace</code>（最推荐的长期方案）</h2><h3 id=\"📌-原理-2\"><a href=\"#📌-原理-2\" class=\"headerlink\" title=\"📌 原理\"></a>📌 原理</h3><p><code>pnpm</code> 支持 <strong>workspace（工作区）</strong>，允许你在一个 monorepo 中管理多个包。你可以把组件库和测试项目放在同一个 workspace 中，<code>pnpm</code> 会自动用软链接连接它们。</p>\n<h3 id=\"📁-项目结构示例\"><a href=\"#📁-项目结构示例\" class=\"headerlink\" title=\"📁 项目结构示例\"></a>📁 项目结构示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json        # 根目录，定义 workspace</span><br><span class=\"line\">├── pnpm-workspace.yaml</span><br><span class=\"line\">├── packages/</span><br><span class=\"line\">│   ├── component-lib/  # 组件库</span><br><span class=\"line\">│   └── demo-app/       # 测试项目</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔧-配置步骤\"><a href=\"#🔧-配置步骤\" class=\"headerlink\" title=\"🔧 配置步骤\"></a>🔧 配置步骤</h3><h4 id=\"1-根目录-package-json\"><a href=\"#1-根目录-package-json\" class=\"headerlink\" title=\"1. 根目录 package.json\"></a>1. 根目录 <code>package.json</code></h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;workspaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;packages/*&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-根目录-pnpm-workspace-yaml\"><a href=\"#2-根目录-pnpm-workspace-yaml\" class=\"headerlink\" title=\"2. 根目录 pnpm-workspace.yaml\"></a>2. 根目录 <code>pnpm-workspace.yaml</code></h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">packages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">&#x27;packages/*&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-在-demo-app-package-json-中添加依赖\"><a href=\"#3-在-demo-app-package-json-中添加依赖\" class=\"headerlink\" title=\"3. 在 demo-app/package.json 中添加依赖\"></a>3. 在 <code>demo-app/package.json</code> 中添加依赖</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;component-lib&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-安装依赖\"><a href=\"#4-安装依赖\" class=\"headerlink\" title=\"4. 安装依赖\"></a>4. 安装依赖</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> my-monorepo</span><br><span class=\"line\">pnpm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>pnpm</code> 会自动识别 workspace 内的包，并创建软链接。</p>\n</blockquote>\n<hr>\n<h3 id=\"✅-优点-2\"><a href=\"#✅-优点-2\" class=\"headerlink\" title=\"✅ 优点\"></a>✅ 优点</h3><ul>\n<li><strong>完全自动化</strong>：安装、链接、更新都由 <code>pnpm</code> 管理。</li>\n<li><strong>支持多包管理</strong>：适合未来扩展更多组件或工具。</li>\n<li><strong>性能好</strong>：<code>pnpm</code> 使用硬链接 + 内容寻址，节省磁盘空间。</li>\n<li><strong>生态完善</strong>：可与 Turborepo、Nx 等工具集成，实现任务调度（如 <code>build</code>、<code>test</code>）。</li>\n</ul>\n<h3 id=\"❌-缺点-2\"><a href=\"#❌-缺点-2\" class=\"headerlink\" title=\"❌ 缺点\"></a>❌ 缺点</h3><ul>\n<li>需要切换到 <code>pnpm</code> 包管理器（如果你原来用 <code>npm</code> 或 <code>yarn</code>）。</li>\n<li>初期配置稍复杂。</li>\n<li>团队协作需要统一使用 <code>pnpm</code>。</li>\n</ul>\n<hr>\n<h3 id=\"🎯-适用场景-1\"><a href=\"#🎯-适用场景-1\" class=\"headerlink\" title=\"🎯 适用场景\"></a>🎯 适用场景</h3><ul>\n<li>你计划长期维护组件库，甚至发展为 UI 库、设计系统。</li>\n<li>你有多个相关项目需要联动开发。</li>\n<li>你追求最佳开发体验和工程化规范。</li>\n</ul>\n<hr>\n<h2 id=\"🏁-建议\"><a href=\"#🏁-建议\" class=\"headerlink\" title=\"🏁 建议\"></a>🏁 建议</h2><ul>\n<li><strong>临时测试 &#x2F; 快速验证</strong> → 用 <code>npm link</code></li>\n<li><strong>遇到 link 问题 &#x2F; 想更真实模拟 install</strong> → 用 <code>yalc</code></li>\n<li><strong>长期开发 &#x2F; 团队项目 &#x2F; 构建组件体系</strong> → 用 <code>pnpm workspace</code></li>\n</ul>\n<hr>\n"},{"title":"npm workspace monorepo 技术栈","_content":"\n\nnpm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 **monorepo**（单体仓库）。\n\n简单来说，npm workspace 允许你在**一个根项目**中管理**多个相互关联的子项目（包）**，并让它们共享依赖、简化版本管理和跨包依赖。\n\n\n\n### 一、核心概念\n\n1.  **Monorepo (单体仓库)**：\n    *   一个代码仓库中包含多个独立的包（packages）。\n    *   例如：一个项目包含前端应用 (`packages/frontend`)、后端服务 (`packages/backend`)、共享工具库 (`packages/utils`)。\n\n2.  **Workspace**：\n    *   指 monorepo 中的一个子包。\n    *   每个 workspace 都是一个独立的 npm 包，拥有自己的 `package.json` 文件。\n\n3.  **Root Project (根项目)**：\n    *   包含所有 workspace 的顶层目录。\n    *   它的 `package.json` 文件通过 `workspaces` 字段来声明和配置所有子 workspace。\n\n---\n\n### 二、 npm Workspace \n\n#### 1. 📚 目录结构示例\n\n```bash\nmy-monorepo/\n├── package.json          # 根项目的 package.json\n├── packages/\n│   ├── frontend/\n│   │   └── package.json  # frontend workspace\n│   ├── backend/\n│   │   └── package.json  # backend workspace\n│   └── utils/\n│       └── package.json  # utils workspace (shared library)\n└── node_modules/         # 所有依赖集中安装在这里（由根项目管理）\n```\n#### 2. 📚 npm Workspace `workspaces`字段 \n> **位置**：根目录的 `package.json` 文件中。\n> **作用**：声明哪些目录是需要被统一管理的“工作区包”。\n>\n> ```json\n> {\n>   \"private\": true, // 必须！防止根项目被意外发布\n>   \"workspaces\": [\n>     \"packages/*\",           // 通配符：packages 下所有子目录\n>     \"tools/cli\",            // 具体路径\n>     \"examples/demo-app\"     // 可以是深层嵌套路径\n>   ]\n> }\n> ```\n*   **核心条件**：一个目录要成为 workspace 包，必须同时满足：\n    1.  其路径被 `workspaces` 数组中的某个条目**匹配到**。\n    2.  该目录下**存在 `package.json` 文件**。\n*   **嵌套路径处理**：\n    *   `a/sub` 是 `a` 的子目录，**物理上嵌套**。\n    *   但如果在 `workspaces` 中**同时注册了 `\"a\"` 和 `\"a/sub\"`**，那么它们在 workspace 系统中是**两个独立且平级的包**。\n    *   **注册即平等**：被根 `workspaces` 直接列出的路径，都视为顶级管理单元。\n* **最佳实践 (Best Practices)**\n    *   **根项目设为 `private: true`**。\n    *   **避免在 workspace 包内部再用 `workspaces` 管理子包**（易冲突）。\n    *   **优先使用平铺结构** (`packages/core`, `packages/ui`) 或**明确列出路径**。\n    *   **利用 `exports` 字段**进行精细导出，而非创建过多小包。\n    *   **合理使用 `workspace:*`** 简化本地包依赖。\n\n* **一句话总结**\n  > **`workspaces` 字段是“注册表”，将指定路径下的 `package.json` 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。**\n#### 3. 📚 npm Workspace 统一依赖管理 \n1. **核心目标**\n  > **实现多包项目中依赖的高效共享、去重和版本统一，避免 `node_modules` 膨胀和版本冲突。**\n\n2. **核心机制：依赖提升 (Dependency Hoisting)**\n*   **定义**：将所有 workspace 包的**公共外部依赖**，集中安装到**根目录的 `node_modules`** 中。\n*   **触发**：在根目录或任何 workspace 包内运行 `npm install`。\n*   **过程**：\n    1.  npm 扫描所有 `workspaces` 包的 `package.json`。\n    2.  收集所有 `dependencies` 和 `devDependencies`。\n    3.  进行版本解析，选择兼容的版本。\n    4.  将选中的外部包（如 `react`, `lodash`）**只安装一份**到 `根/node_modules`。\n\n3. **实现方式：符号链接 (Symbolic Links / Symlinks)**\n*   **位置**：在**每个 workspace 包的 `node_modules` 子目录内**。\n*   **作用**：为每个包“模拟”出它所需要的依赖。\n*   **方向**：\n    *   **源**：`packages/your-pkg/node_modules/lodash`\n    *   **目标**：`../../../node_modules/lodash` (指向根目录的真实依赖)\n*   **关键**：链接是由 **npm 自动创建**的，对开发者透明。\n\n4. **文件系统结构示例**\n```bash\nmy-monorepo/\n├── package.json\n├── package-lock.json\n├── node_modules/                     # 🎯 依赖的“中央仓库”\n│   ├── lodash/                       # ✅ 真实的 lodash 包\n│   └── react/                        # ✅ 真实的 react 包\n└── packages/\n    ├── core/\n    │   ├── package.json\n    │   └── node_modules/\n    │       └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n    └── ui/\n        ├── package.json\n        └── node_modules/\n            ├── react -> ../../../node_modules/react    # 🔗 符号链接\n            └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n```\n\n5. **工作流程 (Node.js 模块解析)**\n当 `packages/ui` 执行 `require('react')`：\n1.  从 `packages/ui` 开始查找 `node_modules/react`。\n2.  找到 `packages/ui/node_modules/react` —— 这是一个**符号链接**。\n3.  系统跟随链接，定位到 `根/node_modules/react`。\n4.  加载并执行根目录中的真实 `react` 代码。\n\n6. **关键优势**\n| 优势 | 说明 |\n| :--- | :--- |\n| **去重** | 相同依赖只安装一份，节省磁盘空间。 |\n| **高效** | 安装速度更快，`node_modules` 体积显著减小。 |\n| **版本统一** | npm 尽量使用单一版本，减少“依赖地狱”。 |\n| **开发友好** | 包间依赖通过链接直接引用源码，修改即时生效。 |\n\n7. **在子目录安装依赖会发生什么？**\n*   **绝大多数情况** (`npm install lodash`)：\n    *   依赖被**提升到根 `node_modules`**。\n    *   子目录的 `node_modules` 中创建**指向根的符号链接**。\n*   **特殊情况（版本冲突）**：\n    *   如果版本与其他包不兼容，npm **可能**会将该版本**本地安装**到子目录的 `node_modules`（真实代码，非链接）。\n    *   这是 npm 为了解决冲突的“降级”方案，应尽量避免。\n\n8. **一句话总结**\n  > **npm Workspace 通过“依赖提升”将所有外部依赖集中到根 `node_modules`，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。**\n\n---\n#### 4. 📚 npm Workspace 统一脚本执行 \n\n1. **核心目标**\n> **实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。**\n\n---\n\n2. **三大命令模式**\n\n| 模式 | 命令语法 | 作用范围 | 何时使用 |\n| :--- | :--- | :--- | :--- |\n| **局部执行** | `npm run <script>` | **仅当前目录** | 在单个包内进行开发、调试。 |\n| **批量执行** | `npm run <script> --workspaces` | **所有**注册的 workspace 包 | 构建、测试、检查整个项目。 |\n| **精准执行** | `npm run <script> --workspace=<name>` | **指定的单个** workspace 包 | 只运行某个特定包的脚本。 |\n\n---\n\n3. **命令详解**\n\n*   **`npm run <script>` (无参数)**\n    *   **作用域**：严格限定在**当前所在目录**的 `package.json`。\n    *   **行为**：查找并执行当前目录 `package.json` 中 `scripts` 字段定义的 `<script>`。\n    *   **示例**：\n        ```bash\n        # 在 packages/ui 目录下\n        npm run dev  # 只运行 ui 包的 dev 脚本\n        ```\n    *   **关键**：这是**默认行为**，不涉及 workspace 管理。\n\n*   **`npm run <script> --workspaces` (复数)**\n    *   **作用域**：**所有**在根 `package.json` 的 `workspaces` 字段中声明的包。\n    *   **行为**：npm 会**依次**进入每个 workspace 包，并运行其 `package.json` 中对应的 `<script>`。\n    *   **并行执行**：添加 `--parallel` 可并行运行，速度更快：\n        ```bash\n        npm run test --workspaces --parallel\n        ```\n    *   **示例**：\n        ```bash\n        npm run build --workspaces  # 构建所有包\n        npm run lint --workspaces   # 检查所有包代码\n        ```\n\n*   **`npm run <script> --workspace=<name>` (单数)**\n    *   **作用域**：**仅** `<name>` 指定的**单个** workspace 包。\n    *   **`<name>` 是什么？**\n        *   可以是包的**相对路径**（相对于根项目）：`packages/ui`, `tools/cli`。\n        *   可以是包的**名称**（`package.json` 中的 `name` 字段）：`@myorg/core`, `my-ui-lib`。\n    *   **路径基准**：`<name>` 是**相对于根项目目录**解析的。\n    *   **示例**：\n        ```bash\n        npm run build --workspace=packages/ui\n        npm run dev --workspace=@myorg/frontend\n        ```\n\n---\n\n4. **运行位置：灵活但有约定**\n\n*   **技术上**：你可以在**项目中的任何目录**运行 `--workspaces` 或 `--workspace=<name>` 命令。\n    *   npm 会自动**向上查找**，找到包含 `workspaces` 的根 `package.json`。\n*   **实践上**：**强烈建议在根目录运行**这些命令。\n    *   **原因**：\n        1.  **意图清晰**：明确表示“我要管理整个项目”。\n        2.  **避免混淆**：防止误以为命令只与当前包有关。\n        3.  **符合脚本**：根 `package.json` 中的聚合脚本（如 `\"build\": \"npm run build --workspaces\"`）必须在根目录运行。\n        4.  **团队一致**：建立统一的操作规范。\n\n---\n\n5. **最佳实践**\n\n1.  **在根 `package.json` 中定义聚合脚本**：\n    ```json\n    {\n      \"scripts\": {\n        \"build\": \"npm run build --workspaces\",\n        \"test\": \"npm run test --workspaces --parallel\",\n        \"lint\": \"npm run lint --workspaces\",\n        \"dev:ui\": \"npm run dev --workspace=packages/ui\",\n        \"dev:api\": \"npm run dev --workspace=packages/api\"\n      }\n    }\n    ```\n2.  **始终在根目录运行聚合命令**：\n    ```bash\n    npm run build  # 调用根脚本\n    npm run test\n    ```\n3.  **在包内进行开发时使用局部命令**：\n    ```bash\n    cd packages/ui\n    npm run dev  # 只启动 UI 开发服务器\n    ```\n\n---\n6. **一句话总结**\n> **`npm run` 默认只作用于当前包；添加 `--workspaces` 可批量操作所有包，添加 `--workspace=<name>` 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。**\n\n---\n#### 5. 📚 npm Workspace 统一的依赖解析与链接\n#### 📚 npm Workspace 核心机制：统一的依赖解析与链接\n\n1. **核心目标**\n> **实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (`import ... from '@scope/pkg'`) 引用本地开发中的其他包，无需配置复杂路径别名。**\n\n---\n\n2. **底层机制：符号链接 (Symlink) + Node.js 模块解析**\n\n这个“魔法”由两部分协同完成：\n\n*   **第一步：npm 创建符号链接 (Symlink)**\n    *   **时机**：运行 `npm install`（通常在根目录）。\n    *   **操作**：\n        1.  npm 扫描所有包的 `dependencies`。\n        2.  发现 `packages/ui` 依赖 `@myorg/core`。\n        3.  识别到 `@myorg/core` 是一个 workspace 包（在 `workspaces` 数组中）。\n        4.  **在 `packages/ui/node_modules/@myorg/core` 创建一个符号链接 (软连接)**。\n        5.  **链接的目标**：`../../core`（即 `packages/core` 的源码目录）。\n    *   **结果**：`ui` 包的 `node_modules` 中有了一个指向 `core` 包源码的“快捷方式”。\n\n*   **第二步：Node.js 解析模块**\n    *   **时机**：运行代码（`npm run dev`, `node app.js`），执行到 `import ... from '@myorg/core'`。\n    *   **过程**（遵循 Node.js 标准）：\n        1.  从当前文件目录开始，向上查找 `node_modules`。\n        2.  在 `packages/ui/node_modules` 中找到 `@myorg/core`。\n        3.  发现它是一个**符号链接**。\n        4.  **跟随链接**，跳转到 `packages/core` 目录。\n        5.  读取 `packages/core/package.json`，找到 `main`, `module`, `exports` 等字段。\n        6.  加载并执行字段指向的文件（如 `dist/index.js`）。\n    *   **结果**：成功加载 `core` 包的代码，仿佛它就是一个安装好的 npm 包。\n\n---\n\n3. **关键特性与优势**\n\n| 特性 | 说明 |\n| :--- | :--- |\n| **开发体验统一** | 无论引用外部包 (`react`) 还是内部包 (`@myorg/core`)，代码写法完全一致：`import xxx from 'package-name'`。 |\n| **即时生效** | `core` 包更新并**重新构建**后，`ui` 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。 |\n| **解耦** | `ui` 包不关心 `core` 包的物理位置，只关心其包名和 API。 |\n| **可发布性** | |\n| **零配置** | 无需在 `tsconfig.json` 中配置 `paths` 别名。 |\n\n---\n\n4. **操作流程（依赖建立）**\n\n1.  **注册包**：在根 `package.json` 的 `workspaces` 数组中定义包路径（如 `\"packages/*\"`）。\n2.  **声明依赖**：在 `packages/ui/package.json` 的 `dependencies` 中添加 `\"@myorg/core\": \"1.0.0\"`。\n    *   **推荐命令**：`npm install @myorg/core --workspace=packages/ui`\n3.  **安装与链接**：在根目录运行 `npm install`，创建符号链接。\n\n    | 场景 | 是否需要 `--workspace` | 说明 |\n    | :--- | :--- | :--- |\n    | **在 workspace 包目录内运行** | ❌ **通常不需要** | npm 能自动推断上下文。 |\n    | **在根目录运行** | ✅ **强烈建议使用** | 避免歧义，确保命令精确作用于目标包。 |\n    | **添加新的 workspace 依赖** | ✅ **推荐使用** | 最清晰、最安全的方式。 |\n\n4.  **构建被依赖包**：确保 `packages/core` 已通过 `npm run build --workspace=packages/core` 构建出 `dist/`。（只要引用到代码就行）\n5.  **使用**：在 `ui` 包代码中 `import ... from '@myorg/core'`。\n\n---\n\n5. **常见误区澄清**\n\n*   **误区**：`\"dependencies\": { \"@myorg/core\": \"workspace:*\" }`\n    *   **正解**：❌ **npm 不支持**。这是 Yarn/pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。\n*   **误区**：每次 `core` 包更新都要改 `ui` 包的版本号。\n    *   **正解**：❌ **不需要**。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。\n*   **误区**：npm 会为 workspace 包“打包”或“下载”。\n    *   **正解**：❌ **不会**。开发时是直接链接到本地文件，无打包下载过程。\n\n---\n\n6. **一句话总结**\n\n> **npm workspace 通过在依赖包的 `node_modules` 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，`import` 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。**\n### 三、主要优势\n\n1.  **依赖集中管理与优化**：\n    *   所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 `node_modules` 统一管理。\n    *   npm 会进行依赖提升（hoist），避免重复安装，减少 `node_modules` 体积。\n    *   不同 workspace 可以共享相同的依赖版本。\n\n2.  **简化跨包依赖**：\n    *   假设 `frontend` 需要使用 `utils` 包。\n    *   在 `packages/frontend/package.json` 中，你可以直接这样写：\n        ```json\n        {\n          \"dependencies\": {\n            \"utils\": \"1.0.0\"  // 假设 utils 的 version 是 1.0.0\n            // 或者使用 \"workspace:*\" 来引用最新的本地版本\n          }\n        }\n        ```\n    *   npm 会自动将 `packages/utils` 链接到 `frontend` 的依赖中，**无需发布到 npm registry**。这极大地方便了本地开发和测试。\n\n3.  **批量操作**：\n    *   使用 `--workspaces` 或 `--workspace=<name>` 标志可以对所有或特定 workspace 执行命令。\n    *   **例子**：\n        *   `npm install`：安装所有 workspace 的依赖（包括它们之间的依赖）。\n        *   `npm run build --workspaces`：在所有 workspace 中运行 `build` 脚本。\n        *   `npm run test --workspace=packages/frontend`：只在 `frontend` workspace 中运行 `test` 脚本。\n        *   `npm exec --workspace=packages/backend vite`：在 `backend` 中执行 `vite` 命令。\n\n4.  **版本同步与发布**（需要额外工具）：\n    *   虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 `lerna` 或 `nx` 那样），但它为这些工具提供了基础。你可以结合 `npm version` 和脚本管理多个包的版本。\n\n---\n### 四、常用命令\n\n*   `npm install`：在根目录运行，会安装所有 workspace 的依赖。\n*   `npm run <script> --workspaces`：在所有 workspace 中运行指定脚本。\n*   `npm run <script> --workspace=<package-name>`：在指定 workspace 中运行脚本。\n*   `npm exec --workspace=<package-name> <command>`：在指定 workspace 中执行命令。\n*   `npm ls --workspaces`：列出所有 workspace。\n*   `npm publish --workspace=<package-name>`：发布指定的 workspace 包到 npm registry。\n\n---\n### 五、注意事项\n\n1.  **npm 版本要求**：必须使用 **npm 7 或更高版本**。\n2.  **`private: true`**：根项目通常设置为 `private: true`，防止意外发布。\n3.  **依赖解析**：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。\n4.  **与 `file:` 依赖的区别**：过去常用 `file:../utils` 来引用本地包，但这种方式在发布时会有问题（`file:` 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。\n5.  **不是唯一选择**：还有其他优秀的 monorepo 工具，如 `pnpm`（其 workspace 功能非常强大且高效）、`yarn`（with Plug'n'Play）、`lerna`、`nx` 等。选择哪个取决于你的具体需求和偏好。\n\n---\n\n### 总结\n\nnpm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。\n\n> npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题 \n看起来您可能想了解的是 npm 的 **workspace**（工作区）功能，而不是“workplace”。npm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 **monorepo**（单体仓库）。\n\n简单来说，npm workspace 允许你在**一个根项目**中管理**多个相互关联的子项目（包）**，并让它们共享依赖、简化版本管理和跨包依赖。\n\n---\n\n### 一、核心概念\n\n1.  **Monorepo (单体仓库)**：\n    *   一个代码仓库中包含多个独立的包（packages）。\n    *   例如：一个项目包含前端应用 (`packages/frontend`)、后端服务 (`packages/backend`)、共享工具库 (`packages/utils`)。\n\n2.  **Workspace**：\n    *   指 monorepo 中的一个子包。\n    *   每个 workspace 都是一个独立的 npm 包，拥有自己的 `package.json` 文件。\n\n3.  **Root Project (根项目)**：\n    *   包含所有 workspace 的顶层目录。\n    *   它的 `package.json` 文件通过 `workspaces` 字段来声明和配置所有子 workspace。\n\n---\n\n### 二、如何配置 npm Workspace\n\n#### 1. 📚 目录结构示例\n\n```bash\nmy-monorepo/\n├── package.json          # 根项目的 package.json\n├── packages/\n│   ├── frontend/\n│   │   └── package.json  # frontend workspace\n│   ├── backend/\n│   │   └── package.json  # backend workspace\n│   └── utils/\n│       └── package.json  # utils workspace (shared library)\n└── node_modules/         # 所有依赖集中安装在这里（由根项目管理）\n```\n#### 2. 📚 npm Workspace `workspaces`字段 \n> **位置**：根目录的 `package.json` 文件中。\n> **作用**：声明哪些目录是需要被统一管理的“工作区包”。\n>\n> ```json\n> {\n>   \"private\": true, // 必须！防止根项目被意外发布\n>   \"workspaces\": [\n>     \"packages/*\",           // 通配符：packages 下所有子目录\n>     \"tools/cli\",            // 具体路径\n>     \"examples/demo-app\"     // 可以是深层嵌套路径\n>   ]\n> }\n> ```\n*   **核心条件**：一个目录要成为 workspace 包，必须同时满足：\n    1.  其路径被 `workspaces` 数组中的某个条目**匹配到**。\n    2.  该目录下**存在 `package.json` 文件**。\n*   **嵌套路径处理**：\n    *   `a/sub` 是 `a` 的子目录，**物理上嵌套**。\n    *   但如果在 `workspaces` 中**同时注册了 `\"a\"` 和 `\"a/sub\"`**，那么它们在 workspace 系统中是**两个独立且平级的包**。\n    *   **注册即平等**：被根 `workspaces` 直接列出的路径，都视为顶级管理单元。\n* **最佳实践 (Best Practices)**\n    *   **根项目设为 `private: true`**。\n    *   **避免在 workspace 包内部再用 `workspaces` 管理子包**（易冲突）。\n    *   **优先使用平铺结构** (`packages/core`, `packages/ui`) 或**明确列出路径**。\n    *   **利用 `exports` 字段**进行精细导出，而非创建过多小包。\n    *   **合理使用 `workspace:*`** 简化本地包依赖。\n\n* **一句话总结**\n  > **`workspaces` 字段是“注册表”，将指定路径下的 `package.json` 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。**\n#### 3. 📚 npm Workspace 统一依赖管理 \n1. **核心目标**\n  > **实现多包项目中依赖的高效共享、去重和版本统一，避免 `node_modules` 膨胀和版本冲突。**\n\n2. **核心机制：依赖提升 (Dependency Hoisting)**\n*   **定义**：将所有 workspace 包的**公共外部依赖**，集中安装到**根目录的 `node_modules`** 中。\n*   **触发**：在根目录或任何 workspace 包内运行 `npm install`。\n*   **过程**：\n    1.  npm 扫描所有 `workspaces` 包的 `package.json`。\n    2.  收集所有 `dependencies` 和 `devDependencies`。\n    3.  进行版本解析，选择兼容的版本。\n    4.  将选中的外部包（如 `react`, `lodash`）**只安装一份**到 `根/node_modules`。\n\n3. **实现方式：符号链接 (Symbolic Links / Symlinks)**\n*   **位置**：在**每个 workspace 包的 `node_modules` 子目录内**。\n*   **作用**：为每个包“模拟”出它所需要的依赖。\n*   **方向**：\n    *   **源**：`packages/your-pkg/node_modules/lodash`\n    *   **目标**：`../../../node_modules/lodash` (指向根目录的真实依赖)\n*   **关键**：链接是由 **npm 自动创建**的，对开发者透明。\n\n4. **文件系统结构示例**\n```bash\nmy-monorepo/\n├── package.json\n├── package-lock.json\n├── node_modules/                     # 🎯 依赖的“中央仓库”\n│   ├── lodash/                       # ✅ 真实的 lodash 包\n│   └── react/                        # ✅ 真实的 react 包\n└── packages/\n    ├── core/\n    │   ├── package.json\n    │   └── node_modules/\n    │       └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n    └── ui/\n        ├── package.json\n        └── node_modules/\n            ├── react -> ../../../node_modules/react    # 🔗 符号链接\n            └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n```\n\n5. **工作流程 (Node.js 模块解析)**\n当 `packages/ui` 执行 `require('react')`：\n1.  从 `packages/ui` 开始查找 `node_modules/react`。\n2.  找到 `packages/ui/node_modules/react` —— 这是一个**符号链接**。\n3.  系统跟随链接，定位到 `根/node_modules/react`。\n4.  加载并执行根目录中的真实 `react` 代码。\n\n6. **关键优势**\n| 优势 | 说明 |\n| :--- | :--- |\n| **去重** | 相同依赖只安装一份，节省磁盘空间。 |\n| **高效** | 安装速度更快，`node_modules` 体积显著减小。 |\n| **版本统一** | npm 尽量使用单一版本，减少“依赖地狱”。 |\n| **开发友好** | 包间依赖通过链接直接引用源码，修改即时生效。 |\n\n7. **在子目录安装依赖会发生什么？**\n*   **绝大多数情况** (`npm install lodash`)：\n    *   依赖被**提升到根 `node_modules`**。\n    *   子目录的 `node_modules` 中创建**指向根的符号链接**。\n*   **特殊情况（版本冲突）**：\n    *   如果版本与其他包不兼容，npm **可能**会将该版本**本地安装**到子目录的 `node_modules`（真实代码，非链接）。\n    *   这是 npm 为了解决冲突的“降级”方案，应尽量避免。\n\n8. **一句话总结**\n  > **npm Workspace 通过“依赖提升”将所有外部依赖集中到根 `node_modules`，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。**\n\n---\n#### 4. 📚 npm Workspace 统一脚本执行 \n\n1. **核心目标**\n> **实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。**\n\n---\n\n2. **三大命令模式**\n\n| 模式 | 命令语法 | 作用范围 | 何时使用 |\n| :--- | :--- | :--- | :--- |\n| **局部执行** | `npm run <script>` | **仅当前目录** | 在单个包内进行开发、调试。 |\n| **批量执行** | `npm run <script> --workspaces` | **所有**注册的 workspace 包 | 构建、测试、检查整个项目。 |\n| **精准执行** | `npm run <script> --workspace=<name>` | **指定的单个** workspace 包 | 只运行某个特定包的脚本。 |\n\n---\n\n3. **命令详解**\n\n*   **`npm run <script>` (无参数)**\n    *   **作用域**：严格限定在**当前所在目录**的 `package.json`。\n    *   **行为**：查找并执行当前目录 `package.json` 中 `scripts` 字段定义的 `<script>`。\n    *   **示例**：\n        ```bash\n        # 在 packages/ui 目录下\n        npm run dev  # 只运行 ui 包的 dev 脚本\n        ```\n    *   **关键**：这是**默认行为**，不涉及 workspace 管理。\n\n*   **`npm run <script> --workspaces` (复数)**\n    *   **作用域**：**所有**在根 `package.json` 的 `workspaces` 字段中声明的包。\n    *   **行为**：npm 会**依次**进入每个 workspace 包，并运行其 `package.json` 中对应的 `<script>`。\n    *   **并行执行**：添加 `--parallel` 可并行运行，速度更快：\n        ```bash\n        npm run test --workspaces --parallel\n        ```\n    *   **示例**：\n        ```bash\n        npm run build --workspaces  # 构建所有包\n        npm run lint --workspaces   # 检查所有包代码\n        ```\n\n*   **`npm run <script> --workspace=<name>` (单数)**\n    *   **作用域**：**仅** `<name>` 指定的**单个** workspace 包。\n    *   **`<name>` 是什么？**\n        *   可以是包的**相对路径**（相对于根项目）：`packages/ui`, `tools/cli`。\n        *   可以是包的**名称**（`package.json` 中的 `name` 字段）：`@myorg/core`, `my-ui-lib`。\n    *   **路径基准**：`<name>` 是**相对于根项目目录**解析的。\n    *   **示例**：\n        ```bash\n        npm run build --workspace=packages/ui\n        npm run dev --workspace=@myorg/frontend\n        ```\n\n---\n\n4. **运行位置：灵活但有约定**\n\n*   **技术上**：你可以在**项目中的任何目录**运行 `--workspaces` 或 `--workspace=<name>` 命令。\n    *   npm 会自动**向上查找**，找到包含 `workspaces` 的根 `package.json`。\n*   **实践上**：**强烈建议在根目录运行**这些命令。\n    *   **原因**：\n        1.  **意图清晰**：明确表示“我要管理整个项目”。\n        2.  **避免混淆**：防止误以为命令只与当前包有关。\n        3.  **符合脚本**：根 `package.json` 中的聚合脚本（如 `\"build\": \"npm run build --workspaces\"`）必须在根目录运行。\n        4.  **团队一致**：建立统一的操作规范。\n\n---\n\n5. **最佳实践**\n\n1.  **在根 `package.json` 中定义聚合脚本**：\n    ```json\n    {\n      \"scripts\": {\n        \"build\": \"npm run build --workspaces\",\n        \"test\": \"npm run test --workspaces --parallel\",\n        \"lint\": \"npm run lint --workspaces\",\n        \"dev:ui\": \"npm run dev --workspace=packages/ui\",\n        \"dev:api\": \"npm run dev --workspace=packages/api\"\n      }\n    }\n    ```\n2.  **始终在根目录运行聚合命令**：\n    ```bash\n    npm run build  # 调用根脚本\n    npm run test\n    ```\n3.  **在包内进行开发时使用局部命令**：\n    ```bash\n    cd packages/ui\n    npm run dev  # 只启动 UI 开发服务器\n    ```\n\n---\n6. **一句话总结**\n> **`npm run` 默认只作用于当前包；添加 `--workspaces` 可批量操作所有包，添加 `--workspace=<name>` 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。**\n\n---\n#### 5. 📚 npm Workspace 统一的依赖解析与链接\n#### 📚 npm Workspace 核心机制：统一的依赖解析与链接\n\n1. **核心目标**\n> **实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (`import ... from '@scope/pkg'`) 引用本地开发中的其他包，无需配置复杂路径别名。**\n\n---\n\n2. **底层机制：符号链接 (Symlink) + Node.js 模块解析**\n\n这个“魔法”由两部分协同完成：\n\n*   **第一步：npm 创建符号链接 (Symlink)**\n    *   **时机**：运行 `npm install`（通常在根目录）。\n    *   **操作**：\n        1.  npm 扫描所有包的 `dependencies`。\n        2.  发现 `packages/ui` 依赖 `@myorg/core`。\n        3.  识别到 `@myorg/core` 是一个 workspace 包（在 `workspaces` 数组中）。\n        4.  **在 `packages/ui/node_modules/@myorg/core` 创建一个符号链接 (软连接)**。\n        5.  **链接的目标**：`../../core`（即 `packages/core` 的源码目录）。\n    *   **结果**：`ui` 包的 `node_modules` 中有了一个指向 `core` 包源码的“快捷方式”。\n\n*   **第二步：Node.js 解析模块**\n    *   **时机**：运行代码（`npm run dev`, `node app.js`），执行到 `import ... from '@myorg/core'`。\n    *   **过程**（遵循 Node.js 标准）：\n        1.  从当前文件目录开始，向上查找 `node_modules`。\n        2.  在 `packages/ui/node_modules` 中找到 `@myorg/core`。\n        3.  发现它是一个**符号链接**。\n        4.  **跟随链接**，跳转到 `packages/core` 目录。\n        5.  读取 `packages/core/package.json`，找到 `main`, `module`, `exports` 等字段。\n        6.  加载并执行字段指向的文件（如 `dist/index.js`）。\n    *   **结果**：成功加载 `core` 包的代码，仿佛它就是一个安装好的 npm 包。\n\n---\n\n3. **关键特性与优势**\n\n| 特性 | 说明 |\n| :--- | :--- |\n| **开发体验统一** | 无论引用外部包 (`react`) 还是内部包 (`@myorg/core`)，代码写法完全一致：`import xxx from 'package-name'`。 |\n| **即时生效** | `core` 包更新并**重新构建**后，`ui` 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。 |\n| **解耦** | `ui` 包不关心 `core` 包的物理位置，只关心其包名和 API。 |\n| **可发布性** | |\n| **零配置** | 无需在 `tsconfig.json` 中配置 `paths` 别名。 |\n\n---\n\n4. **操作流程（依赖建立）**\n\n1.  **注册包**：在根 `package.json` 的 `workspaces` 数组中定义包路径（如 `\"packages/*\"`）。\n2.  **声明依赖**：在 `packages/ui/package.json` 的 `dependencies` 中添加 `\"@myorg/core\": \"1.0.0\"`。\n    *   **推荐命令**：`npm install @myorg/core --workspace=packages/ui`\n3.  **安装与链接**：在根目录运行 `npm install`，创建符号链接。\n\n    | 场景 | 是否需要 `--workspace` | 说明 |\n    | :--- | :--- | :--- |\n    | **在 workspace 包目录内运行** | ❌ **通常不需要** | npm 能自动推断上下文。 |\n    | **在根目录运行** | ✅ **强烈建议使用** | 避免歧义，确保命令精确作用于目标包。 |\n    | **添加新的 workspace 依赖** | ✅ **推荐使用** | 最清晰、最安全的方式。 |\n\n4.  **构建被依赖包**：确保 `packages/core` 已通过 `npm run build --workspace=packages/core` 构建出 `dist/`。（只要引用到代码就行）\n5.  **使用**：在 `ui` 包代码中 `import ... from '@myorg/core'`。\n\n---\n\n5. **常见误区澄清**\n\n*   **误区**：`\"dependencies\": { \"@myorg/core\": \"workspace:*\" }`\n    *   **正解**：❌ **npm 不支持**。这是 Yarn/pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。\n*   **误区**：每次 `core` 包更新都要改 `ui` 包的版本号。\n    *   **正解**：❌ **不需要**。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。\n*   **误区**：npm 会为 workspace 包“打包”或“下载”。\n    *   **正解**：❌ **不会**。开发时是直接链接到本地文件，无打包下载过程。\n\n---\n\n6. **一句话总结**\n\n> **npm workspace 通过在依赖包的 `node_modules` 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，`import` 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。**\n### 三、主要优势\n\n1.  **依赖集中管理与优化**：\n    *   所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 `node_modules` 统一管理。\n    *   npm 会进行依赖提升（hoist），避免重复安装，减少 `node_modules` 体积。\n    *   不同 workspace 可以共享相同的依赖版本。\n\n2.  **简化跨包依赖**：\n    *   假设 `frontend` 需要使用 `utils` 包。\n    *   在 `packages/frontend/package.json` 中，你可以直接这样写：\n        ```json\n        {\n          \"dependencies\": {\n            \"utils\": \"1.0.0\"  // 假设 utils 的 version 是 1.0.0\n            // 或者使用 \"workspace:*\" 来引用最新的本地版本\n          }\n        }\n        ```\n    *   npm 会自动将 `packages/utils` 链接到 `frontend` 的依赖中，**无需发布到 npm registry**。这极大地方便了本地开发和测试。\n\n3.  **批量操作**：\n    *   使用 `--workspaces` 或 `--workspace=<name>` 标志可以对所有或特定 workspace 执行命令。\n    *   **例子**：\n        *   `npm install`：安装所有 workspace 的依赖（包括它们之间的依赖）。\n        *   `npm run build --workspaces`：在所有 workspace 中运行 `build` 脚本。\n        *   `npm run test --workspace=packages/frontend`：只在 `frontend` workspace 中运行 `test` 脚本。\n        *   `npm exec --workspace=packages/backend vite`：在 `backend` 中执行 `vite` 命令。\n\n4.  **版本同步与发布**（需要额外工具）：\n    *   虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 `lerna` 或 `nx` 那样），但它为这些工具提供了基础。你可以结合 `npm version` 和脚本管理多个包的版本。\n\n---\n### 四、常用命令\n\n*   `npm install`：在根目录运行，会安装所有 workspace 的依赖。\n*   `npm run <script> --workspaces`：在所有 workspace 中运行指定脚本。\n*   `npm run <script> --workspace=<package-name>`：在指定 workspace 中运行脚本。\n*   `npm exec --workspace=<package-name> <command>`：在指定 workspace 中执行命令。\n*   `npm ls --workspaces`：列出所有 workspace。\n*   `npm publish --workspace=<package-name>`：发布指定的 workspace 包到 npm registry。\n\n---\n### 五、注意事项\n\n1.  **npm 版本要求**：必须使用 **npm 7 或更高版本**。\n2.  **`private: true`**：根项目通常设置为 `private: true`，防止意外发布。\n3.  **依赖解析**：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。\n4.  **与 `file:` 依赖的区别**：过去常用 `file:../utils` 来引用本地包，但这种方式在发布时会有问题（`file:` 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。\n5.  **不是唯一选择**：还有其他优秀的 monorepo 工具，如 `pnpm`（其 workspace 功能非常强大且高效）、`yarn`（with Plug'n'Play）、`lerna`、`nx` 等。选择哪个取决于你的具体需求和偏好。\n\n---\n\n### 总结\n\nnpm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。\n\n> npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题 ","source":"_posts/npm workspace.md","raw":"---\ntitle: npm workspace monorepo 技术栈\n---\n\n\nnpm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 **monorepo**（单体仓库）。\n\n简单来说，npm workspace 允许你在**一个根项目**中管理**多个相互关联的子项目（包）**，并让它们共享依赖、简化版本管理和跨包依赖。\n\n\n\n### 一、核心概念\n\n1.  **Monorepo (单体仓库)**：\n    *   一个代码仓库中包含多个独立的包（packages）。\n    *   例如：一个项目包含前端应用 (`packages/frontend`)、后端服务 (`packages/backend`)、共享工具库 (`packages/utils`)。\n\n2.  **Workspace**：\n    *   指 monorepo 中的一个子包。\n    *   每个 workspace 都是一个独立的 npm 包，拥有自己的 `package.json` 文件。\n\n3.  **Root Project (根项目)**：\n    *   包含所有 workspace 的顶层目录。\n    *   它的 `package.json` 文件通过 `workspaces` 字段来声明和配置所有子 workspace。\n\n---\n\n### 二、 npm Workspace \n\n#### 1. 📚 目录结构示例\n\n```bash\nmy-monorepo/\n├── package.json          # 根项目的 package.json\n├── packages/\n│   ├── frontend/\n│   │   └── package.json  # frontend workspace\n│   ├── backend/\n│   │   └── package.json  # backend workspace\n│   └── utils/\n│       └── package.json  # utils workspace (shared library)\n└── node_modules/         # 所有依赖集中安装在这里（由根项目管理）\n```\n#### 2. 📚 npm Workspace `workspaces`字段 \n> **位置**：根目录的 `package.json` 文件中。\n> **作用**：声明哪些目录是需要被统一管理的“工作区包”。\n>\n> ```json\n> {\n>   \"private\": true, // 必须！防止根项目被意外发布\n>   \"workspaces\": [\n>     \"packages/*\",           // 通配符：packages 下所有子目录\n>     \"tools/cli\",            // 具体路径\n>     \"examples/demo-app\"     // 可以是深层嵌套路径\n>   ]\n> }\n> ```\n*   **核心条件**：一个目录要成为 workspace 包，必须同时满足：\n    1.  其路径被 `workspaces` 数组中的某个条目**匹配到**。\n    2.  该目录下**存在 `package.json` 文件**。\n*   **嵌套路径处理**：\n    *   `a/sub` 是 `a` 的子目录，**物理上嵌套**。\n    *   但如果在 `workspaces` 中**同时注册了 `\"a\"` 和 `\"a/sub\"`**，那么它们在 workspace 系统中是**两个独立且平级的包**。\n    *   **注册即平等**：被根 `workspaces` 直接列出的路径，都视为顶级管理单元。\n* **最佳实践 (Best Practices)**\n    *   **根项目设为 `private: true`**。\n    *   **避免在 workspace 包内部再用 `workspaces` 管理子包**（易冲突）。\n    *   **优先使用平铺结构** (`packages/core`, `packages/ui`) 或**明确列出路径**。\n    *   **利用 `exports` 字段**进行精细导出，而非创建过多小包。\n    *   **合理使用 `workspace:*`** 简化本地包依赖。\n\n* **一句话总结**\n  > **`workspaces` 字段是“注册表”，将指定路径下的 `package.json` 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。**\n#### 3. 📚 npm Workspace 统一依赖管理 \n1. **核心目标**\n  > **实现多包项目中依赖的高效共享、去重和版本统一，避免 `node_modules` 膨胀和版本冲突。**\n\n2. **核心机制：依赖提升 (Dependency Hoisting)**\n*   **定义**：将所有 workspace 包的**公共外部依赖**，集中安装到**根目录的 `node_modules`** 中。\n*   **触发**：在根目录或任何 workspace 包内运行 `npm install`。\n*   **过程**：\n    1.  npm 扫描所有 `workspaces` 包的 `package.json`。\n    2.  收集所有 `dependencies` 和 `devDependencies`。\n    3.  进行版本解析，选择兼容的版本。\n    4.  将选中的外部包（如 `react`, `lodash`）**只安装一份**到 `根/node_modules`。\n\n3. **实现方式：符号链接 (Symbolic Links / Symlinks)**\n*   **位置**：在**每个 workspace 包的 `node_modules` 子目录内**。\n*   **作用**：为每个包“模拟”出它所需要的依赖。\n*   **方向**：\n    *   **源**：`packages/your-pkg/node_modules/lodash`\n    *   **目标**：`../../../node_modules/lodash` (指向根目录的真实依赖)\n*   **关键**：链接是由 **npm 自动创建**的，对开发者透明。\n\n4. **文件系统结构示例**\n```bash\nmy-monorepo/\n├── package.json\n├── package-lock.json\n├── node_modules/                     # 🎯 依赖的“中央仓库”\n│   ├── lodash/                       # ✅ 真实的 lodash 包\n│   └── react/                        # ✅ 真实的 react 包\n└── packages/\n    ├── core/\n    │   ├── package.json\n    │   └── node_modules/\n    │       └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n    └── ui/\n        ├── package.json\n        └── node_modules/\n            ├── react -> ../../../node_modules/react    # 🔗 符号链接\n            └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n```\n\n5. **工作流程 (Node.js 模块解析)**\n当 `packages/ui` 执行 `require('react')`：\n1.  从 `packages/ui` 开始查找 `node_modules/react`。\n2.  找到 `packages/ui/node_modules/react` —— 这是一个**符号链接**。\n3.  系统跟随链接，定位到 `根/node_modules/react`。\n4.  加载并执行根目录中的真实 `react` 代码。\n\n6. **关键优势**\n| 优势 | 说明 |\n| :--- | :--- |\n| **去重** | 相同依赖只安装一份，节省磁盘空间。 |\n| **高效** | 安装速度更快，`node_modules` 体积显著减小。 |\n| **版本统一** | npm 尽量使用单一版本，减少“依赖地狱”。 |\n| **开发友好** | 包间依赖通过链接直接引用源码，修改即时生效。 |\n\n7. **在子目录安装依赖会发生什么？**\n*   **绝大多数情况** (`npm install lodash`)：\n    *   依赖被**提升到根 `node_modules`**。\n    *   子目录的 `node_modules` 中创建**指向根的符号链接**。\n*   **特殊情况（版本冲突）**：\n    *   如果版本与其他包不兼容，npm **可能**会将该版本**本地安装**到子目录的 `node_modules`（真实代码，非链接）。\n    *   这是 npm 为了解决冲突的“降级”方案，应尽量避免。\n\n8. **一句话总结**\n  > **npm Workspace 通过“依赖提升”将所有外部依赖集中到根 `node_modules`，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。**\n\n---\n#### 4. 📚 npm Workspace 统一脚本执行 \n\n1. **核心目标**\n> **实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。**\n\n---\n\n2. **三大命令模式**\n\n| 模式 | 命令语法 | 作用范围 | 何时使用 |\n| :--- | :--- | :--- | :--- |\n| **局部执行** | `npm run <script>` | **仅当前目录** | 在单个包内进行开发、调试。 |\n| **批量执行** | `npm run <script> --workspaces` | **所有**注册的 workspace 包 | 构建、测试、检查整个项目。 |\n| **精准执行** | `npm run <script> --workspace=<name>` | **指定的单个** workspace 包 | 只运行某个特定包的脚本。 |\n\n---\n\n3. **命令详解**\n\n*   **`npm run <script>` (无参数)**\n    *   **作用域**：严格限定在**当前所在目录**的 `package.json`。\n    *   **行为**：查找并执行当前目录 `package.json` 中 `scripts` 字段定义的 `<script>`。\n    *   **示例**：\n        ```bash\n        # 在 packages/ui 目录下\n        npm run dev  # 只运行 ui 包的 dev 脚本\n        ```\n    *   **关键**：这是**默认行为**，不涉及 workspace 管理。\n\n*   **`npm run <script> --workspaces` (复数)**\n    *   **作用域**：**所有**在根 `package.json` 的 `workspaces` 字段中声明的包。\n    *   **行为**：npm 会**依次**进入每个 workspace 包，并运行其 `package.json` 中对应的 `<script>`。\n    *   **并行执行**：添加 `--parallel` 可并行运行，速度更快：\n        ```bash\n        npm run test --workspaces --parallel\n        ```\n    *   **示例**：\n        ```bash\n        npm run build --workspaces  # 构建所有包\n        npm run lint --workspaces   # 检查所有包代码\n        ```\n\n*   **`npm run <script> --workspace=<name>` (单数)**\n    *   **作用域**：**仅** `<name>` 指定的**单个** workspace 包。\n    *   **`<name>` 是什么？**\n        *   可以是包的**相对路径**（相对于根项目）：`packages/ui`, `tools/cli`。\n        *   可以是包的**名称**（`package.json` 中的 `name` 字段）：`@myorg/core`, `my-ui-lib`。\n    *   **路径基准**：`<name>` 是**相对于根项目目录**解析的。\n    *   **示例**：\n        ```bash\n        npm run build --workspace=packages/ui\n        npm run dev --workspace=@myorg/frontend\n        ```\n\n---\n\n4. **运行位置：灵活但有约定**\n\n*   **技术上**：你可以在**项目中的任何目录**运行 `--workspaces` 或 `--workspace=<name>` 命令。\n    *   npm 会自动**向上查找**，找到包含 `workspaces` 的根 `package.json`。\n*   **实践上**：**强烈建议在根目录运行**这些命令。\n    *   **原因**：\n        1.  **意图清晰**：明确表示“我要管理整个项目”。\n        2.  **避免混淆**：防止误以为命令只与当前包有关。\n        3.  **符合脚本**：根 `package.json` 中的聚合脚本（如 `\"build\": \"npm run build --workspaces\"`）必须在根目录运行。\n        4.  **团队一致**：建立统一的操作规范。\n\n---\n\n5. **最佳实践**\n\n1.  **在根 `package.json` 中定义聚合脚本**：\n    ```json\n    {\n      \"scripts\": {\n        \"build\": \"npm run build --workspaces\",\n        \"test\": \"npm run test --workspaces --parallel\",\n        \"lint\": \"npm run lint --workspaces\",\n        \"dev:ui\": \"npm run dev --workspace=packages/ui\",\n        \"dev:api\": \"npm run dev --workspace=packages/api\"\n      }\n    }\n    ```\n2.  **始终在根目录运行聚合命令**：\n    ```bash\n    npm run build  # 调用根脚本\n    npm run test\n    ```\n3.  **在包内进行开发时使用局部命令**：\n    ```bash\n    cd packages/ui\n    npm run dev  # 只启动 UI 开发服务器\n    ```\n\n---\n6. **一句话总结**\n> **`npm run` 默认只作用于当前包；添加 `--workspaces` 可批量操作所有包，添加 `--workspace=<name>` 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。**\n\n---\n#### 5. 📚 npm Workspace 统一的依赖解析与链接\n#### 📚 npm Workspace 核心机制：统一的依赖解析与链接\n\n1. **核心目标**\n> **实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (`import ... from '@scope/pkg'`) 引用本地开发中的其他包，无需配置复杂路径别名。**\n\n---\n\n2. **底层机制：符号链接 (Symlink) + Node.js 模块解析**\n\n这个“魔法”由两部分协同完成：\n\n*   **第一步：npm 创建符号链接 (Symlink)**\n    *   **时机**：运行 `npm install`（通常在根目录）。\n    *   **操作**：\n        1.  npm 扫描所有包的 `dependencies`。\n        2.  发现 `packages/ui` 依赖 `@myorg/core`。\n        3.  识别到 `@myorg/core` 是一个 workspace 包（在 `workspaces` 数组中）。\n        4.  **在 `packages/ui/node_modules/@myorg/core` 创建一个符号链接 (软连接)**。\n        5.  **链接的目标**：`../../core`（即 `packages/core` 的源码目录）。\n    *   **结果**：`ui` 包的 `node_modules` 中有了一个指向 `core` 包源码的“快捷方式”。\n\n*   **第二步：Node.js 解析模块**\n    *   **时机**：运行代码（`npm run dev`, `node app.js`），执行到 `import ... from '@myorg/core'`。\n    *   **过程**（遵循 Node.js 标准）：\n        1.  从当前文件目录开始，向上查找 `node_modules`。\n        2.  在 `packages/ui/node_modules` 中找到 `@myorg/core`。\n        3.  发现它是一个**符号链接**。\n        4.  **跟随链接**，跳转到 `packages/core` 目录。\n        5.  读取 `packages/core/package.json`，找到 `main`, `module`, `exports` 等字段。\n        6.  加载并执行字段指向的文件（如 `dist/index.js`）。\n    *   **结果**：成功加载 `core` 包的代码，仿佛它就是一个安装好的 npm 包。\n\n---\n\n3. **关键特性与优势**\n\n| 特性 | 说明 |\n| :--- | :--- |\n| **开发体验统一** | 无论引用外部包 (`react`) 还是内部包 (`@myorg/core`)，代码写法完全一致：`import xxx from 'package-name'`。 |\n| **即时生效** | `core` 包更新并**重新构建**后，`ui` 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。 |\n| **解耦** | `ui` 包不关心 `core` 包的物理位置，只关心其包名和 API。 |\n| **可发布性** | |\n| **零配置** | 无需在 `tsconfig.json` 中配置 `paths` 别名。 |\n\n---\n\n4. **操作流程（依赖建立）**\n\n1.  **注册包**：在根 `package.json` 的 `workspaces` 数组中定义包路径（如 `\"packages/*\"`）。\n2.  **声明依赖**：在 `packages/ui/package.json` 的 `dependencies` 中添加 `\"@myorg/core\": \"1.0.0\"`。\n    *   **推荐命令**：`npm install @myorg/core --workspace=packages/ui`\n3.  **安装与链接**：在根目录运行 `npm install`，创建符号链接。\n\n    | 场景 | 是否需要 `--workspace` | 说明 |\n    | :--- | :--- | :--- |\n    | **在 workspace 包目录内运行** | ❌ **通常不需要** | npm 能自动推断上下文。 |\n    | **在根目录运行** | ✅ **强烈建议使用** | 避免歧义，确保命令精确作用于目标包。 |\n    | **添加新的 workspace 依赖** | ✅ **推荐使用** | 最清晰、最安全的方式。 |\n\n4.  **构建被依赖包**：确保 `packages/core` 已通过 `npm run build --workspace=packages/core` 构建出 `dist/`。（只要引用到代码就行）\n5.  **使用**：在 `ui` 包代码中 `import ... from '@myorg/core'`。\n\n---\n\n5. **常见误区澄清**\n\n*   **误区**：`\"dependencies\": { \"@myorg/core\": \"workspace:*\" }`\n    *   **正解**：❌ **npm 不支持**。这是 Yarn/pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。\n*   **误区**：每次 `core` 包更新都要改 `ui` 包的版本号。\n    *   **正解**：❌ **不需要**。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。\n*   **误区**：npm 会为 workspace 包“打包”或“下载”。\n    *   **正解**：❌ **不会**。开发时是直接链接到本地文件，无打包下载过程。\n\n---\n\n6. **一句话总结**\n\n> **npm workspace 通过在依赖包的 `node_modules` 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，`import` 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。**\n### 三、主要优势\n\n1.  **依赖集中管理与优化**：\n    *   所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 `node_modules` 统一管理。\n    *   npm 会进行依赖提升（hoist），避免重复安装，减少 `node_modules` 体积。\n    *   不同 workspace 可以共享相同的依赖版本。\n\n2.  **简化跨包依赖**：\n    *   假设 `frontend` 需要使用 `utils` 包。\n    *   在 `packages/frontend/package.json` 中，你可以直接这样写：\n        ```json\n        {\n          \"dependencies\": {\n            \"utils\": \"1.0.0\"  // 假设 utils 的 version 是 1.0.0\n            // 或者使用 \"workspace:*\" 来引用最新的本地版本\n          }\n        }\n        ```\n    *   npm 会自动将 `packages/utils` 链接到 `frontend` 的依赖中，**无需发布到 npm registry**。这极大地方便了本地开发和测试。\n\n3.  **批量操作**：\n    *   使用 `--workspaces` 或 `--workspace=<name>` 标志可以对所有或特定 workspace 执行命令。\n    *   **例子**：\n        *   `npm install`：安装所有 workspace 的依赖（包括它们之间的依赖）。\n        *   `npm run build --workspaces`：在所有 workspace 中运行 `build` 脚本。\n        *   `npm run test --workspace=packages/frontend`：只在 `frontend` workspace 中运行 `test` 脚本。\n        *   `npm exec --workspace=packages/backend vite`：在 `backend` 中执行 `vite` 命令。\n\n4.  **版本同步与发布**（需要额外工具）：\n    *   虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 `lerna` 或 `nx` 那样），但它为这些工具提供了基础。你可以结合 `npm version` 和脚本管理多个包的版本。\n\n---\n### 四、常用命令\n\n*   `npm install`：在根目录运行，会安装所有 workspace 的依赖。\n*   `npm run <script> --workspaces`：在所有 workspace 中运行指定脚本。\n*   `npm run <script> --workspace=<package-name>`：在指定 workspace 中运行脚本。\n*   `npm exec --workspace=<package-name> <command>`：在指定 workspace 中执行命令。\n*   `npm ls --workspaces`：列出所有 workspace。\n*   `npm publish --workspace=<package-name>`：发布指定的 workspace 包到 npm registry。\n\n---\n### 五、注意事项\n\n1.  **npm 版本要求**：必须使用 **npm 7 或更高版本**。\n2.  **`private: true`**：根项目通常设置为 `private: true`，防止意外发布。\n3.  **依赖解析**：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。\n4.  **与 `file:` 依赖的区别**：过去常用 `file:../utils` 来引用本地包，但这种方式在发布时会有问题（`file:` 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。\n5.  **不是唯一选择**：还有其他优秀的 monorepo 工具，如 `pnpm`（其 workspace 功能非常强大且高效）、`yarn`（with Plug'n'Play）、`lerna`、`nx` 等。选择哪个取决于你的具体需求和偏好。\n\n---\n\n### 总结\n\nnpm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。\n\n> npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题 \n看起来您可能想了解的是 npm 的 **workspace**（工作区）功能，而不是“workplace”。npm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 **monorepo**（单体仓库）。\n\n简单来说，npm workspace 允许你在**一个根项目**中管理**多个相互关联的子项目（包）**，并让它们共享依赖、简化版本管理和跨包依赖。\n\n---\n\n### 一、核心概念\n\n1.  **Monorepo (单体仓库)**：\n    *   一个代码仓库中包含多个独立的包（packages）。\n    *   例如：一个项目包含前端应用 (`packages/frontend`)、后端服务 (`packages/backend`)、共享工具库 (`packages/utils`)。\n\n2.  **Workspace**：\n    *   指 monorepo 中的一个子包。\n    *   每个 workspace 都是一个独立的 npm 包，拥有自己的 `package.json` 文件。\n\n3.  **Root Project (根项目)**：\n    *   包含所有 workspace 的顶层目录。\n    *   它的 `package.json` 文件通过 `workspaces` 字段来声明和配置所有子 workspace。\n\n---\n\n### 二、如何配置 npm Workspace\n\n#### 1. 📚 目录结构示例\n\n```bash\nmy-monorepo/\n├── package.json          # 根项目的 package.json\n├── packages/\n│   ├── frontend/\n│   │   └── package.json  # frontend workspace\n│   ├── backend/\n│   │   └── package.json  # backend workspace\n│   └── utils/\n│       └── package.json  # utils workspace (shared library)\n└── node_modules/         # 所有依赖集中安装在这里（由根项目管理）\n```\n#### 2. 📚 npm Workspace `workspaces`字段 \n> **位置**：根目录的 `package.json` 文件中。\n> **作用**：声明哪些目录是需要被统一管理的“工作区包”。\n>\n> ```json\n> {\n>   \"private\": true, // 必须！防止根项目被意外发布\n>   \"workspaces\": [\n>     \"packages/*\",           // 通配符：packages 下所有子目录\n>     \"tools/cli\",            // 具体路径\n>     \"examples/demo-app\"     // 可以是深层嵌套路径\n>   ]\n> }\n> ```\n*   **核心条件**：一个目录要成为 workspace 包，必须同时满足：\n    1.  其路径被 `workspaces` 数组中的某个条目**匹配到**。\n    2.  该目录下**存在 `package.json` 文件**。\n*   **嵌套路径处理**：\n    *   `a/sub` 是 `a` 的子目录，**物理上嵌套**。\n    *   但如果在 `workspaces` 中**同时注册了 `\"a\"` 和 `\"a/sub\"`**，那么它们在 workspace 系统中是**两个独立且平级的包**。\n    *   **注册即平等**：被根 `workspaces` 直接列出的路径，都视为顶级管理单元。\n* **最佳实践 (Best Practices)**\n    *   **根项目设为 `private: true`**。\n    *   **避免在 workspace 包内部再用 `workspaces` 管理子包**（易冲突）。\n    *   **优先使用平铺结构** (`packages/core`, `packages/ui`) 或**明确列出路径**。\n    *   **利用 `exports` 字段**进行精细导出，而非创建过多小包。\n    *   **合理使用 `workspace:*`** 简化本地包依赖。\n\n* **一句话总结**\n  > **`workspaces` 字段是“注册表”，将指定路径下的 `package.json` 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。**\n#### 3. 📚 npm Workspace 统一依赖管理 \n1. **核心目标**\n  > **实现多包项目中依赖的高效共享、去重和版本统一，避免 `node_modules` 膨胀和版本冲突。**\n\n2. **核心机制：依赖提升 (Dependency Hoisting)**\n*   **定义**：将所有 workspace 包的**公共外部依赖**，集中安装到**根目录的 `node_modules`** 中。\n*   **触发**：在根目录或任何 workspace 包内运行 `npm install`。\n*   **过程**：\n    1.  npm 扫描所有 `workspaces` 包的 `package.json`。\n    2.  收集所有 `dependencies` 和 `devDependencies`。\n    3.  进行版本解析，选择兼容的版本。\n    4.  将选中的外部包（如 `react`, `lodash`）**只安装一份**到 `根/node_modules`。\n\n3. **实现方式：符号链接 (Symbolic Links / Symlinks)**\n*   **位置**：在**每个 workspace 包的 `node_modules` 子目录内**。\n*   **作用**：为每个包“模拟”出它所需要的依赖。\n*   **方向**：\n    *   **源**：`packages/your-pkg/node_modules/lodash`\n    *   **目标**：`../../../node_modules/lodash` (指向根目录的真实依赖)\n*   **关键**：链接是由 **npm 自动创建**的，对开发者透明。\n\n4. **文件系统结构示例**\n```bash\nmy-monorepo/\n├── package.json\n├── package-lock.json\n├── node_modules/                     # 🎯 依赖的“中央仓库”\n│   ├── lodash/                       # ✅ 真实的 lodash 包\n│   └── react/                        # ✅ 真实的 react 包\n└── packages/\n    ├── core/\n    │   ├── package.json\n    │   └── node_modules/\n    │       └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n    └── ui/\n        ├── package.json\n        └── node_modules/\n            ├── react -> ../../../node_modules/react    # 🔗 符号链接\n            └── lodash -> ../../../node_modules/lodash  # 🔗 符号链接\n```\n\n5. **工作流程 (Node.js 模块解析)**\n当 `packages/ui` 执行 `require('react')`：\n1.  从 `packages/ui` 开始查找 `node_modules/react`。\n2.  找到 `packages/ui/node_modules/react` —— 这是一个**符号链接**。\n3.  系统跟随链接，定位到 `根/node_modules/react`。\n4.  加载并执行根目录中的真实 `react` 代码。\n\n6. **关键优势**\n| 优势 | 说明 |\n| :--- | :--- |\n| **去重** | 相同依赖只安装一份，节省磁盘空间。 |\n| **高效** | 安装速度更快，`node_modules` 体积显著减小。 |\n| **版本统一** | npm 尽量使用单一版本，减少“依赖地狱”。 |\n| **开发友好** | 包间依赖通过链接直接引用源码，修改即时生效。 |\n\n7. **在子目录安装依赖会发生什么？**\n*   **绝大多数情况** (`npm install lodash`)：\n    *   依赖被**提升到根 `node_modules`**。\n    *   子目录的 `node_modules` 中创建**指向根的符号链接**。\n*   **特殊情况（版本冲突）**：\n    *   如果版本与其他包不兼容，npm **可能**会将该版本**本地安装**到子目录的 `node_modules`（真实代码，非链接）。\n    *   这是 npm 为了解决冲突的“降级”方案，应尽量避免。\n\n8. **一句话总结**\n  > **npm Workspace 通过“依赖提升”将所有外部依赖集中到根 `node_modules`，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。**\n\n---\n#### 4. 📚 npm Workspace 统一脚本执行 \n\n1. **核心目标**\n> **实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。**\n\n---\n\n2. **三大命令模式**\n\n| 模式 | 命令语法 | 作用范围 | 何时使用 |\n| :--- | :--- | :--- | :--- |\n| **局部执行** | `npm run <script>` | **仅当前目录** | 在单个包内进行开发、调试。 |\n| **批量执行** | `npm run <script> --workspaces` | **所有**注册的 workspace 包 | 构建、测试、检查整个项目。 |\n| **精准执行** | `npm run <script> --workspace=<name>` | **指定的单个** workspace 包 | 只运行某个特定包的脚本。 |\n\n---\n\n3. **命令详解**\n\n*   **`npm run <script>` (无参数)**\n    *   **作用域**：严格限定在**当前所在目录**的 `package.json`。\n    *   **行为**：查找并执行当前目录 `package.json` 中 `scripts` 字段定义的 `<script>`。\n    *   **示例**：\n        ```bash\n        # 在 packages/ui 目录下\n        npm run dev  # 只运行 ui 包的 dev 脚本\n        ```\n    *   **关键**：这是**默认行为**，不涉及 workspace 管理。\n\n*   **`npm run <script> --workspaces` (复数)**\n    *   **作用域**：**所有**在根 `package.json` 的 `workspaces` 字段中声明的包。\n    *   **行为**：npm 会**依次**进入每个 workspace 包，并运行其 `package.json` 中对应的 `<script>`。\n    *   **并行执行**：添加 `--parallel` 可并行运行，速度更快：\n        ```bash\n        npm run test --workspaces --parallel\n        ```\n    *   **示例**：\n        ```bash\n        npm run build --workspaces  # 构建所有包\n        npm run lint --workspaces   # 检查所有包代码\n        ```\n\n*   **`npm run <script> --workspace=<name>` (单数)**\n    *   **作用域**：**仅** `<name>` 指定的**单个** workspace 包。\n    *   **`<name>` 是什么？**\n        *   可以是包的**相对路径**（相对于根项目）：`packages/ui`, `tools/cli`。\n        *   可以是包的**名称**（`package.json` 中的 `name` 字段）：`@myorg/core`, `my-ui-lib`。\n    *   **路径基准**：`<name>` 是**相对于根项目目录**解析的。\n    *   **示例**：\n        ```bash\n        npm run build --workspace=packages/ui\n        npm run dev --workspace=@myorg/frontend\n        ```\n\n---\n\n4. **运行位置：灵活但有约定**\n\n*   **技术上**：你可以在**项目中的任何目录**运行 `--workspaces` 或 `--workspace=<name>` 命令。\n    *   npm 会自动**向上查找**，找到包含 `workspaces` 的根 `package.json`。\n*   **实践上**：**强烈建议在根目录运行**这些命令。\n    *   **原因**：\n        1.  **意图清晰**：明确表示“我要管理整个项目”。\n        2.  **避免混淆**：防止误以为命令只与当前包有关。\n        3.  **符合脚本**：根 `package.json` 中的聚合脚本（如 `\"build\": \"npm run build --workspaces\"`）必须在根目录运行。\n        4.  **团队一致**：建立统一的操作规范。\n\n---\n\n5. **最佳实践**\n\n1.  **在根 `package.json` 中定义聚合脚本**：\n    ```json\n    {\n      \"scripts\": {\n        \"build\": \"npm run build --workspaces\",\n        \"test\": \"npm run test --workspaces --parallel\",\n        \"lint\": \"npm run lint --workspaces\",\n        \"dev:ui\": \"npm run dev --workspace=packages/ui\",\n        \"dev:api\": \"npm run dev --workspace=packages/api\"\n      }\n    }\n    ```\n2.  **始终在根目录运行聚合命令**：\n    ```bash\n    npm run build  # 调用根脚本\n    npm run test\n    ```\n3.  **在包内进行开发时使用局部命令**：\n    ```bash\n    cd packages/ui\n    npm run dev  # 只启动 UI 开发服务器\n    ```\n\n---\n6. **一句话总结**\n> **`npm run` 默认只作用于当前包；添加 `--workspaces` 可批量操作所有包，添加 `--workspace=<name>` 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。**\n\n---\n#### 5. 📚 npm Workspace 统一的依赖解析与链接\n#### 📚 npm Workspace 核心机制：统一的依赖解析与链接\n\n1. **核心目标**\n> **实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (`import ... from '@scope/pkg'`) 引用本地开发中的其他包，无需配置复杂路径别名。**\n\n---\n\n2. **底层机制：符号链接 (Symlink) + Node.js 模块解析**\n\n这个“魔法”由两部分协同完成：\n\n*   **第一步：npm 创建符号链接 (Symlink)**\n    *   **时机**：运行 `npm install`（通常在根目录）。\n    *   **操作**：\n        1.  npm 扫描所有包的 `dependencies`。\n        2.  发现 `packages/ui` 依赖 `@myorg/core`。\n        3.  识别到 `@myorg/core` 是一个 workspace 包（在 `workspaces` 数组中）。\n        4.  **在 `packages/ui/node_modules/@myorg/core` 创建一个符号链接 (软连接)**。\n        5.  **链接的目标**：`../../core`（即 `packages/core` 的源码目录）。\n    *   **结果**：`ui` 包的 `node_modules` 中有了一个指向 `core` 包源码的“快捷方式”。\n\n*   **第二步：Node.js 解析模块**\n    *   **时机**：运行代码（`npm run dev`, `node app.js`），执行到 `import ... from '@myorg/core'`。\n    *   **过程**（遵循 Node.js 标准）：\n        1.  从当前文件目录开始，向上查找 `node_modules`。\n        2.  在 `packages/ui/node_modules` 中找到 `@myorg/core`。\n        3.  发现它是一个**符号链接**。\n        4.  **跟随链接**，跳转到 `packages/core` 目录。\n        5.  读取 `packages/core/package.json`，找到 `main`, `module`, `exports` 等字段。\n        6.  加载并执行字段指向的文件（如 `dist/index.js`）。\n    *   **结果**：成功加载 `core` 包的代码，仿佛它就是一个安装好的 npm 包。\n\n---\n\n3. **关键特性与优势**\n\n| 特性 | 说明 |\n| :--- | :--- |\n| **开发体验统一** | 无论引用外部包 (`react`) 还是内部包 (`@myorg/core`)，代码写法完全一致：`import xxx from 'package-name'`。 |\n| **即时生效** | `core` 包更新并**重新构建**后，`ui` 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。 |\n| **解耦** | `ui` 包不关心 `core` 包的物理位置，只关心其包名和 API。 |\n| **可发布性** | |\n| **零配置** | 无需在 `tsconfig.json` 中配置 `paths` 别名。 |\n\n---\n\n4. **操作流程（依赖建立）**\n\n1.  **注册包**：在根 `package.json` 的 `workspaces` 数组中定义包路径（如 `\"packages/*\"`）。\n2.  **声明依赖**：在 `packages/ui/package.json` 的 `dependencies` 中添加 `\"@myorg/core\": \"1.0.0\"`。\n    *   **推荐命令**：`npm install @myorg/core --workspace=packages/ui`\n3.  **安装与链接**：在根目录运行 `npm install`，创建符号链接。\n\n    | 场景 | 是否需要 `--workspace` | 说明 |\n    | :--- | :--- | :--- |\n    | **在 workspace 包目录内运行** | ❌ **通常不需要** | npm 能自动推断上下文。 |\n    | **在根目录运行** | ✅ **强烈建议使用** | 避免歧义，确保命令精确作用于目标包。 |\n    | **添加新的 workspace 依赖** | ✅ **推荐使用** | 最清晰、最安全的方式。 |\n\n4.  **构建被依赖包**：确保 `packages/core` 已通过 `npm run build --workspace=packages/core` 构建出 `dist/`。（只要引用到代码就行）\n5.  **使用**：在 `ui` 包代码中 `import ... from '@myorg/core'`。\n\n---\n\n5. **常见误区澄清**\n\n*   **误区**：`\"dependencies\": { \"@myorg/core\": \"workspace:*\" }`\n    *   **正解**：❌ **npm 不支持**。这是 Yarn/pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。\n*   **误区**：每次 `core` 包更新都要改 `ui` 包的版本号。\n    *   **正解**：❌ **不需要**。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。\n*   **误区**：npm 会为 workspace 包“打包”或“下载”。\n    *   **正解**：❌ **不会**。开发时是直接链接到本地文件，无打包下载过程。\n\n---\n\n6. **一句话总结**\n\n> **npm workspace 通过在依赖包的 `node_modules` 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，`import` 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。**\n### 三、主要优势\n\n1.  **依赖集中管理与优化**：\n    *   所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 `node_modules` 统一管理。\n    *   npm 会进行依赖提升（hoist），避免重复安装，减少 `node_modules` 体积。\n    *   不同 workspace 可以共享相同的依赖版本。\n\n2.  **简化跨包依赖**：\n    *   假设 `frontend` 需要使用 `utils` 包。\n    *   在 `packages/frontend/package.json` 中，你可以直接这样写：\n        ```json\n        {\n          \"dependencies\": {\n            \"utils\": \"1.0.0\"  // 假设 utils 的 version 是 1.0.0\n            // 或者使用 \"workspace:*\" 来引用最新的本地版本\n          }\n        }\n        ```\n    *   npm 会自动将 `packages/utils` 链接到 `frontend` 的依赖中，**无需发布到 npm registry**。这极大地方便了本地开发和测试。\n\n3.  **批量操作**：\n    *   使用 `--workspaces` 或 `--workspace=<name>` 标志可以对所有或特定 workspace 执行命令。\n    *   **例子**：\n        *   `npm install`：安装所有 workspace 的依赖（包括它们之间的依赖）。\n        *   `npm run build --workspaces`：在所有 workspace 中运行 `build` 脚本。\n        *   `npm run test --workspace=packages/frontend`：只在 `frontend` workspace 中运行 `test` 脚本。\n        *   `npm exec --workspace=packages/backend vite`：在 `backend` 中执行 `vite` 命令。\n\n4.  **版本同步与发布**（需要额外工具）：\n    *   虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 `lerna` 或 `nx` 那样），但它为这些工具提供了基础。你可以结合 `npm version` 和脚本管理多个包的版本。\n\n---\n### 四、常用命令\n\n*   `npm install`：在根目录运行，会安装所有 workspace 的依赖。\n*   `npm run <script> --workspaces`：在所有 workspace 中运行指定脚本。\n*   `npm run <script> --workspace=<package-name>`：在指定 workspace 中运行脚本。\n*   `npm exec --workspace=<package-name> <command>`：在指定 workspace 中执行命令。\n*   `npm ls --workspaces`：列出所有 workspace。\n*   `npm publish --workspace=<package-name>`：发布指定的 workspace 包到 npm registry。\n\n---\n### 五、注意事项\n\n1.  **npm 版本要求**：必须使用 **npm 7 或更高版本**。\n2.  **`private: true`**：根项目通常设置为 `private: true`，防止意外发布。\n3.  **依赖解析**：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。\n4.  **与 `file:` 依赖的区别**：过去常用 `file:../utils` 来引用本地包，但这种方式在发布时会有问题（`file:` 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。\n5.  **不是唯一选择**：还有其他优秀的 monorepo 工具，如 `pnpm`（其 workspace 功能非常强大且高效）、`yarn`（with Plug'n'Play）、`lerna`、`nx` 等。选择哪个取决于你的具体需求和偏好。\n\n---\n\n### 总结\n\nnpm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。\n\n> npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题 ","slug":"npm workspace","published":1,"date":"2025-09-02T01:50:34.912Z","updated":"2025-09-01T09:54:01.768Z","_id":"cmf1wtzv0000pq4v9d8ftekxg","comments":1,"layout":"post","photos":[],"content":"<p>npm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 <strong>monorepo</strong>（单体仓库）。</p>\n<p>简单来说，npm workspace 允许你在<strong>一个根项目</strong>中管理<strong>多个相互关联的子项目（包）</strong>，并让它们共享依赖、简化版本管理和跨包依赖。</p>\n<h3 id=\"一、核心概念\"><a href=\"#一、核心概念\" class=\"headerlink\" title=\"一、核心概念\"></a>一、核心概念</h3><ol>\n<li><p>**Monorepo (单体仓库)**：</p>\n<ul>\n<li>一个代码仓库中包含多个独立的包（packages）。</li>\n<li>例如：一个项目包含前端应用 (<code>packages/frontend</code>)、后端服务 (<code>packages/backend</code>)、共享工具库 (<code>packages/utils</code>)。</li>\n</ul>\n</li>\n<li><p><strong>Workspace</strong>：</p>\n<ul>\n<li>指 monorepo 中的一个子包。</li>\n<li>每个 workspace 都是一个独立的 npm 包，拥有自己的 <code>package.json</code> 文件。</li>\n</ul>\n</li>\n<li><p>**Root Project (根项目)**：</p>\n<ul>\n<li>包含所有 workspace 的顶层目录。</li>\n<li>它的 <code>package.json</code> 文件通过 <code>workspaces</code> 字段来声明和配置所有子 workspace。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"二、-npm-Workspace\"><a href=\"#二、-npm-Workspace\" class=\"headerlink\" title=\"二、 npm Workspace\"></a>二、 npm Workspace</h3><h4 id=\"1-📚-目录结构示例\"><a href=\"#1-📚-目录结构示例\" class=\"headerlink\" title=\"1. 📚 目录结构示例\"></a>1. 📚 目录结构示例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json          <span class=\"comment\"># 根项目的 package.json</span></span><br><span class=\"line\">├── packages/</span><br><span class=\"line\">│   ├── frontend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># frontend workspace</span></span><br><span class=\"line\">│   ├── backend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># backend workspace</span></span><br><span class=\"line\">│   └── utils/</span><br><span class=\"line\">│       └── package.json  <span class=\"comment\"># utils workspace (shared library)</span></span><br><span class=\"line\">└── node_modules/         <span class=\"comment\"># 所有依赖集中安装在这里（由根项目管理）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-📚-npm-Workspace-workspaces字段\"><a href=\"#2-📚-npm-Workspace-workspaces字段\" class=\"headerlink\" title=\"2. 📚 npm Workspace workspaces字段\"></a>2. 📚 npm Workspace <code>workspaces</code>字段</h4><blockquote>\n<p><strong>位置</strong>：根目录的 <code>package.json</code> 文件中。<br><strong>作用</strong>：声明哪些目录是需要被统一管理的“工作区包”。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 必须！防止根项目被意外发布</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;workspaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;packages/*&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">// 通配符：packages 下所有子目录</span></span><br><span class=\"line\">    <span class=\"string\">&quot;tools/cli&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">// 具体路径</span></span><br><span class=\"line\">    <span class=\"string\">&quot;examples/demo-app&quot;</span>     <span class=\"comment\">// 可以是深层嵌套路径</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li><p><strong>核心条件</strong>：一个目录要成为 workspace 包，必须同时满足：</p>\n<ol>\n<li>其路径被 <code>workspaces</code> 数组中的某个条目<strong>匹配到</strong>。</li>\n<li>该目录下<strong>存在 <code>package.json</code> 文件</strong>。</li>\n</ol>\n</li>\n<li><p><strong>嵌套路径处理</strong>：</p>\n<ul>\n<li><code>a/sub</code> 是 <code>a</code> 的子目录，<strong>物理上嵌套</strong>。</li>\n<li>但如果在 <code>workspaces</code> 中<strong>同时注册了 <code>&quot;a&quot;</code> 和 <code>&quot;a/sub&quot;</code><strong>，那么它们在 workspace 系统中是</strong>两个独立且平级的包</strong>。</li>\n<li><strong>注册即平等</strong>：被根 <code>workspaces</code> 直接列出的路径，都视为顶级管理单元。</li>\n</ul>\n</li>\n<li><p><strong>最佳实践 (Best Practices)</strong></p>\n<ul>\n<li>**根项目设为 <code>private: true</code>**。</li>\n<li><strong>避免在 workspace 包内部再用 <code>workspaces</code> 管理子包</strong>（易冲突）。</li>\n<li><strong>优先使用平铺结构</strong> (<code>packages/core</code>, <code>packages/ui</code>) 或<strong>明确列出路径</strong>。</li>\n<li><strong>利用 <code>exports</code> 字段</strong>进行精细导出，而非创建过多小包。</li>\n<li><strong>合理使用 <code>workspace:*</code></strong> 简化本地包依赖。</li>\n</ul>\n</li>\n<li><p><strong>一句话总结</strong></p>\n<blockquote>\n<p><strong><code>workspaces</code> 字段是“注册表”，将指定路径下的 <code>package.json</code> 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。</strong></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-📚-npm-Workspace-统一依赖管理\"><a href=\"#3-📚-npm-Workspace-统一依赖管理\" class=\"headerlink\" title=\"3. 📚 npm Workspace 统一依赖管理\"></a>3. 📚 npm Workspace 统一依赖管理</h4><ol>\n<li><p><strong>核心目标</strong></p>\n<blockquote>\n<p><strong>实现多包项目中依赖的高效共享、去重和版本统一，避免 <code>node_modules</code> 膨胀和版本冲突。</strong></p>\n</blockquote>\n</li>\n<li><p><strong>核心机制：依赖提升 (Dependency Hoisting)</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>定义</strong>：将所有 workspace 包的<strong>公共外部依赖</strong>，集中安装到<strong>根目录的 <code>node_modules</code></strong> 中。</li>\n<li><strong>触发</strong>：在根目录或任何 workspace 包内运行 <code>npm install</code>。</li>\n<li><strong>过程</strong>：<ol>\n<li>npm 扫描所有 <code>workspaces</code> 包的 <code>package.json</code>。</li>\n<li>收集所有 <code>dependencies</code> 和 <code>devDependencies</code>。</li>\n<li>进行版本解析，选择兼容的版本。</li>\n<li>将选中的外部包（如 <code>react</code>, <code>lodash</code>）<strong>只安装一份</strong>到 <code>根/node_modules</code>。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>实现方式：符号链接 (Symbolic Links &#x2F; Symlinks)</strong></li>\n</ol>\n<ul>\n<li><strong>位置</strong>：在<strong>每个 workspace 包的 <code>node_modules</code> 子目录内</strong>。</li>\n<li><strong>作用</strong>：为每个包“模拟”出它所需要的依赖。</li>\n<li><strong>方向</strong>：<ul>\n<li><strong>源</strong>：<code>packages/your-pkg/node_modules/lodash</code></li>\n<li><strong>目标</strong>：<code>../../../node_modules/lodash</code> (指向根目录的真实依赖)</li>\n</ul>\n</li>\n<li><strong>关键</strong>：链接是由 <strong>npm 自动创建</strong>的，对开发者透明。</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>文件系统结构示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── package-lock.json</span><br><span class=\"line\">├── node_modules/                     <span class=\"comment\"># 🎯 依赖的“中央仓库”</span></span><br><span class=\"line\">│   ├── lodash/                       <span class=\"comment\"># ✅ 真实的 lodash 包</span></span><br><span class=\"line\">│   └── react/                        <span class=\"comment\"># ✅ 真实的 react 包</span></span><br><span class=\"line\">└── packages/</span><br><span class=\"line\">    ├── core/</span><br><span class=\"line\">    │   ├── package.json</span><br><span class=\"line\">    │   └── node_modules/</span><br><span class=\"line\">    │       └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">    └── ui/</span><br><span class=\"line\">        ├── package.json</span><br><span class=\"line\">        └── node_modules/</span><br><span class=\"line\">            ├── react -&gt; ../../../node_modules/react    <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">            └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>工作流程 (Node.js 模块解析)</strong><br>当 <code>packages/ui</code> 执行 <code>require(&#39;react&#39;)</code>：</p>\n</li>\n<li><p>从 <code>packages/ui</code> 开始查找 <code>node_modules/react</code>。</p>\n</li>\n<li><p>找到 <code>packages/ui/node_modules/react</code> —— 这是一个<strong>符号链接</strong>。</p>\n</li>\n<li><p>系统跟随链接，定位到 <code>根/node_modules/react</code>。</p>\n</li>\n<li><p>加载并执行根目录中的真实 <code>react</code> 代码。</p>\n</li>\n<li><p><strong>关键优势</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">优势</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>去重</strong></td>\n<td align=\"left\">相同依赖只安装一份，节省磁盘空间。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>高效</strong></td>\n<td align=\"left\">安装速度更快，<code>node_modules</code> 体积显著减小。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>版本统一</strong></td>\n<td align=\"left\">npm 尽量使用单一版本，减少“依赖地狱”。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>开发友好</strong></td>\n<td align=\"left\">包间依赖通过链接直接引用源码，修改即时生效。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>在子目录安装依赖会发生什么？</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>绝大多数情况</strong> (<code>npm install lodash</code>)：<ul>\n<li>依赖被**提升到根 <code>node_modules</code>**。</li>\n<li>子目录的 <code>node_modules</code> 中创建<strong>指向根的符号链接</strong>。</li>\n</ul>\n</li>\n<li><strong>特殊情况（版本冲突）</strong>：<ul>\n<li>如果版本与其他包不兼容，npm <strong>可能</strong>会将该版本<strong>本地安装</strong>到子目录的 <code>node_modules</code>（真实代码，非链接）。</li>\n<li>这是 npm 为了解决冲突的“降级”方案，应尽量避免。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong>npm Workspace 通过“依赖提升”将所有外部依赖集中到根 <code>node_modules</code>，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"4-📚-npm-Workspace-统一脚本执行\"><a href=\"#4-📚-npm-Workspace-统一脚本执行\" class=\"headerlink\" title=\"4. 📚 npm Workspace 统一脚本执行\"></a>4. 📚 npm Workspace 统一脚本执行</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>三大命令模式</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">命令语法</th>\n<th align=\"left\">作用范围</th>\n<th align=\"left\">何时使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>局部执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt;</code></td>\n<td align=\"left\"><strong>仅当前目录</strong></td>\n<td align=\"left\">在单个包内进行开发、调试。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>批量执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspaces</code></td>\n<td align=\"left\"><strong>所有</strong>注册的 workspace 包</td>\n<td align=\"left\">构建、测试、检查整个项目。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>精准执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code></td>\n<td align=\"left\"><strong>指定的单个</strong> workspace 包</td>\n<td align=\"left\">只运行某个特定包的脚本。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"3\">\n<li><strong>命令详解</strong></li>\n</ol>\n<ul>\n<li><p><strong><code>npm run &lt;script&gt;</code> (无参数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：严格限定在<strong>当前所在目录</strong>的 <code>package.json</code>。</li>\n<li><strong>行为</strong>：查找并执行当前目录 <code>package.json</code> 中 <code>scripts</code> 字段定义的 <code>&lt;script&gt;</code>。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 packages/ui 目录下</span></span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只运行 ui 包的 dev 脚本</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>关键</strong>：这是<strong>默认行为</strong>，不涉及 workspace 管理。</li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspaces</code> (复数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>所有</strong>在根 <code>package.json</code> 的 <code>workspaces</code> 字段中声明的包。</li>\n<li><strong>行为</strong>：npm 会<strong>依次</strong>进入每个 workspace 包，并运行其 <code>package.json</code> 中对应的 <code>&lt;script&gt;</code>。</li>\n<li><strong>并行执行</strong>：添加 <code>--parallel</code> 可并行运行，速度更快：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run <span class=\"built_in\">test</span> --workspaces --parallel</span><br></pre></td></tr></table></figure></li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspaces  <span class=\"comment\"># 构建所有包</span></span><br><span class=\"line\">npm run lint --workspaces   <span class=\"comment\"># 检查所有包代码</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code> (单数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>仅</strong> <code>&lt;name&gt;</code> 指定的<strong>单个</strong> workspace 包。</li>\n<li><strong><code>&lt;name&gt;</code> 是什么？</strong><ul>\n<li>可以是包的<strong>相对路径</strong>（相对于根项目）：<code>packages/ui</code>, <code>tools/cli</code>。</li>\n<li>可以是包的<strong>名称</strong>（<code>package.json</code> 中的 <code>name</code> 字段）：<code>@myorg/core</code>, <code>my-ui-lib</code>。</li>\n</ul>\n</li>\n<li><strong>路径基准</strong>：<code>&lt;name&gt;</code> 是<strong>相对于根项目目录</strong>解析的。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspace=packages/ui</span><br><span class=\"line\">npm run dev --workspace=@myorg/frontend</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"4\">\n<li><strong>运行位置：灵活但有约定</strong></li>\n</ol>\n<ul>\n<li><strong>技术上</strong>：你可以在<strong>项目中的任何目录</strong>运行 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 命令。<ul>\n<li>npm 会自动<strong>向上查找</strong>，找到包含 <code>workspaces</code> 的根 <code>package.json</code>。</li>\n</ul>\n</li>\n<li><strong>实践上</strong>：<strong>强烈建议在根目录运行</strong>这些命令。<ul>\n<li><strong>原因</strong>：<ol>\n<li><strong>意图清晰</strong>：明确表示“我要管理整个项目”。</li>\n<li><strong>避免混淆</strong>：防止误以为命令只与当前包有关。</li>\n<li><strong>符合脚本</strong>：根 <code>package.json</code> 中的聚合脚本（如 <code>&quot;build&quot;: &quot;npm run build --workspaces&quot;</code>）必须在根目录运行。</li>\n<li><strong>团队一致</strong>：建立统一的操作规范。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"5\">\n<li><p><strong>最佳实践</strong></p>\n</li>\n<li><p><strong>在根 <code>package.json</code> 中定义聚合脚本</strong>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run build --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;test&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run test --workspaces --parallel&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run lint --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:ui&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/ui&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:api&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/api&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>始终在根目录运行聚合命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build  <span class=\"comment\"># 调用根脚本</span></span><br><span class=\"line\">npm run <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>在包内进行开发时使用局部命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> packages/ui</span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只启动 UI 开发服务器</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong><code>npm run</code> 默认只作用于当前包；添加 <code>--workspaces</code> 可批量操作所有包，添加 <code>--workspace=&lt;name&gt;</code> 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"5-📚-npm-Workspace-统一的依赖解析与链接\"><a href=\"#5-📚-npm-Workspace-统一的依赖解析与链接\" class=\"headerlink\" title=\"5. 📚 npm Workspace 统一的依赖解析与链接\"></a>5. 📚 npm Workspace 统一的依赖解析与链接</h4><h4 id=\"📚-npm-Workspace-核心机制：统一的依赖解析与链接\"><a href=\"#📚-npm-Workspace-核心机制：统一的依赖解析与链接\" class=\"headerlink\" title=\"📚 npm Workspace 核心机制：统一的依赖解析与链接\"></a>📚 npm Workspace 核心机制：统一的依赖解析与链接</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (<code>import ... from &#39;@scope/pkg&#39;</code>) 引用本地开发中的其他包，无需配置复杂路径别名。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>底层机制：符号链接 (Symlink) + Node.js 模块解析</strong></li>\n</ol>\n<p>这个“魔法”由两部分协同完成：</p>\n<ul>\n<li><p><strong>第一步：npm 创建符号链接 (Symlink)</strong></p>\n<ul>\n<li><strong>时机</strong>：运行 <code>npm install</code>（通常在根目录）。</li>\n<li><strong>操作</strong>：<ol>\n<li>npm 扫描所有包的 <code>dependencies</code>。</li>\n<li>发现 <code>packages/ui</code> 依赖 <code>@myorg/core</code>。</li>\n<li>识别到 <code>@myorg/core</code> 是一个 workspace 包（在 <code>workspaces</code> 数组中）。</li>\n<li>**在 <code>packages/ui/node_modules/@myorg/core</code> 创建一个符号链接 (软连接)**。</li>\n<li><strong>链接的目标</strong>：<code>../../core</code>（即 <code>packages/core</code> 的源码目录）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：<code>ui</code> 包的 <code>node_modules</code> 中有了一个指向 <code>core</code> 包源码的“快捷方式”。</li>\n</ul>\n</li>\n<li><p><strong>第二步：Node.js 解析模块</strong></p>\n<ul>\n<li><strong>时机</strong>：运行代码（<code>npm run dev</code>, <code>node app.js</code>），执行到 <code>import ... from &#39;@myorg/core&#39;</code>。</li>\n<li><strong>过程</strong>（遵循 Node.js 标准）：<ol>\n<li>从当前文件目录开始，向上查找 <code>node_modules</code>。</li>\n<li>在 <code>packages/ui/node_modules</code> 中找到 <code>@myorg/core</code>。</li>\n<li>发现它是一个<strong>符号链接</strong>。</li>\n<li><strong>跟随链接</strong>，跳转到 <code>packages/core</code> 目录。</li>\n<li>读取 <code>packages/core/package.json</code>，找到 <code>main</code>, <code>module</code>, <code>exports</code> 等字段。</li>\n<li>加载并执行字段指向的文件（如 <code>dist/index.js</code>）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：成功加载 <code>core</code> 包的代码，仿佛它就是一个安装好的 npm 包。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li><strong>关键特性与优势</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>开发体验统一</strong></td>\n<td align=\"left\">无论引用外部包 (<code>react</code>) 还是内部包 (<code>@myorg/core</code>)，代码写法完全一致：<code>import xxx from &#39;package-name&#39;</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>即时生效</strong></td>\n<td align=\"left\"><code>core</code> 包更新并<strong>重新构建</strong>后，<code>ui</code> 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>解耦</strong></td>\n<td align=\"left\"><code>ui</code> 包不关心 <code>core</code> 包的物理位置，只关心其包名和 API。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>可发布性</strong></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>零配置</strong></td>\n<td align=\"left\">无需在 <code>tsconfig.json</code> 中配置 <code>paths</code> 别名。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"4\">\n<li><p><strong>操作流程（依赖建立）</strong></p>\n</li>\n<li><p><strong>注册包</strong>：在根 <code>package.json</code> 的 <code>workspaces</code> 数组中定义包路径（如 <code>&quot;packages/*&quot;</code>）。</p>\n</li>\n<li><p><strong>声明依赖</strong>：在 <code>packages/ui/package.json</code> 的 <code>dependencies</code> 中添加 <code>&quot;@myorg/core&quot;: &quot;1.0.0&quot;</code>。</p>\n<ul>\n<li><strong>推荐命令</strong>：<code>npm install @myorg/core --workspace=packages/ui</code></li>\n</ul>\n</li>\n<li><p><strong>安装与链接</strong>：在根目录运行 <code>npm install</code>，创建符号链接。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">场景</th>\n<th align=\"left\">是否需要 <code>--workspace</code></th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>在 workspace 包目录内运行</strong></td>\n<td align=\"left\">❌ <strong>通常不需要</strong></td>\n<td align=\"left\">npm 能自动推断上下文。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>在根目录运行</strong></td>\n<td align=\"left\">✅ <strong>强烈建议使用</strong></td>\n<td align=\"left\">避免歧义，确保命令精确作用于目标包。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>添加新的 workspace 依赖</strong></td>\n<td align=\"left\">✅ <strong>推荐使用</strong></td>\n<td align=\"left\">最清晰、最安全的方式。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>构建被依赖包</strong>：确保 <code>packages/core</code> 已通过 <code>npm run build --workspace=packages/core</code> 构建出 <code>dist/</code>。（只要引用到代码就行）</p>\n</li>\n<li><p><strong>使用</strong>：在 <code>ui</code> 包代码中 <code>import ... from &#39;@myorg/core&#39;</code>。</p>\n</li>\n</ol>\n<hr>\n<ol start=\"5\">\n<li><strong>常见误区澄清</strong></li>\n</ol>\n<ul>\n<li><strong>误区</strong>：<code>&quot;dependencies&quot;: &#123; &quot;@myorg/core&quot;: &quot;workspace:*&quot; &#125;</code><ul>\n<li><strong>正解</strong>：❌ <strong>npm 不支持</strong>。这是 Yarn&#x2F;pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：每次 <code>core</code> 包更新都要改 <code>ui</code> 包的版本号。<ul>\n<li><strong>正解</strong>：❌ <strong>不需要</strong>。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：npm 会为 workspace 包“打包”或“下载”。<ul>\n<li><strong>正解</strong>：❌ <strong>不会</strong>。开发时是直接链接到本地文件，无打包下载过程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong></li>\n</ol>\n<blockquote>\n<p><strong>npm workspace 通过在依赖包的 <code>node_modules</code> 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，<code>import</code> 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。</strong></p>\n</blockquote>\n<h3 id=\"三、主要优势\"><a href=\"#三、主要优势\" class=\"headerlink\" title=\"三、主要优势\"></a>三、主要优势</h3><ol>\n<li><p><strong>依赖集中管理与优化</strong>：</p>\n<ul>\n<li>所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 <code>node_modules</code> 统一管理。</li>\n<li>npm 会进行依赖提升（hoist），避免重复安装，减少 <code>node_modules</code> 体积。</li>\n<li>不同 workspace 可以共享相同的依赖版本。</li>\n</ul>\n</li>\n<li><p><strong>简化跨包依赖</strong>：</p>\n<ul>\n<li>假设 <code>frontend</code> 需要使用 <code>utils</code> 包。</li>\n<li>在 <code>packages/frontend/package.json</code> 中，你可以直接这样写：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;utils&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span>  <span class=\"comment\">// 假设 utils 的 version 是 1.0.0</span></span><br><span class=\"line\">    <span class=\"comment\">// 或者使用 &quot;workspace:*&quot; 来引用最新的本地版本</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>npm 会自动将 <code>packages/utils</code> 链接到 <code>frontend</code> 的依赖中，<strong>无需发布到 npm registry</strong>。这极大地方便了本地开发和测试。</li>\n</ul>\n</li>\n<li><p><strong>批量操作</strong>：</p>\n<ul>\n<li>使用 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 标志可以对所有或特定 workspace 执行命令。</li>\n<li><strong>例子</strong>：<ul>\n<li><code>npm install</code>：安装所有 workspace 的依赖（包括它们之间的依赖）。</li>\n<li><code>npm run build --workspaces</code>：在所有 workspace 中运行 <code>build</code> 脚本。</li>\n<li><code>npm run test --workspace=packages/frontend</code>：只在 <code>frontend</code> workspace 中运行 <code>test</code> 脚本。</li>\n<li><code>npm exec --workspace=packages/backend vite</code>：在 <code>backend</code> 中执行 <code>vite</code> 命令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>版本同步与发布</strong>（需要额外工具）：</p>\n<ul>\n<li>虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 <code>lerna</code> 或 <code>nx</code> 那样），但它为这些工具提供了基础。你可以结合 <code>npm version</code> 和脚本管理多个包的版本。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、常用命令\"><a href=\"#四、常用命令\" class=\"headerlink\" title=\"四、常用命令\"></a>四、常用命令</h3><ul>\n<li><code>npm install</code>：在根目录运行，会安装所有 workspace 的依赖。</li>\n<li><code>npm run &lt;script&gt; --workspaces</code>：在所有 workspace 中运行指定脚本。</li>\n<li><code>npm run &lt;script&gt; --workspace=&lt;package-name&gt;</code>：在指定 workspace 中运行脚本。</li>\n<li><code>npm exec --workspace=&lt;package-name&gt; &lt;command&gt;</code>：在指定 workspace 中执行命令。</li>\n<li><code>npm ls --workspaces</code>：列出所有 workspace。</li>\n<li><code>npm publish --workspace=&lt;package-name&gt;</code>：发布指定的 workspace 包到 npm registry。</li>\n</ul>\n<hr>\n<h3 id=\"五、注意事项\"><a href=\"#五、注意事项\" class=\"headerlink\" title=\"五、注意事项\"></a>五、注意事项</h3><ol>\n<li><strong>npm 版本要求</strong>：必须使用 <strong>npm 7 或更高版本</strong>。</li>\n<li>**<code>private: true</code>**：根项目通常设置为 <code>private: true</code>，防止意外发布。</li>\n<li><strong>依赖解析</strong>：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。</li>\n<li><strong>与 <code>file:</code> 依赖的区别</strong>：过去常用 <code>file:../utils</code> 来引用本地包，但这种方式在发布时会有问题（<code>file:</code> 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。</li>\n<li><strong>不是唯一选择</strong>：还有其他优秀的 monorepo 工具，如 <code>pnpm</code>（其 workspace 功能非常强大且高效）、<code>yarn</code>（with Plug’n’Play）、<code>lerna</code>、<code>nx</code> 等。选择哪个取决于你的具体需求和偏好。</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>npm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。</p>\n<blockquote>\n<p>npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题<br>看起来您可能想了解的是 npm 的 <strong>workspace</strong>（工作区）功能，而不是“workplace”。npm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 <strong>monorepo</strong>（单体仓库）。</p>\n</blockquote>\n<p>简单来说，npm workspace 允许你在<strong>一个根项目</strong>中管理<strong>多个相互关联的子项目（包）</strong>，并让它们共享依赖、简化版本管理和跨包依赖。</p>\n<hr>\n<h3 id=\"一、核心概念-1\"><a href=\"#一、核心概念-1\" class=\"headerlink\" title=\"一、核心概念\"></a>一、核心概念</h3><ol>\n<li><p>**Monorepo (单体仓库)**：</p>\n<ul>\n<li>一个代码仓库中包含多个独立的包（packages）。</li>\n<li>例如：一个项目包含前端应用 (<code>packages/frontend</code>)、后端服务 (<code>packages/backend</code>)、共享工具库 (<code>packages/utils</code>)。</li>\n</ul>\n</li>\n<li><p><strong>Workspace</strong>：</p>\n<ul>\n<li>指 monorepo 中的一个子包。</li>\n<li>每个 workspace 都是一个独立的 npm 包，拥有自己的 <code>package.json</code> 文件。</li>\n</ul>\n</li>\n<li><p>**Root Project (根项目)**：</p>\n<ul>\n<li>包含所有 workspace 的顶层目录。</li>\n<li>它的 <code>package.json</code> 文件通过 <code>workspaces</code> 字段来声明和配置所有子 workspace。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"二、如何配置-npm-Workspace\"><a href=\"#二、如何配置-npm-Workspace\" class=\"headerlink\" title=\"二、如何配置 npm Workspace\"></a>二、如何配置 npm Workspace</h3><h4 id=\"1-📚-目录结构示例-1\"><a href=\"#1-📚-目录结构示例-1\" class=\"headerlink\" title=\"1. 📚 目录结构示例\"></a>1. 📚 目录结构示例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json          <span class=\"comment\"># 根项目的 package.json</span></span><br><span class=\"line\">├── packages/</span><br><span class=\"line\">│   ├── frontend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># frontend workspace</span></span><br><span class=\"line\">│   ├── backend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># backend workspace</span></span><br><span class=\"line\">│   └── utils/</span><br><span class=\"line\">│       └── package.json  <span class=\"comment\"># utils workspace (shared library)</span></span><br><span class=\"line\">└── node_modules/         <span class=\"comment\"># 所有依赖集中安装在这里（由根项目管理）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-📚-npm-Workspace-workspaces字段-1\"><a href=\"#2-📚-npm-Workspace-workspaces字段-1\" class=\"headerlink\" title=\"2. 📚 npm Workspace workspaces字段\"></a>2. 📚 npm Workspace <code>workspaces</code>字段</h4><blockquote>\n<p><strong>位置</strong>：根目录的 <code>package.json</code> 文件中。<br><strong>作用</strong>：声明哪些目录是需要被统一管理的“工作区包”。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 必须！防止根项目被意外发布</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;workspaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;packages/*&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">// 通配符：packages 下所有子目录</span></span><br><span class=\"line\">    <span class=\"string\">&quot;tools/cli&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">// 具体路径</span></span><br><span class=\"line\">    <span class=\"string\">&quot;examples/demo-app&quot;</span>     <span class=\"comment\">// 可以是深层嵌套路径</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li><p><strong>核心条件</strong>：一个目录要成为 workspace 包，必须同时满足：</p>\n<ol>\n<li>其路径被 <code>workspaces</code> 数组中的某个条目<strong>匹配到</strong>。</li>\n<li>该目录下<strong>存在 <code>package.json</code> 文件</strong>。</li>\n</ol>\n</li>\n<li><p><strong>嵌套路径处理</strong>：</p>\n<ul>\n<li><code>a/sub</code> 是 <code>a</code> 的子目录，<strong>物理上嵌套</strong>。</li>\n<li>但如果在 <code>workspaces</code> 中<strong>同时注册了 <code>&quot;a&quot;</code> 和 <code>&quot;a/sub&quot;</code><strong>，那么它们在 workspace 系统中是</strong>两个独立且平级的包</strong>。</li>\n<li><strong>注册即平等</strong>：被根 <code>workspaces</code> 直接列出的路径，都视为顶级管理单元。</li>\n</ul>\n</li>\n<li><p><strong>最佳实践 (Best Practices)</strong></p>\n<ul>\n<li>**根项目设为 <code>private: true</code>**。</li>\n<li><strong>避免在 workspace 包内部再用 <code>workspaces</code> 管理子包</strong>（易冲突）。</li>\n<li><strong>优先使用平铺结构</strong> (<code>packages/core</code>, <code>packages/ui</code>) 或<strong>明确列出路径</strong>。</li>\n<li><strong>利用 <code>exports</code> 字段</strong>进行精细导出，而非创建过多小包。</li>\n<li><strong>合理使用 <code>workspace:*</code></strong> 简化本地包依赖。</li>\n</ul>\n</li>\n<li><p><strong>一句话总结</strong></p>\n<blockquote>\n<p><strong><code>workspaces</code> 字段是“注册表”，将指定路径下的 <code>package.json</code> 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。</strong></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-📚-npm-Workspace-统一依赖管理-1\"><a href=\"#3-📚-npm-Workspace-统一依赖管理-1\" class=\"headerlink\" title=\"3. 📚 npm Workspace 统一依赖管理\"></a>3. 📚 npm Workspace 统一依赖管理</h4><ol>\n<li><p><strong>核心目标</strong></p>\n<blockquote>\n<p><strong>实现多包项目中依赖的高效共享、去重和版本统一，避免 <code>node_modules</code> 膨胀和版本冲突。</strong></p>\n</blockquote>\n</li>\n<li><p><strong>核心机制：依赖提升 (Dependency Hoisting)</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>定义</strong>：将所有 workspace 包的<strong>公共外部依赖</strong>，集中安装到<strong>根目录的 <code>node_modules</code></strong> 中。</li>\n<li><strong>触发</strong>：在根目录或任何 workspace 包内运行 <code>npm install</code>。</li>\n<li><strong>过程</strong>：<ol>\n<li>npm 扫描所有 <code>workspaces</code> 包的 <code>package.json</code>。</li>\n<li>收集所有 <code>dependencies</code> 和 <code>devDependencies</code>。</li>\n<li>进行版本解析，选择兼容的版本。</li>\n<li>将选中的外部包（如 <code>react</code>, <code>lodash</code>）<strong>只安装一份</strong>到 <code>根/node_modules</code>。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>实现方式：符号链接 (Symbolic Links &#x2F; Symlinks)</strong></li>\n</ol>\n<ul>\n<li><strong>位置</strong>：在<strong>每个 workspace 包的 <code>node_modules</code> 子目录内</strong>。</li>\n<li><strong>作用</strong>：为每个包“模拟”出它所需要的依赖。</li>\n<li><strong>方向</strong>：<ul>\n<li><strong>源</strong>：<code>packages/your-pkg/node_modules/lodash</code></li>\n<li><strong>目标</strong>：<code>../../../node_modules/lodash</code> (指向根目录的真实依赖)</li>\n</ul>\n</li>\n<li><strong>关键</strong>：链接是由 <strong>npm 自动创建</strong>的，对开发者透明。</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>文件系统结构示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── package-lock.json</span><br><span class=\"line\">├── node_modules/                     <span class=\"comment\"># 🎯 依赖的“中央仓库”</span></span><br><span class=\"line\">│   ├── lodash/                       <span class=\"comment\"># ✅ 真实的 lodash 包</span></span><br><span class=\"line\">│   └── react/                        <span class=\"comment\"># ✅ 真实的 react 包</span></span><br><span class=\"line\">└── packages/</span><br><span class=\"line\">    ├── core/</span><br><span class=\"line\">    │   ├── package.json</span><br><span class=\"line\">    │   └── node_modules/</span><br><span class=\"line\">    │       └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">    └── ui/</span><br><span class=\"line\">        ├── package.json</span><br><span class=\"line\">        └── node_modules/</span><br><span class=\"line\">            ├── react -&gt; ../../../node_modules/react    <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">            └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>工作流程 (Node.js 模块解析)</strong><br>当 <code>packages/ui</code> 执行 <code>require(&#39;react&#39;)</code>：</p>\n</li>\n<li><p>从 <code>packages/ui</code> 开始查找 <code>node_modules/react</code>。</p>\n</li>\n<li><p>找到 <code>packages/ui/node_modules/react</code> —— 这是一个<strong>符号链接</strong>。</p>\n</li>\n<li><p>系统跟随链接，定位到 <code>根/node_modules/react</code>。</p>\n</li>\n<li><p>加载并执行根目录中的真实 <code>react</code> 代码。</p>\n</li>\n<li><p><strong>关键优势</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">优势</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>去重</strong></td>\n<td align=\"left\">相同依赖只安装一份，节省磁盘空间。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>高效</strong></td>\n<td align=\"left\">安装速度更快，<code>node_modules</code> 体积显著减小。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>版本统一</strong></td>\n<td align=\"left\">npm 尽量使用单一版本，减少“依赖地狱”。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>开发友好</strong></td>\n<td align=\"left\">包间依赖通过链接直接引用源码，修改即时生效。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>在子目录安装依赖会发生什么？</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>绝大多数情况</strong> (<code>npm install lodash</code>)：<ul>\n<li>依赖被**提升到根 <code>node_modules</code>**。</li>\n<li>子目录的 <code>node_modules</code> 中创建<strong>指向根的符号链接</strong>。</li>\n</ul>\n</li>\n<li><strong>特殊情况（版本冲突）</strong>：<ul>\n<li>如果版本与其他包不兼容，npm <strong>可能</strong>会将该版本<strong>本地安装</strong>到子目录的 <code>node_modules</code>（真实代码，非链接）。</li>\n<li>这是 npm 为了解决冲突的“降级”方案，应尽量避免。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong>npm Workspace 通过“依赖提升”将所有外部依赖集中到根 <code>node_modules</code>，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"4-📚-npm-Workspace-统一脚本执行-1\"><a href=\"#4-📚-npm-Workspace-统一脚本执行-1\" class=\"headerlink\" title=\"4. 📚 npm Workspace 统一脚本执行\"></a>4. 📚 npm Workspace 统一脚本执行</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>三大命令模式</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">命令语法</th>\n<th align=\"left\">作用范围</th>\n<th align=\"left\">何时使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>局部执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt;</code></td>\n<td align=\"left\"><strong>仅当前目录</strong></td>\n<td align=\"left\">在单个包内进行开发、调试。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>批量执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspaces</code></td>\n<td align=\"left\"><strong>所有</strong>注册的 workspace 包</td>\n<td align=\"left\">构建、测试、检查整个项目。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>精准执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code></td>\n<td align=\"left\"><strong>指定的单个</strong> workspace 包</td>\n<td align=\"left\">只运行某个特定包的脚本。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"3\">\n<li><strong>命令详解</strong></li>\n</ol>\n<ul>\n<li><p><strong><code>npm run &lt;script&gt;</code> (无参数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：严格限定在<strong>当前所在目录</strong>的 <code>package.json</code>。</li>\n<li><strong>行为</strong>：查找并执行当前目录 <code>package.json</code> 中 <code>scripts</code> 字段定义的 <code>&lt;script&gt;</code>。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 packages/ui 目录下</span></span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只运行 ui 包的 dev 脚本</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>关键</strong>：这是<strong>默认行为</strong>，不涉及 workspace 管理。</li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspaces</code> (复数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>所有</strong>在根 <code>package.json</code> 的 <code>workspaces</code> 字段中声明的包。</li>\n<li><strong>行为</strong>：npm 会<strong>依次</strong>进入每个 workspace 包，并运行其 <code>package.json</code> 中对应的 <code>&lt;script&gt;</code>。</li>\n<li><strong>并行执行</strong>：添加 <code>--parallel</code> 可并行运行，速度更快：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run <span class=\"built_in\">test</span> --workspaces --parallel</span><br></pre></td></tr></table></figure></li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspaces  <span class=\"comment\"># 构建所有包</span></span><br><span class=\"line\">npm run lint --workspaces   <span class=\"comment\"># 检查所有包代码</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code> (单数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>仅</strong> <code>&lt;name&gt;</code> 指定的<strong>单个</strong> workspace 包。</li>\n<li><strong><code>&lt;name&gt;</code> 是什么？</strong><ul>\n<li>可以是包的<strong>相对路径</strong>（相对于根项目）：<code>packages/ui</code>, <code>tools/cli</code>。</li>\n<li>可以是包的<strong>名称</strong>（<code>package.json</code> 中的 <code>name</code> 字段）：<code>@myorg/core</code>, <code>my-ui-lib</code>。</li>\n</ul>\n</li>\n<li><strong>路径基准</strong>：<code>&lt;name&gt;</code> 是<strong>相对于根项目目录</strong>解析的。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspace=packages/ui</span><br><span class=\"line\">npm run dev --workspace=@myorg/frontend</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"4\">\n<li><strong>运行位置：灵活但有约定</strong></li>\n</ol>\n<ul>\n<li><strong>技术上</strong>：你可以在<strong>项目中的任何目录</strong>运行 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 命令。<ul>\n<li>npm 会自动<strong>向上查找</strong>，找到包含 <code>workspaces</code> 的根 <code>package.json</code>。</li>\n</ul>\n</li>\n<li><strong>实践上</strong>：<strong>强烈建议在根目录运行</strong>这些命令。<ul>\n<li><strong>原因</strong>：<ol>\n<li><strong>意图清晰</strong>：明确表示“我要管理整个项目”。</li>\n<li><strong>避免混淆</strong>：防止误以为命令只与当前包有关。</li>\n<li><strong>符合脚本</strong>：根 <code>package.json</code> 中的聚合脚本（如 <code>&quot;build&quot;: &quot;npm run build --workspaces&quot;</code>）必须在根目录运行。</li>\n<li><strong>团队一致</strong>：建立统一的操作规范。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"5\">\n<li><p><strong>最佳实践</strong></p>\n</li>\n<li><p><strong>在根 <code>package.json</code> 中定义聚合脚本</strong>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run build --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;test&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run test --workspaces --parallel&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run lint --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:ui&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/ui&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:api&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/api&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>始终在根目录运行聚合命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build  <span class=\"comment\"># 调用根脚本</span></span><br><span class=\"line\">npm run <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>在包内进行开发时使用局部命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> packages/ui</span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只启动 UI 开发服务器</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong><code>npm run</code> 默认只作用于当前包；添加 <code>--workspaces</code> 可批量操作所有包，添加 <code>--workspace=&lt;name&gt;</code> 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"5-📚-npm-Workspace-统一的依赖解析与链接-1\"><a href=\"#5-📚-npm-Workspace-统一的依赖解析与链接-1\" class=\"headerlink\" title=\"5. 📚 npm Workspace 统一的依赖解析与链接\"></a>5. 📚 npm Workspace 统一的依赖解析与链接</h4><h4 id=\"📚-npm-Workspace-核心机制：统一的依赖解析与链接-1\"><a href=\"#📚-npm-Workspace-核心机制：统一的依赖解析与链接-1\" class=\"headerlink\" title=\"📚 npm Workspace 核心机制：统一的依赖解析与链接\"></a>📚 npm Workspace 核心机制：统一的依赖解析与链接</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (<code>import ... from &#39;@scope/pkg&#39;</code>) 引用本地开发中的其他包，无需配置复杂路径别名。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>底层机制：符号链接 (Symlink) + Node.js 模块解析</strong></li>\n</ol>\n<p>这个“魔法”由两部分协同完成：</p>\n<ul>\n<li><p><strong>第一步：npm 创建符号链接 (Symlink)</strong></p>\n<ul>\n<li><strong>时机</strong>：运行 <code>npm install</code>（通常在根目录）。</li>\n<li><strong>操作</strong>：<ol>\n<li>npm 扫描所有包的 <code>dependencies</code>。</li>\n<li>发现 <code>packages/ui</code> 依赖 <code>@myorg/core</code>。</li>\n<li>识别到 <code>@myorg/core</code> 是一个 workspace 包（在 <code>workspaces</code> 数组中）。</li>\n<li>**在 <code>packages/ui/node_modules/@myorg/core</code> 创建一个符号链接 (软连接)**。</li>\n<li><strong>链接的目标</strong>：<code>../../core</code>（即 <code>packages/core</code> 的源码目录）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：<code>ui</code> 包的 <code>node_modules</code> 中有了一个指向 <code>core</code> 包源码的“快捷方式”。</li>\n</ul>\n</li>\n<li><p><strong>第二步：Node.js 解析模块</strong></p>\n<ul>\n<li><strong>时机</strong>：运行代码（<code>npm run dev</code>, <code>node app.js</code>），执行到 <code>import ... from &#39;@myorg/core&#39;</code>。</li>\n<li><strong>过程</strong>（遵循 Node.js 标准）：<ol>\n<li>从当前文件目录开始，向上查找 <code>node_modules</code>。</li>\n<li>在 <code>packages/ui/node_modules</code> 中找到 <code>@myorg/core</code>。</li>\n<li>发现它是一个<strong>符号链接</strong>。</li>\n<li><strong>跟随链接</strong>，跳转到 <code>packages/core</code> 目录。</li>\n<li>读取 <code>packages/core/package.json</code>，找到 <code>main</code>, <code>module</code>, <code>exports</code> 等字段。</li>\n<li>加载并执行字段指向的文件（如 <code>dist/index.js</code>）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：成功加载 <code>core</code> 包的代码，仿佛它就是一个安装好的 npm 包。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li><strong>关键特性与优势</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>开发体验统一</strong></td>\n<td align=\"left\">无论引用外部包 (<code>react</code>) 还是内部包 (<code>@myorg/core</code>)，代码写法完全一致：<code>import xxx from &#39;package-name&#39;</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>即时生效</strong></td>\n<td align=\"left\"><code>core</code> 包更新并<strong>重新构建</strong>后，<code>ui</code> 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>解耦</strong></td>\n<td align=\"left\"><code>ui</code> 包不关心 <code>core</code> 包的物理位置，只关心其包名和 API。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>可发布性</strong></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>零配置</strong></td>\n<td align=\"left\">无需在 <code>tsconfig.json</code> 中配置 <code>paths</code> 别名。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"4\">\n<li><p><strong>操作流程（依赖建立）</strong></p>\n</li>\n<li><p><strong>注册包</strong>：在根 <code>package.json</code> 的 <code>workspaces</code> 数组中定义包路径（如 <code>&quot;packages/*&quot;</code>）。</p>\n</li>\n<li><p><strong>声明依赖</strong>：在 <code>packages/ui/package.json</code> 的 <code>dependencies</code> 中添加 <code>&quot;@myorg/core&quot;: &quot;1.0.0&quot;</code>。</p>\n<ul>\n<li><strong>推荐命令</strong>：<code>npm install @myorg/core --workspace=packages/ui</code></li>\n</ul>\n</li>\n<li><p><strong>安装与链接</strong>：在根目录运行 <code>npm install</code>，创建符号链接。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">场景</th>\n<th align=\"left\">是否需要 <code>--workspace</code></th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>在 workspace 包目录内运行</strong></td>\n<td align=\"left\">❌ <strong>通常不需要</strong></td>\n<td align=\"left\">npm 能自动推断上下文。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>在根目录运行</strong></td>\n<td align=\"left\">✅ <strong>强烈建议使用</strong></td>\n<td align=\"left\">避免歧义，确保命令精确作用于目标包。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>添加新的 workspace 依赖</strong></td>\n<td align=\"left\">✅ <strong>推荐使用</strong></td>\n<td align=\"left\">最清晰、最安全的方式。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>构建被依赖包</strong>：确保 <code>packages/core</code> 已通过 <code>npm run build --workspace=packages/core</code> 构建出 <code>dist/</code>。（只要引用到代码就行）</p>\n</li>\n<li><p><strong>使用</strong>：在 <code>ui</code> 包代码中 <code>import ... from &#39;@myorg/core&#39;</code>。</p>\n</li>\n</ol>\n<hr>\n<ol start=\"5\">\n<li><strong>常见误区澄清</strong></li>\n</ol>\n<ul>\n<li><strong>误区</strong>：<code>&quot;dependencies&quot;: &#123; &quot;@myorg/core&quot;: &quot;workspace:*&quot; &#125;</code><ul>\n<li><strong>正解</strong>：❌ <strong>npm 不支持</strong>。这是 Yarn&#x2F;pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：每次 <code>core</code> 包更新都要改 <code>ui</code> 包的版本号。<ul>\n<li><strong>正解</strong>：❌ <strong>不需要</strong>。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：npm 会为 workspace 包“打包”或“下载”。<ul>\n<li><strong>正解</strong>：❌ <strong>不会</strong>。开发时是直接链接到本地文件，无打包下载过程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong></li>\n</ol>\n<blockquote>\n<p><strong>npm workspace 通过在依赖包的 <code>node_modules</code> 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，<code>import</code> 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。</strong></p>\n</blockquote>\n<h3 id=\"三、主要优势-1\"><a href=\"#三、主要优势-1\" class=\"headerlink\" title=\"三、主要优势\"></a>三、主要优势</h3><ol>\n<li><p><strong>依赖集中管理与优化</strong>：</p>\n<ul>\n<li>所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 <code>node_modules</code> 统一管理。</li>\n<li>npm 会进行依赖提升（hoist），避免重复安装，减少 <code>node_modules</code> 体积。</li>\n<li>不同 workspace 可以共享相同的依赖版本。</li>\n</ul>\n</li>\n<li><p><strong>简化跨包依赖</strong>：</p>\n<ul>\n<li>假设 <code>frontend</code> 需要使用 <code>utils</code> 包。</li>\n<li>在 <code>packages/frontend/package.json</code> 中，你可以直接这样写：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;utils&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span>  <span class=\"comment\">// 假设 utils 的 version 是 1.0.0</span></span><br><span class=\"line\">    <span class=\"comment\">// 或者使用 &quot;workspace:*&quot; 来引用最新的本地版本</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>npm 会自动将 <code>packages/utils</code> 链接到 <code>frontend</code> 的依赖中，<strong>无需发布到 npm registry</strong>。这极大地方便了本地开发和测试。</li>\n</ul>\n</li>\n<li><p><strong>批量操作</strong>：</p>\n<ul>\n<li>使用 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 标志可以对所有或特定 workspace 执行命令。</li>\n<li><strong>例子</strong>：<ul>\n<li><code>npm install</code>：安装所有 workspace 的依赖（包括它们之间的依赖）。</li>\n<li><code>npm run build --workspaces</code>：在所有 workspace 中运行 <code>build</code> 脚本。</li>\n<li><code>npm run test --workspace=packages/frontend</code>：只在 <code>frontend</code> workspace 中运行 <code>test</code> 脚本。</li>\n<li><code>npm exec --workspace=packages/backend vite</code>：在 <code>backend</code> 中执行 <code>vite</code> 命令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>版本同步与发布</strong>（需要额外工具）：</p>\n<ul>\n<li>虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 <code>lerna</code> 或 <code>nx</code> 那样），但它为这些工具提供了基础。你可以结合 <code>npm version</code> 和脚本管理多个包的版本。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、常用命令-1\"><a href=\"#四、常用命令-1\" class=\"headerlink\" title=\"四、常用命令\"></a>四、常用命令</h3><ul>\n<li><code>npm install</code>：在根目录运行，会安装所有 workspace 的依赖。</li>\n<li><code>npm run &lt;script&gt; --workspaces</code>：在所有 workspace 中运行指定脚本。</li>\n<li><code>npm run &lt;script&gt; --workspace=&lt;package-name&gt;</code>：在指定 workspace 中运行脚本。</li>\n<li><code>npm exec --workspace=&lt;package-name&gt; &lt;command&gt;</code>：在指定 workspace 中执行命令。</li>\n<li><code>npm ls --workspaces</code>：列出所有 workspace。</li>\n<li><code>npm publish --workspace=&lt;package-name&gt;</code>：发布指定的 workspace 包到 npm registry。</li>\n</ul>\n<hr>\n<h3 id=\"五、注意事项-1\"><a href=\"#五、注意事项-1\" class=\"headerlink\" title=\"五、注意事项\"></a>五、注意事项</h3><ol>\n<li><strong>npm 版本要求</strong>：必须使用 <strong>npm 7 或更高版本</strong>。</li>\n<li>**<code>private: true</code>**：根项目通常设置为 <code>private: true</code>，防止意外发布。</li>\n<li><strong>依赖解析</strong>：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。</li>\n<li><strong>与 <code>file:</code> 依赖的区别</strong>：过去常用 <code>file:../utils</code> 来引用本地包，但这种方式在发布时会有问题（<code>file:</code> 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。</li>\n<li><strong>不是唯一选择</strong>：还有其他优秀的 monorepo 工具，如 <code>pnpm</code>（其 workspace 功能非常强大且高效）、<code>yarn</code>（with Plug’n’Play）、<code>lerna</code>、<code>nx</code> 等。选择哪个取决于你的具体需求和偏好。</li>\n</ol>\n<hr>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>npm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。</p>\n<blockquote>\n<p>npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题 </p>\n</blockquote>\n","excerpt":"","more":"<p>npm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 <strong>monorepo</strong>（单体仓库）。</p>\n<p>简单来说，npm workspace 允许你在<strong>一个根项目</strong>中管理<strong>多个相互关联的子项目（包）</strong>，并让它们共享依赖、简化版本管理和跨包依赖。</p>\n<h3 id=\"一、核心概念\"><a href=\"#一、核心概念\" class=\"headerlink\" title=\"一、核心概念\"></a>一、核心概念</h3><ol>\n<li><p>**Monorepo (单体仓库)**：</p>\n<ul>\n<li>一个代码仓库中包含多个独立的包（packages）。</li>\n<li>例如：一个项目包含前端应用 (<code>packages/frontend</code>)、后端服务 (<code>packages/backend</code>)、共享工具库 (<code>packages/utils</code>)。</li>\n</ul>\n</li>\n<li><p><strong>Workspace</strong>：</p>\n<ul>\n<li>指 monorepo 中的一个子包。</li>\n<li>每个 workspace 都是一个独立的 npm 包，拥有自己的 <code>package.json</code> 文件。</li>\n</ul>\n</li>\n<li><p>**Root Project (根项目)**：</p>\n<ul>\n<li>包含所有 workspace 的顶层目录。</li>\n<li>它的 <code>package.json</code> 文件通过 <code>workspaces</code> 字段来声明和配置所有子 workspace。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"二、-npm-Workspace\"><a href=\"#二、-npm-Workspace\" class=\"headerlink\" title=\"二、 npm Workspace\"></a>二、 npm Workspace</h3><h4 id=\"1-📚-目录结构示例\"><a href=\"#1-📚-目录结构示例\" class=\"headerlink\" title=\"1. 📚 目录结构示例\"></a>1. 📚 目录结构示例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json          <span class=\"comment\"># 根项目的 package.json</span></span><br><span class=\"line\">├── packages/</span><br><span class=\"line\">│   ├── frontend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># frontend workspace</span></span><br><span class=\"line\">│   ├── backend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># backend workspace</span></span><br><span class=\"line\">│   └── utils/</span><br><span class=\"line\">│       └── package.json  <span class=\"comment\"># utils workspace (shared library)</span></span><br><span class=\"line\">└── node_modules/         <span class=\"comment\"># 所有依赖集中安装在这里（由根项目管理）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-📚-npm-Workspace-workspaces字段\"><a href=\"#2-📚-npm-Workspace-workspaces字段\" class=\"headerlink\" title=\"2. 📚 npm Workspace workspaces字段\"></a>2. 📚 npm Workspace <code>workspaces</code>字段</h4><blockquote>\n<p><strong>位置</strong>：根目录的 <code>package.json</code> 文件中。<br><strong>作用</strong>：声明哪些目录是需要被统一管理的“工作区包”。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 必须！防止根项目被意外发布</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;workspaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;packages/*&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">// 通配符：packages 下所有子目录</span></span><br><span class=\"line\">    <span class=\"string\">&quot;tools/cli&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">// 具体路径</span></span><br><span class=\"line\">    <span class=\"string\">&quot;examples/demo-app&quot;</span>     <span class=\"comment\">// 可以是深层嵌套路径</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li><p><strong>核心条件</strong>：一个目录要成为 workspace 包，必须同时满足：</p>\n<ol>\n<li>其路径被 <code>workspaces</code> 数组中的某个条目<strong>匹配到</strong>。</li>\n<li>该目录下<strong>存在 <code>package.json</code> 文件</strong>。</li>\n</ol>\n</li>\n<li><p><strong>嵌套路径处理</strong>：</p>\n<ul>\n<li><code>a/sub</code> 是 <code>a</code> 的子目录，<strong>物理上嵌套</strong>。</li>\n<li>但如果在 <code>workspaces</code> 中<strong>同时注册了 <code>&quot;a&quot;</code> 和 <code>&quot;a/sub&quot;</code><strong>，那么它们在 workspace 系统中是</strong>两个独立且平级的包</strong>。</li>\n<li><strong>注册即平等</strong>：被根 <code>workspaces</code> 直接列出的路径，都视为顶级管理单元。</li>\n</ul>\n</li>\n<li><p><strong>最佳实践 (Best Practices)</strong></p>\n<ul>\n<li>**根项目设为 <code>private: true</code>**。</li>\n<li><strong>避免在 workspace 包内部再用 <code>workspaces</code> 管理子包</strong>（易冲突）。</li>\n<li><strong>优先使用平铺结构</strong> (<code>packages/core</code>, <code>packages/ui</code>) 或<strong>明确列出路径</strong>。</li>\n<li><strong>利用 <code>exports</code> 字段</strong>进行精细导出，而非创建过多小包。</li>\n<li><strong>合理使用 <code>workspace:*</code></strong> 简化本地包依赖。</li>\n</ul>\n</li>\n<li><p><strong>一句话总结</strong></p>\n<blockquote>\n<p><strong><code>workspaces</code> 字段是“注册表”，将指定路径下的 <code>package.json</code> 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。</strong></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-📚-npm-Workspace-统一依赖管理\"><a href=\"#3-📚-npm-Workspace-统一依赖管理\" class=\"headerlink\" title=\"3. 📚 npm Workspace 统一依赖管理\"></a>3. 📚 npm Workspace 统一依赖管理</h4><ol>\n<li><p><strong>核心目标</strong></p>\n<blockquote>\n<p><strong>实现多包项目中依赖的高效共享、去重和版本统一，避免 <code>node_modules</code> 膨胀和版本冲突。</strong></p>\n</blockquote>\n</li>\n<li><p><strong>核心机制：依赖提升 (Dependency Hoisting)</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>定义</strong>：将所有 workspace 包的<strong>公共外部依赖</strong>，集中安装到<strong>根目录的 <code>node_modules</code></strong> 中。</li>\n<li><strong>触发</strong>：在根目录或任何 workspace 包内运行 <code>npm install</code>。</li>\n<li><strong>过程</strong>：<ol>\n<li>npm 扫描所有 <code>workspaces</code> 包的 <code>package.json</code>。</li>\n<li>收集所有 <code>dependencies</code> 和 <code>devDependencies</code>。</li>\n<li>进行版本解析，选择兼容的版本。</li>\n<li>将选中的外部包（如 <code>react</code>, <code>lodash</code>）<strong>只安装一份</strong>到 <code>根/node_modules</code>。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>实现方式：符号链接 (Symbolic Links &#x2F; Symlinks)</strong></li>\n</ol>\n<ul>\n<li><strong>位置</strong>：在<strong>每个 workspace 包的 <code>node_modules</code> 子目录内</strong>。</li>\n<li><strong>作用</strong>：为每个包“模拟”出它所需要的依赖。</li>\n<li><strong>方向</strong>：<ul>\n<li><strong>源</strong>：<code>packages/your-pkg/node_modules/lodash</code></li>\n<li><strong>目标</strong>：<code>../../../node_modules/lodash</code> (指向根目录的真实依赖)</li>\n</ul>\n</li>\n<li><strong>关键</strong>：链接是由 <strong>npm 自动创建</strong>的，对开发者透明。</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>文件系统结构示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── package-lock.json</span><br><span class=\"line\">├── node_modules/                     <span class=\"comment\"># 🎯 依赖的“中央仓库”</span></span><br><span class=\"line\">│   ├── lodash/                       <span class=\"comment\"># ✅ 真实的 lodash 包</span></span><br><span class=\"line\">│   └── react/                        <span class=\"comment\"># ✅ 真实的 react 包</span></span><br><span class=\"line\">└── packages/</span><br><span class=\"line\">    ├── core/</span><br><span class=\"line\">    │   ├── package.json</span><br><span class=\"line\">    │   └── node_modules/</span><br><span class=\"line\">    │       └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">    └── ui/</span><br><span class=\"line\">        ├── package.json</span><br><span class=\"line\">        └── node_modules/</span><br><span class=\"line\">            ├── react -&gt; ../../../node_modules/react    <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">            └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>工作流程 (Node.js 模块解析)</strong><br>当 <code>packages/ui</code> 执行 <code>require(&#39;react&#39;)</code>：</p>\n</li>\n<li><p>从 <code>packages/ui</code> 开始查找 <code>node_modules/react</code>。</p>\n</li>\n<li><p>找到 <code>packages/ui/node_modules/react</code> —— 这是一个<strong>符号链接</strong>。</p>\n</li>\n<li><p>系统跟随链接，定位到 <code>根/node_modules/react</code>。</p>\n</li>\n<li><p>加载并执行根目录中的真实 <code>react</code> 代码。</p>\n</li>\n<li><p><strong>关键优势</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">优势</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>去重</strong></td>\n<td align=\"left\">相同依赖只安装一份，节省磁盘空间。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>高效</strong></td>\n<td align=\"left\">安装速度更快，<code>node_modules</code> 体积显著减小。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>版本统一</strong></td>\n<td align=\"left\">npm 尽量使用单一版本，减少“依赖地狱”。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>开发友好</strong></td>\n<td align=\"left\">包间依赖通过链接直接引用源码，修改即时生效。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>在子目录安装依赖会发生什么？</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>绝大多数情况</strong> (<code>npm install lodash</code>)：<ul>\n<li>依赖被**提升到根 <code>node_modules</code>**。</li>\n<li>子目录的 <code>node_modules</code> 中创建<strong>指向根的符号链接</strong>。</li>\n</ul>\n</li>\n<li><strong>特殊情况（版本冲突）</strong>：<ul>\n<li>如果版本与其他包不兼容，npm <strong>可能</strong>会将该版本<strong>本地安装</strong>到子目录的 <code>node_modules</code>（真实代码，非链接）。</li>\n<li>这是 npm 为了解决冲突的“降级”方案，应尽量避免。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong>npm Workspace 通过“依赖提升”将所有外部依赖集中到根 <code>node_modules</code>，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"4-📚-npm-Workspace-统一脚本执行\"><a href=\"#4-📚-npm-Workspace-统一脚本执行\" class=\"headerlink\" title=\"4. 📚 npm Workspace 统一脚本执行\"></a>4. 📚 npm Workspace 统一脚本执行</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>三大命令模式</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">命令语法</th>\n<th align=\"left\">作用范围</th>\n<th align=\"left\">何时使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>局部执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt;</code></td>\n<td align=\"left\"><strong>仅当前目录</strong></td>\n<td align=\"left\">在单个包内进行开发、调试。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>批量执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspaces</code></td>\n<td align=\"left\"><strong>所有</strong>注册的 workspace 包</td>\n<td align=\"left\">构建、测试、检查整个项目。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>精准执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code></td>\n<td align=\"left\"><strong>指定的单个</strong> workspace 包</td>\n<td align=\"left\">只运行某个特定包的脚本。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"3\">\n<li><strong>命令详解</strong></li>\n</ol>\n<ul>\n<li><p><strong><code>npm run &lt;script&gt;</code> (无参数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：严格限定在<strong>当前所在目录</strong>的 <code>package.json</code>。</li>\n<li><strong>行为</strong>：查找并执行当前目录 <code>package.json</code> 中 <code>scripts</code> 字段定义的 <code>&lt;script&gt;</code>。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 packages/ui 目录下</span></span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只运行 ui 包的 dev 脚本</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>关键</strong>：这是<strong>默认行为</strong>，不涉及 workspace 管理。</li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspaces</code> (复数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>所有</strong>在根 <code>package.json</code> 的 <code>workspaces</code> 字段中声明的包。</li>\n<li><strong>行为</strong>：npm 会<strong>依次</strong>进入每个 workspace 包，并运行其 <code>package.json</code> 中对应的 <code>&lt;script&gt;</code>。</li>\n<li><strong>并行执行</strong>：添加 <code>--parallel</code> 可并行运行，速度更快：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run <span class=\"built_in\">test</span> --workspaces --parallel</span><br></pre></td></tr></table></figure></li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspaces  <span class=\"comment\"># 构建所有包</span></span><br><span class=\"line\">npm run lint --workspaces   <span class=\"comment\"># 检查所有包代码</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code> (单数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>仅</strong> <code>&lt;name&gt;</code> 指定的<strong>单个</strong> workspace 包。</li>\n<li><strong><code>&lt;name&gt;</code> 是什么？</strong><ul>\n<li>可以是包的<strong>相对路径</strong>（相对于根项目）：<code>packages/ui</code>, <code>tools/cli</code>。</li>\n<li>可以是包的<strong>名称</strong>（<code>package.json</code> 中的 <code>name</code> 字段）：<code>@myorg/core</code>, <code>my-ui-lib</code>。</li>\n</ul>\n</li>\n<li><strong>路径基准</strong>：<code>&lt;name&gt;</code> 是<strong>相对于根项目目录</strong>解析的。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspace=packages/ui</span><br><span class=\"line\">npm run dev --workspace=@myorg/frontend</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"4\">\n<li><strong>运行位置：灵活但有约定</strong></li>\n</ol>\n<ul>\n<li><strong>技术上</strong>：你可以在<strong>项目中的任何目录</strong>运行 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 命令。<ul>\n<li>npm 会自动<strong>向上查找</strong>，找到包含 <code>workspaces</code> 的根 <code>package.json</code>。</li>\n</ul>\n</li>\n<li><strong>实践上</strong>：<strong>强烈建议在根目录运行</strong>这些命令。<ul>\n<li><strong>原因</strong>：<ol>\n<li><strong>意图清晰</strong>：明确表示“我要管理整个项目”。</li>\n<li><strong>避免混淆</strong>：防止误以为命令只与当前包有关。</li>\n<li><strong>符合脚本</strong>：根 <code>package.json</code> 中的聚合脚本（如 <code>&quot;build&quot;: &quot;npm run build --workspaces&quot;</code>）必须在根目录运行。</li>\n<li><strong>团队一致</strong>：建立统一的操作规范。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"5\">\n<li><p><strong>最佳实践</strong></p>\n</li>\n<li><p><strong>在根 <code>package.json</code> 中定义聚合脚本</strong>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run build --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;test&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run test --workspaces --parallel&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run lint --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:ui&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/ui&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:api&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/api&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>始终在根目录运行聚合命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build  <span class=\"comment\"># 调用根脚本</span></span><br><span class=\"line\">npm run <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>在包内进行开发时使用局部命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> packages/ui</span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只启动 UI 开发服务器</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong><code>npm run</code> 默认只作用于当前包；添加 <code>--workspaces</code> 可批量操作所有包，添加 <code>--workspace=&lt;name&gt;</code> 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"5-📚-npm-Workspace-统一的依赖解析与链接\"><a href=\"#5-📚-npm-Workspace-统一的依赖解析与链接\" class=\"headerlink\" title=\"5. 📚 npm Workspace 统一的依赖解析与链接\"></a>5. 📚 npm Workspace 统一的依赖解析与链接</h4><h4 id=\"📚-npm-Workspace-核心机制：统一的依赖解析与链接\"><a href=\"#📚-npm-Workspace-核心机制：统一的依赖解析与链接\" class=\"headerlink\" title=\"📚 npm Workspace 核心机制：统一的依赖解析与链接\"></a>📚 npm Workspace 核心机制：统一的依赖解析与链接</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (<code>import ... from &#39;@scope/pkg&#39;</code>) 引用本地开发中的其他包，无需配置复杂路径别名。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>底层机制：符号链接 (Symlink) + Node.js 模块解析</strong></li>\n</ol>\n<p>这个“魔法”由两部分协同完成：</p>\n<ul>\n<li><p><strong>第一步：npm 创建符号链接 (Symlink)</strong></p>\n<ul>\n<li><strong>时机</strong>：运行 <code>npm install</code>（通常在根目录）。</li>\n<li><strong>操作</strong>：<ol>\n<li>npm 扫描所有包的 <code>dependencies</code>。</li>\n<li>发现 <code>packages/ui</code> 依赖 <code>@myorg/core</code>。</li>\n<li>识别到 <code>@myorg/core</code> 是一个 workspace 包（在 <code>workspaces</code> 数组中）。</li>\n<li>**在 <code>packages/ui/node_modules/@myorg/core</code> 创建一个符号链接 (软连接)**。</li>\n<li><strong>链接的目标</strong>：<code>../../core</code>（即 <code>packages/core</code> 的源码目录）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：<code>ui</code> 包的 <code>node_modules</code> 中有了一个指向 <code>core</code> 包源码的“快捷方式”。</li>\n</ul>\n</li>\n<li><p><strong>第二步：Node.js 解析模块</strong></p>\n<ul>\n<li><strong>时机</strong>：运行代码（<code>npm run dev</code>, <code>node app.js</code>），执行到 <code>import ... from &#39;@myorg/core&#39;</code>。</li>\n<li><strong>过程</strong>（遵循 Node.js 标准）：<ol>\n<li>从当前文件目录开始，向上查找 <code>node_modules</code>。</li>\n<li>在 <code>packages/ui/node_modules</code> 中找到 <code>@myorg/core</code>。</li>\n<li>发现它是一个<strong>符号链接</strong>。</li>\n<li><strong>跟随链接</strong>，跳转到 <code>packages/core</code> 目录。</li>\n<li>读取 <code>packages/core/package.json</code>，找到 <code>main</code>, <code>module</code>, <code>exports</code> 等字段。</li>\n<li>加载并执行字段指向的文件（如 <code>dist/index.js</code>）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：成功加载 <code>core</code> 包的代码，仿佛它就是一个安装好的 npm 包。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li><strong>关键特性与优势</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>开发体验统一</strong></td>\n<td align=\"left\">无论引用外部包 (<code>react</code>) 还是内部包 (<code>@myorg/core</code>)，代码写法完全一致：<code>import xxx from &#39;package-name&#39;</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>即时生效</strong></td>\n<td align=\"left\"><code>core</code> 包更新并<strong>重新构建</strong>后，<code>ui</code> 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>解耦</strong></td>\n<td align=\"left\"><code>ui</code> 包不关心 <code>core</code> 包的物理位置，只关心其包名和 API。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>可发布性</strong></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>零配置</strong></td>\n<td align=\"left\">无需在 <code>tsconfig.json</code> 中配置 <code>paths</code> 别名。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"4\">\n<li><p><strong>操作流程（依赖建立）</strong></p>\n</li>\n<li><p><strong>注册包</strong>：在根 <code>package.json</code> 的 <code>workspaces</code> 数组中定义包路径（如 <code>&quot;packages/*&quot;</code>）。</p>\n</li>\n<li><p><strong>声明依赖</strong>：在 <code>packages/ui/package.json</code> 的 <code>dependencies</code> 中添加 <code>&quot;@myorg/core&quot;: &quot;1.0.0&quot;</code>。</p>\n<ul>\n<li><strong>推荐命令</strong>：<code>npm install @myorg/core --workspace=packages/ui</code></li>\n</ul>\n</li>\n<li><p><strong>安装与链接</strong>：在根目录运行 <code>npm install</code>，创建符号链接。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">场景</th>\n<th align=\"left\">是否需要 <code>--workspace</code></th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>在 workspace 包目录内运行</strong></td>\n<td align=\"left\">❌ <strong>通常不需要</strong></td>\n<td align=\"left\">npm 能自动推断上下文。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>在根目录运行</strong></td>\n<td align=\"left\">✅ <strong>强烈建议使用</strong></td>\n<td align=\"left\">避免歧义，确保命令精确作用于目标包。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>添加新的 workspace 依赖</strong></td>\n<td align=\"left\">✅ <strong>推荐使用</strong></td>\n<td align=\"left\">最清晰、最安全的方式。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>构建被依赖包</strong>：确保 <code>packages/core</code> 已通过 <code>npm run build --workspace=packages/core</code> 构建出 <code>dist/</code>。（只要引用到代码就行）</p>\n</li>\n<li><p><strong>使用</strong>：在 <code>ui</code> 包代码中 <code>import ... from &#39;@myorg/core&#39;</code>。</p>\n</li>\n</ol>\n<hr>\n<ol start=\"5\">\n<li><strong>常见误区澄清</strong></li>\n</ol>\n<ul>\n<li><strong>误区</strong>：<code>&quot;dependencies&quot;: &#123; &quot;@myorg/core&quot;: &quot;workspace:*&quot; &#125;</code><ul>\n<li><strong>正解</strong>：❌ <strong>npm 不支持</strong>。这是 Yarn&#x2F;pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：每次 <code>core</code> 包更新都要改 <code>ui</code> 包的版本号。<ul>\n<li><strong>正解</strong>：❌ <strong>不需要</strong>。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：npm 会为 workspace 包“打包”或“下载”。<ul>\n<li><strong>正解</strong>：❌ <strong>不会</strong>。开发时是直接链接到本地文件，无打包下载过程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong></li>\n</ol>\n<blockquote>\n<p><strong>npm workspace 通过在依赖包的 <code>node_modules</code> 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，<code>import</code> 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。</strong></p>\n</blockquote>\n<h3 id=\"三、主要优势\"><a href=\"#三、主要优势\" class=\"headerlink\" title=\"三、主要优势\"></a>三、主要优势</h3><ol>\n<li><p><strong>依赖集中管理与优化</strong>：</p>\n<ul>\n<li>所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 <code>node_modules</code> 统一管理。</li>\n<li>npm 会进行依赖提升（hoist），避免重复安装，减少 <code>node_modules</code> 体积。</li>\n<li>不同 workspace 可以共享相同的依赖版本。</li>\n</ul>\n</li>\n<li><p><strong>简化跨包依赖</strong>：</p>\n<ul>\n<li>假设 <code>frontend</code> 需要使用 <code>utils</code> 包。</li>\n<li>在 <code>packages/frontend/package.json</code> 中，你可以直接这样写：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;utils&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span>  <span class=\"comment\">// 假设 utils 的 version 是 1.0.0</span></span><br><span class=\"line\">    <span class=\"comment\">// 或者使用 &quot;workspace:*&quot; 来引用最新的本地版本</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>npm 会自动将 <code>packages/utils</code> 链接到 <code>frontend</code> 的依赖中，<strong>无需发布到 npm registry</strong>。这极大地方便了本地开发和测试。</li>\n</ul>\n</li>\n<li><p><strong>批量操作</strong>：</p>\n<ul>\n<li>使用 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 标志可以对所有或特定 workspace 执行命令。</li>\n<li><strong>例子</strong>：<ul>\n<li><code>npm install</code>：安装所有 workspace 的依赖（包括它们之间的依赖）。</li>\n<li><code>npm run build --workspaces</code>：在所有 workspace 中运行 <code>build</code> 脚本。</li>\n<li><code>npm run test --workspace=packages/frontend</code>：只在 <code>frontend</code> workspace 中运行 <code>test</code> 脚本。</li>\n<li><code>npm exec --workspace=packages/backend vite</code>：在 <code>backend</code> 中执行 <code>vite</code> 命令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>版本同步与发布</strong>（需要额外工具）：</p>\n<ul>\n<li>虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 <code>lerna</code> 或 <code>nx</code> 那样），但它为这些工具提供了基础。你可以结合 <code>npm version</code> 和脚本管理多个包的版本。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、常用命令\"><a href=\"#四、常用命令\" class=\"headerlink\" title=\"四、常用命令\"></a>四、常用命令</h3><ul>\n<li><code>npm install</code>：在根目录运行，会安装所有 workspace 的依赖。</li>\n<li><code>npm run &lt;script&gt; --workspaces</code>：在所有 workspace 中运行指定脚本。</li>\n<li><code>npm run &lt;script&gt; --workspace=&lt;package-name&gt;</code>：在指定 workspace 中运行脚本。</li>\n<li><code>npm exec --workspace=&lt;package-name&gt; &lt;command&gt;</code>：在指定 workspace 中执行命令。</li>\n<li><code>npm ls --workspaces</code>：列出所有 workspace。</li>\n<li><code>npm publish --workspace=&lt;package-name&gt;</code>：发布指定的 workspace 包到 npm registry。</li>\n</ul>\n<hr>\n<h3 id=\"五、注意事项\"><a href=\"#五、注意事项\" class=\"headerlink\" title=\"五、注意事项\"></a>五、注意事项</h3><ol>\n<li><strong>npm 版本要求</strong>：必须使用 <strong>npm 7 或更高版本</strong>。</li>\n<li>**<code>private: true</code>**：根项目通常设置为 <code>private: true</code>，防止意外发布。</li>\n<li><strong>依赖解析</strong>：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。</li>\n<li><strong>与 <code>file:</code> 依赖的区别</strong>：过去常用 <code>file:../utils</code> 来引用本地包，但这种方式在发布时会有问题（<code>file:</code> 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。</li>\n<li><strong>不是唯一选择</strong>：还有其他优秀的 monorepo 工具，如 <code>pnpm</code>（其 workspace 功能非常强大且高效）、<code>yarn</code>（with Plug’n’Play）、<code>lerna</code>、<code>nx</code> 等。选择哪个取决于你的具体需求和偏好。</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>npm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。</p>\n<blockquote>\n<p>npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题<br>看起来您可能想了解的是 npm 的 <strong>workspace</strong>（工作区）功能，而不是“workplace”。npm workspace 是从 npm 7 开始引入的一个强大特性，用于管理包含多个相互依赖的包（packages）的大型项目，通常称为 <strong>monorepo</strong>（单体仓库）。</p>\n</blockquote>\n<p>简单来说，npm workspace 允许你在<strong>一个根项目</strong>中管理<strong>多个相互关联的子项目（包）</strong>，并让它们共享依赖、简化版本管理和跨包依赖。</p>\n<hr>\n<h3 id=\"一、核心概念-1\"><a href=\"#一、核心概念-1\" class=\"headerlink\" title=\"一、核心概念\"></a>一、核心概念</h3><ol>\n<li><p>**Monorepo (单体仓库)**：</p>\n<ul>\n<li>一个代码仓库中包含多个独立的包（packages）。</li>\n<li>例如：一个项目包含前端应用 (<code>packages/frontend</code>)、后端服务 (<code>packages/backend</code>)、共享工具库 (<code>packages/utils</code>)。</li>\n</ul>\n</li>\n<li><p><strong>Workspace</strong>：</p>\n<ul>\n<li>指 monorepo 中的一个子包。</li>\n<li>每个 workspace 都是一个独立的 npm 包，拥有自己的 <code>package.json</code> 文件。</li>\n</ul>\n</li>\n<li><p>**Root Project (根项目)**：</p>\n<ul>\n<li>包含所有 workspace 的顶层目录。</li>\n<li>它的 <code>package.json</code> 文件通过 <code>workspaces</code> 字段来声明和配置所有子 workspace。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"二、如何配置-npm-Workspace\"><a href=\"#二、如何配置-npm-Workspace\" class=\"headerlink\" title=\"二、如何配置 npm Workspace\"></a>二、如何配置 npm Workspace</h3><h4 id=\"1-📚-目录结构示例-1\"><a href=\"#1-📚-目录结构示例-1\" class=\"headerlink\" title=\"1. 📚 目录结构示例\"></a>1. 📚 目录结构示例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json          <span class=\"comment\"># 根项目的 package.json</span></span><br><span class=\"line\">├── packages/</span><br><span class=\"line\">│   ├── frontend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># frontend workspace</span></span><br><span class=\"line\">│   ├── backend/</span><br><span class=\"line\">│   │   └── package.json  <span class=\"comment\"># backend workspace</span></span><br><span class=\"line\">│   └── utils/</span><br><span class=\"line\">│       └── package.json  <span class=\"comment\"># utils workspace (shared library)</span></span><br><span class=\"line\">└── node_modules/         <span class=\"comment\"># 所有依赖集中安装在这里（由根项目管理）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-📚-npm-Workspace-workspaces字段-1\"><a href=\"#2-📚-npm-Workspace-workspaces字段-1\" class=\"headerlink\" title=\"2. 📚 npm Workspace workspaces字段\"></a>2. 📚 npm Workspace <code>workspaces</code>字段</h4><blockquote>\n<p><strong>位置</strong>：根目录的 <code>package.json</code> 文件中。<br><strong>作用</strong>：声明哪些目录是需要被统一管理的“工作区包”。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 必须！防止根项目被意外发布</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;workspaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;packages/*&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">// 通配符：packages 下所有子目录</span></span><br><span class=\"line\">    <span class=\"string\">&quot;tools/cli&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">// 具体路径</span></span><br><span class=\"line\">    <span class=\"string\">&quot;examples/demo-app&quot;</span>     <span class=\"comment\">// 可以是深层嵌套路径</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li><p><strong>核心条件</strong>：一个目录要成为 workspace 包，必须同时满足：</p>\n<ol>\n<li>其路径被 <code>workspaces</code> 数组中的某个条目<strong>匹配到</strong>。</li>\n<li>该目录下<strong>存在 <code>package.json</code> 文件</strong>。</li>\n</ol>\n</li>\n<li><p><strong>嵌套路径处理</strong>：</p>\n<ul>\n<li><code>a/sub</code> 是 <code>a</code> 的子目录，<strong>物理上嵌套</strong>。</li>\n<li>但如果在 <code>workspaces</code> 中<strong>同时注册了 <code>&quot;a&quot;</code> 和 <code>&quot;a/sub&quot;</code><strong>，那么它们在 workspace 系统中是</strong>两个独立且平级的包</strong>。</li>\n<li><strong>注册即平等</strong>：被根 <code>workspaces</code> 直接列出的路径，都视为顶级管理单元。</li>\n</ul>\n</li>\n<li><p><strong>最佳实践 (Best Practices)</strong></p>\n<ul>\n<li>**根项目设为 <code>private: true</code>**。</li>\n<li><strong>避免在 workspace 包内部再用 <code>workspaces</code> 管理子包</strong>（易冲突）。</li>\n<li><strong>优先使用平铺结构</strong> (<code>packages/core</code>, <code>packages/ui</code>) 或<strong>明确列出路径</strong>。</li>\n<li><strong>利用 <code>exports</code> 字段</strong>进行精细导出，而非创建过多小包。</li>\n<li><strong>合理使用 <code>workspace:*</code></strong> 简化本地包依赖。</li>\n</ul>\n</li>\n<li><p><strong>一句话总结</strong></p>\n<blockquote>\n<p><strong><code>workspaces</code> 字段是“注册表”，将指定路径下的 <code>package.json</code> 目录注册为独立包；npm 通过依赖提升和符号链接，实现高效、统一的多包项目管理。物理路径的嵌套不影响逻辑上的平级管理。</strong></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-📚-npm-Workspace-统一依赖管理-1\"><a href=\"#3-📚-npm-Workspace-统一依赖管理-1\" class=\"headerlink\" title=\"3. 📚 npm Workspace 统一依赖管理\"></a>3. 📚 npm Workspace 统一依赖管理</h4><ol>\n<li><p><strong>核心目标</strong></p>\n<blockquote>\n<p><strong>实现多包项目中依赖的高效共享、去重和版本统一，避免 <code>node_modules</code> 膨胀和版本冲突。</strong></p>\n</blockquote>\n</li>\n<li><p><strong>核心机制：依赖提升 (Dependency Hoisting)</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>定义</strong>：将所有 workspace 包的<strong>公共外部依赖</strong>，集中安装到<strong>根目录的 <code>node_modules</code></strong> 中。</li>\n<li><strong>触发</strong>：在根目录或任何 workspace 包内运行 <code>npm install</code>。</li>\n<li><strong>过程</strong>：<ol>\n<li>npm 扫描所有 <code>workspaces</code> 包的 <code>package.json</code>。</li>\n<li>收集所有 <code>dependencies</code> 和 <code>devDependencies</code>。</li>\n<li>进行版本解析，选择兼容的版本。</li>\n<li>将选中的外部包（如 <code>react</code>, <code>lodash</code>）<strong>只安装一份</strong>到 <code>根/node_modules</code>。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>实现方式：符号链接 (Symbolic Links &#x2F; Symlinks)</strong></li>\n</ol>\n<ul>\n<li><strong>位置</strong>：在<strong>每个 workspace 包的 <code>node_modules</code> 子目录内</strong>。</li>\n<li><strong>作用</strong>：为每个包“模拟”出它所需要的依赖。</li>\n<li><strong>方向</strong>：<ul>\n<li><strong>源</strong>：<code>packages/your-pkg/node_modules/lodash</code></li>\n<li><strong>目标</strong>：<code>../../../node_modules/lodash</code> (指向根目录的真实依赖)</li>\n</ul>\n</li>\n<li><strong>关键</strong>：链接是由 <strong>npm 自动创建</strong>的，对开发者透明。</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>文件系统结构示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── package-lock.json</span><br><span class=\"line\">├── node_modules/                     <span class=\"comment\"># 🎯 依赖的“中央仓库”</span></span><br><span class=\"line\">│   ├── lodash/                       <span class=\"comment\"># ✅ 真实的 lodash 包</span></span><br><span class=\"line\">│   └── react/                        <span class=\"comment\"># ✅ 真实的 react 包</span></span><br><span class=\"line\">└── packages/</span><br><span class=\"line\">    ├── core/</span><br><span class=\"line\">    │   ├── package.json</span><br><span class=\"line\">    │   └── node_modules/</span><br><span class=\"line\">    │       └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">    └── ui/</span><br><span class=\"line\">        ├── package.json</span><br><span class=\"line\">        └── node_modules/</span><br><span class=\"line\">            ├── react -&gt; ../../../node_modules/react    <span class=\"comment\"># 🔗 符号链接</span></span><br><span class=\"line\">            └── lodash -&gt; ../../../node_modules/lodash  <span class=\"comment\"># 🔗 符号链接</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>工作流程 (Node.js 模块解析)</strong><br>当 <code>packages/ui</code> 执行 <code>require(&#39;react&#39;)</code>：</p>\n</li>\n<li><p>从 <code>packages/ui</code> 开始查找 <code>node_modules/react</code>。</p>\n</li>\n<li><p>找到 <code>packages/ui/node_modules/react</code> —— 这是一个<strong>符号链接</strong>。</p>\n</li>\n<li><p>系统跟随链接，定位到 <code>根/node_modules/react</code>。</p>\n</li>\n<li><p>加载并执行根目录中的真实 <code>react</code> 代码。</p>\n</li>\n<li><p><strong>关键优势</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">优势</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>去重</strong></td>\n<td align=\"left\">相同依赖只安装一份，节省磁盘空间。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>高效</strong></td>\n<td align=\"left\">安装速度更快，<code>node_modules</code> 体积显著减小。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>版本统一</strong></td>\n<td align=\"left\">npm 尽量使用单一版本，减少“依赖地狱”。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>开发友好</strong></td>\n<td align=\"left\">包间依赖通过链接直接引用源码，修改即时生效。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>在子目录安装依赖会发生什么？</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>绝大多数情况</strong> (<code>npm install lodash</code>)：<ul>\n<li>依赖被**提升到根 <code>node_modules</code>**。</li>\n<li>子目录的 <code>node_modules</code> 中创建<strong>指向根的符号链接</strong>。</li>\n</ul>\n</li>\n<li><strong>特殊情况（版本冲突）</strong>：<ul>\n<li>如果版本与其他包不兼容，npm <strong>可能</strong>会将该版本<strong>本地安装</strong>到子目录的 <code>node_modules</code>（真实代码，非链接）。</li>\n<li>这是 npm 为了解决冲突的“降级”方案，应尽量避免。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong>npm Workspace 通过“依赖提升”将所有外部依赖集中到根 <code>node_modules</code>，再通过“符号链接”让每个 workspace 包都能访问到这些共享依赖，从而实现高效、统一的依赖管理。你在任何地方安装，最终大多都会变成指向根目录的软链接。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"4-📚-npm-Workspace-统一脚本执行-1\"><a href=\"#4-📚-npm-Workspace-统一脚本执行-1\" class=\"headerlink\" title=\"4. 📚 npm Workspace 统一脚本执行\"></a>4. 📚 npm Workspace 统一脚本执行</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现对多个 workspace 包的批量或精准脚本控制，提升开发效率，避免手动进入每个包执行命令。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>三大命令模式</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">命令语法</th>\n<th align=\"left\">作用范围</th>\n<th align=\"left\">何时使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>局部执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt;</code></td>\n<td align=\"left\"><strong>仅当前目录</strong></td>\n<td align=\"left\">在单个包内进行开发、调试。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>批量执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspaces</code></td>\n<td align=\"left\"><strong>所有</strong>注册的 workspace 包</td>\n<td align=\"left\">构建、测试、检查整个项目。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>精准执行</strong></td>\n<td align=\"left\"><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code></td>\n<td align=\"left\"><strong>指定的单个</strong> workspace 包</td>\n<td align=\"left\">只运行某个特定包的脚本。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"3\">\n<li><strong>命令详解</strong></li>\n</ol>\n<ul>\n<li><p><strong><code>npm run &lt;script&gt;</code> (无参数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：严格限定在<strong>当前所在目录</strong>的 <code>package.json</code>。</li>\n<li><strong>行为</strong>：查找并执行当前目录 <code>package.json</code> 中 <code>scripts</code> 字段定义的 <code>&lt;script&gt;</code>。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 packages/ui 目录下</span></span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只运行 ui 包的 dev 脚本</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>关键</strong>：这是<strong>默认行为</strong>，不涉及 workspace 管理。</li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspaces</code> (复数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>所有</strong>在根 <code>package.json</code> 的 <code>workspaces</code> 字段中声明的包。</li>\n<li><strong>行为</strong>：npm 会<strong>依次</strong>进入每个 workspace 包，并运行其 <code>package.json</code> 中对应的 <code>&lt;script&gt;</code>。</li>\n<li><strong>并行执行</strong>：添加 <code>--parallel</code> 可并行运行，速度更快：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run <span class=\"built_in\">test</span> --workspaces --parallel</span><br></pre></td></tr></table></figure></li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspaces  <span class=\"comment\"># 构建所有包</span></span><br><span class=\"line\">npm run lint --workspaces   <span class=\"comment\"># 检查所有包代码</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong><code>npm run &lt;script&gt; --workspace=&lt;name&gt;</code> (单数)</strong></p>\n<ul>\n<li><strong>作用域</strong>：<strong>仅</strong> <code>&lt;name&gt;</code> 指定的<strong>单个</strong> workspace 包。</li>\n<li><strong><code>&lt;name&gt;</code> 是什么？</strong><ul>\n<li>可以是包的<strong>相对路径</strong>（相对于根项目）：<code>packages/ui</code>, <code>tools/cli</code>。</li>\n<li>可以是包的<strong>名称</strong>（<code>package.json</code> 中的 <code>name</code> 字段）：<code>@myorg/core</code>, <code>my-ui-lib</code>。</li>\n</ul>\n</li>\n<li><strong>路径基准</strong>：<code>&lt;name&gt;</code> 是<strong>相对于根项目目录</strong>解析的。</li>\n<li><strong>示例</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build --workspace=packages/ui</span><br><span class=\"line\">npm run dev --workspace=@myorg/frontend</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"4\">\n<li><strong>运行位置：灵活但有约定</strong></li>\n</ol>\n<ul>\n<li><strong>技术上</strong>：你可以在<strong>项目中的任何目录</strong>运行 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 命令。<ul>\n<li>npm 会自动<strong>向上查找</strong>，找到包含 <code>workspaces</code> 的根 <code>package.json</code>。</li>\n</ul>\n</li>\n<li><strong>实践上</strong>：<strong>强烈建议在根目录运行</strong>这些命令。<ul>\n<li><strong>原因</strong>：<ol>\n<li><strong>意图清晰</strong>：明确表示“我要管理整个项目”。</li>\n<li><strong>避免混淆</strong>：防止误以为命令只与当前包有关。</li>\n<li><strong>符合脚本</strong>：根 <code>package.json</code> 中的聚合脚本（如 <code>&quot;build&quot;: &quot;npm run build --workspaces&quot;</code>）必须在根目录运行。</li>\n<li><strong>团队一致</strong>：建立统一的操作规范。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"5\">\n<li><p><strong>最佳实践</strong></p>\n</li>\n<li><p><strong>在根 <code>package.json</code> 中定义聚合脚本</strong>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run build --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;test&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run test --workspaces --parallel&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run lint --workspaces&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:ui&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/ui&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dev:api&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;npm run dev --workspace=packages/api&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>始终在根目录运行聚合命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build  <span class=\"comment\"># 调用根脚本</span></span><br><span class=\"line\">npm run <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>在包内进行开发时使用局部命令</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> packages/ui</span><br><span class=\"line\">npm run dev  <span class=\"comment\"># 只启动 UI 开发服务器</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong><blockquote>\n<p><strong><code>npm run</code> 默认只作用于当前包；添加 <code>--workspaces</code> 可批量操作所有包，添加 <code>--workspace=&lt;name&gt;</code> 可精准控制单个包。虽然命令可在任意位置执行，但为清晰和一致，应始终在根目录进行统一管理。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h4 id=\"5-📚-npm-Workspace-统一的依赖解析与链接-1\"><a href=\"#5-📚-npm-Workspace-统一的依赖解析与链接-1\" class=\"headerlink\" title=\"5. 📚 npm Workspace 统一的依赖解析与链接\"></a>5. 📚 npm Workspace 统一的依赖解析与链接</h4><h4 id=\"📚-npm-Workspace-核心机制：统一的依赖解析与链接-1\"><a href=\"#📚-npm-Workspace-核心机制：统一的依赖解析与链接-1\" class=\"headerlink\" title=\"📚 npm Workspace 核心机制：统一的依赖解析与链接\"></a>📚 npm Workspace 核心机制：统一的依赖解析与链接</h4><ol>\n<li><strong>核心目标</strong><blockquote>\n<p><strong>实现 workspace 内部包之间的无缝引用，让开发者能像使用 npm 包一样，直接通过包名 (<code>import ... from &#39;@scope/pkg&#39;</code>) 引用本地开发中的其他包，无需配置复杂路径别名。</strong></p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li><strong>底层机制：符号链接 (Symlink) + Node.js 模块解析</strong></li>\n</ol>\n<p>这个“魔法”由两部分协同完成：</p>\n<ul>\n<li><p><strong>第一步：npm 创建符号链接 (Symlink)</strong></p>\n<ul>\n<li><strong>时机</strong>：运行 <code>npm install</code>（通常在根目录）。</li>\n<li><strong>操作</strong>：<ol>\n<li>npm 扫描所有包的 <code>dependencies</code>。</li>\n<li>发现 <code>packages/ui</code> 依赖 <code>@myorg/core</code>。</li>\n<li>识别到 <code>@myorg/core</code> 是一个 workspace 包（在 <code>workspaces</code> 数组中）。</li>\n<li>**在 <code>packages/ui/node_modules/@myorg/core</code> 创建一个符号链接 (软连接)**。</li>\n<li><strong>链接的目标</strong>：<code>../../core</code>（即 <code>packages/core</code> 的源码目录）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：<code>ui</code> 包的 <code>node_modules</code> 中有了一个指向 <code>core</code> 包源码的“快捷方式”。</li>\n</ul>\n</li>\n<li><p><strong>第二步：Node.js 解析模块</strong></p>\n<ul>\n<li><strong>时机</strong>：运行代码（<code>npm run dev</code>, <code>node app.js</code>），执行到 <code>import ... from &#39;@myorg/core&#39;</code>。</li>\n<li><strong>过程</strong>（遵循 Node.js 标准）：<ol>\n<li>从当前文件目录开始，向上查找 <code>node_modules</code>。</li>\n<li>在 <code>packages/ui/node_modules</code> 中找到 <code>@myorg/core</code>。</li>\n<li>发现它是一个<strong>符号链接</strong>。</li>\n<li><strong>跟随链接</strong>，跳转到 <code>packages/core</code> 目录。</li>\n<li>读取 <code>packages/core/package.json</code>，找到 <code>main</code>, <code>module</code>, <code>exports</code> 等字段。</li>\n<li>加载并执行字段指向的文件（如 <code>dist/index.js</code>）。</li>\n</ol>\n</li>\n<li><strong>结果</strong>：成功加载 <code>core</code> 包的代码，仿佛它就是一个安装好的 npm 包。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li><strong>关键特性与优势</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>开发体验统一</strong></td>\n<td align=\"left\">无论引用外部包 (<code>react</code>) 还是内部包 (<code>@myorg/core</code>)，代码写法完全一致：<code>import xxx from &#39;package-name&#39;</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>即时生效</strong></td>\n<td align=\"left\"><code>core</code> 包更新并<strong>重新构建</strong>后，<code>ui</code> 包在下次运行时就能使用最新代码（符号链接指向的内容已更新）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>解耦</strong></td>\n<td align=\"left\"><code>ui</code> 包不关心 <code>core</code> 包的物理位置，只关心其包名和 API。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>可发布性</strong></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>零配置</strong></td>\n<td align=\"left\">无需在 <code>tsconfig.json</code> 中配置 <code>paths</code> 别名。</td>\n</tr>\n</tbody></table>\n<hr>\n<ol start=\"4\">\n<li><p><strong>操作流程（依赖建立）</strong></p>\n</li>\n<li><p><strong>注册包</strong>：在根 <code>package.json</code> 的 <code>workspaces</code> 数组中定义包路径（如 <code>&quot;packages/*&quot;</code>）。</p>\n</li>\n<li><p><strong>声明依赖</strong>：在 <code>packages/ui/package.json</code> 的 <code>dependencies</code> 中添加 <code>&quot;@myorg/core&quot;: &quot;1.0.0&quot;</code>。</p>\n<ul>\n<li><strong>推荐命令</strong>：<code>npm install @myorg/core --workspace=packages/ui</code></li>\n</ul>\n</li>\n<li><p><strong>安装与链接</strong>：在根目录运行 <code>npm install</code>，创建符号链接。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">场景</th>\n<th align=\"left\">是否需要 <code>--workspace</code></th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>在 workspace 包目录内运行</strong></td>\n<td align=\"left\">❌ <strong>通常不需要</strong></td>\n<td align=\"left\">npm 能自动推断上下文。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>在根目录运行</strong></td>\n<td align=\"left\">✅ <strong>强烈建议使用</strong></td>\n<td align=\"left\">避免歧义，确保命令精确作用于目标包。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>添加新的 workspace 依赖</strong></td>\n<td align=\"left\">✅ <strong>推荐使用</strong></td>\n<td align=\"left\">最清晰、最安全的方式。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>构建被依赖包</strong>：确保 <code>packages/core</code> 已通过 <code>npm run build --workspace=packages/core</code> 构建出 <code>dist/</code>。（只要引用到代码就行）</p>\n</li>\n<li><p><strong>使用</strong>：在 <code>ui</code> 包代码中 <code>import ... from &#39;@myorg/core&#39;</code>。</p>\n</li>\n</ol>\n<hr>\n<ol start=\"5\">\n<li><strong>常见误区澄清</strong></li>\n</ol>\n<ul>\n<li><strong>误区</strong>：<code>&quot;dependencies&quot;: &#123; &quot;@myorg/core&quot;: &quot;workspace:*&quot; &#125;</code><ul>\n<li><strong>正解</strong>：❌ <strong>npm 不支持</strong>。这是 Yarn&#x2F;pnpm 的语法。npm 使用隐式链接，只需写实际包名和版本。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：每次 <code>core</code> 包更新都要改 <code>ui</code> 包的版本号。<ul>\n<li><strong>正解</strong>：❌ <strong>不需要</strong>。开发时 npm 忽略版本号，直接链接最新代码。版本号主要用于发布时的兼容性声明。</li>\n</ul>\n</li>\n<li><strong>误区</strong>：npm 会为 workspace 包“打包”或“下载”。<ul>\n<li><strong>正解</strong>：❌ <strong>不会</strong>。开发时是直接链接到本地文件，无打包下载过程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start=\"6\">\n<li><strong>一句话总结</strong></li>\n</ol>\n<blockquote>\n<p><strong>npm workspace 通过在依赖包的 <code>node_modules</code> 中创建指向源码目录的符号链接 (Symlink)，并结合 Node.js 标准的模块解析机制，实现了内部包的“软连接”。这使得开发者能无缝引用本地包，<code>import</code> 语句直接生效，且被依赖包更新构建后，依赖方能自动使用最新代码，极大地简化了 Monorepo 的开发流程。</strong></p>\n</blockquote>\n<h3 id=\"三、主要优势-1\"><a href=\"#三、主要优势-1\" class=\"headerlink\" title=\"三、主要优势\"></a>三、主要优势</h3><ol>\n<li><p><strong>依赖集中管理与优化</strong>：</p>\n<ul>\n<li>所有 workspace 的依赖（包括它们之间的依赖）都由根项目的 <code>node_modules</code> 统一管理。</li>\n<li>npm 会进行依赖提升（hoist），避免重复安装，减少 <code>node_modules</code> 体积。</li>\n<li>不同 workspace 可以共享相同的依赖版本。</li>\n</ul>\n</li>\n<li><p><strong>简化跨包依赖</strong>：</p>\n<ul>\n<li>假设 <code>frontend</code> 需要使用 <code>utils</code> 包。</li>\n<li>在 <code>packages/frontend/package.json</code> 中，你可以直接这样写：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;utils&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span>  <span class=\"comment\">// 假设 utils 的 version 是 1.0.0</span></span><br><span class=\"line\">    <span class=\"comment\">// 或者使用 &quot;workspace:*&quot; 来引用最新的本地版本</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>npm 会自动将 <code>packages/utils</code> 链接到 <code>frontend</code> 的依赖中，<strong>无需发布到 npm registry</strong>。这极大地方便了本地开发和测试。</li>\n</ul>\n</li>\n<li><p><strong>批量操作</strong>：</p>\n<ul>\n<li>使用 <code>--workspaces</code> 或 <code>--workspace=&lt;name&gt;</code> 标志可以对所有或特定 workspace 执行命令。</li>\n<li><strong>例子</strong>：<ul>\n<li><code>npm install</code>：安装所有 workspace 的依赖（包括它们之间的依赖）。</li>\n<li><code>npm run build --workspaces</code>：在所有 workspace 中运行 <code>build</code> 脚本。</li>\n<li><code>npm run test --workspace=packages/frontend</code>：只在 <code>frontend</code> workspace 中运行 <code>test</code> 脚本。</li>\n<li><code>npm exec --workspace=packages/backend vite</code>：在 <code>backend</code> 中执行 <code>vite</code> 命令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>版本同步与发布</strong>（需要额外工具）：</p>\n<ul>\n<li>虽然 npm workspace 本身不直接提供高级的版本管理和发布策略（如 <code>lerna</code> 或 <code>nx</code> 那样），但它为这些工具提供了基础。你可以结合 <code>npm version</code> 和脚本管理多个包的版本。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、常用命令-1\"><a href=\"#四、常用命令-1\" class=\"headerlink\" title=\"四、常用命令\"></a>四、常用命令</h3><ul>\n<li><code>npm install</code>：在根目录运行，会安装所有 workspace 的依赖。</li>\n<li><code>npm run &lt;script&gt; --workspaces</code>：在所有 workspace 中运行指定脚本。</li>\n<li><code>npm run &lt;script&gt; --workspace=&lt;package-name&gt;</code>：在指定 workspace 中运行脚本。</li>\n<li><code>npm exec --workspace=&lt;package-name&gt; &lt;command&gt;</code>：在指定 workspace 中执行命令。</li>\n<li><code>npm ls --workspaces</code>：列出所有 workspace。</li>\n<li><code>npm publish --workspace=&lt;package-name&gt;</code>：发布指定的 workspace 包到 npm registry。</li>\n</ul>\n<hr>\n<h3 id=\"五、注意事项-1\"><a href=\"#五、注意事项-1\" class=\"headerlink\" title=\"五、注意事项\"></a>五、注意事项</h3><ol>\n<li><strong>npm 版本要求</strong>：必须使用 <strong>npm 7 或更高版本</strong>。</li>\n<li>**<code>private: true</code>**：根项目通常设置为 <code>private: true</code>，防止意外发布。</li>\n<li><strong>依赖解析</strong>：npm 会优先从 workspace 中查找依赖，如果找不到，再去 npm registry 下载。</li>\n<li><strong>与 <code>file:</code> 依赖的区别</strong>：过去常用 <code>file:../utils</code> 来引用本地包，但这种方式在发布时会有问题（<code>file:</code> 路径在 registry 上无效）。workspace 依赖在开发时是链接的，发布时会正常解析为 registry 上的版本（如果已发布）。</li>\n<li><strong>不是唯一选择</strong>：还有其他优秀的 monorepo 工具，如 <code>pnpm</code>（其 workspace 功能非常强大且高效）、<code>yarn</code>（with Plug’n’Play）、<code>lerna</code>、<code>nx</code> 等。选择哪个取决于你的具体需求和偏好。</li>\n</ol>\n<hr>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>npm workspace 是一个内置于 npm 的、用于管理 monorepo 的轻量级解决方案。它通过集中依赖管理、简化跨包引用和提供批量操作能力，极大地提升了多包项目的开发效率。如果你的项目结构适合 monorepo 模式，npm workspace 是一个非常值得考虑的工具。</p>\n<blockquote>\n<p>npm workspace 提供了统一的依赖管理、统一的命令管理、采用的软链接方式解决了本地包之间引用的问题 </p>\n</blockquote>\n"},{"title":"npm vs pnpm","_content":"> [软链接硬链接](07-软链接和硬链接.md)\n`pnpm` 和 `npm` 都是 Node.js 生态系统中的包管理器，用于安装、更新、卸载和管理项目依赖。它们的主要区别体现在性能、磁盘空间使用、依赖结构和安装方式上。\n\n以下是 `pnpm` 和 `npm` 的主要区别：\n\n### 1. 依赖存储方式（核心区别）\n\n*   **npm**:\n    *   从 npm 3.x 开始，npm 采用扁平化依赖结构（flat dependency tree）。\n    *   它会将所有依赖尽可能地提升到 `node_modules` 的根目录，以减少嵌套层级。\n    *   但是，当存在版本冲突时，它仍然会在子目录中安装不同版本的包。\n    *   每个项目都会独立下载和存储其依赖，即使多个项目使用相同的包版本，也会在各自的 `node_modules` 中重复存储，占用更多磁盘空间。\n\n*   **pnpm**:\n    *   采用**内容可寻址存储**（Content-Addressable Store）和**硬链接**（Hard Links）机制。\n    *   所有下载的包都存储在一个全局的、单一的内容可寻址存储中（通常位于用户主目录下，如 `~/.pnpm-store`）。\n    *   当一个项目需要某个包时，`pnpm` 会从全局存储中创建指向该包的**硬链接**到项目的 `node_modules` 中。\n    *   这意味着**相同的包版本在磁盘上只存储一份**，无论被多少个项目使用，极大地节省了磁盘空间。\n    *   项目中的 `node_modules` 结构是“符号链接 + 硬链接”的混合体，结构更严格，更接近 `node_modules` 的原始嵌套结构（类似 npm 2.x），但通过链接避免了重复。\n\n### 2. 安装速度\n\n*   **首次安装**：对于一个新项目，如果全局存储中没有所需包，`pnpm` 需要先下载并存入全局存储，然后创建链接，速度可能与 `npm` 相近或稍慢。\n*   **后续安装/重复安装**：如果所需包已在全局存储中，`pnpm` 只需创建硬链接，速度**极快**，远超 `npm` 的重复下载和解压。\n*   **总体速度**：由于避免了重复下载和解压，`pnpm` 在大多数情况下的安装速度（尤其是 CI/CD 环境或频繁创建项目时）**显著快于 `npm`**。\n\n### 3. 磁盘空间占用\n\n*   **npm**：每个项目的 `node_modules` 都包含完整的依赖副本，占用大量磁盘空间，尤其是在有多个项目时。\n*   **pnpm**：利用全局存储和硬链接，**磁盘空间占用远小于 `npm`**。相同包版本只存储一份。\n\n### 4. 依赖隔离与“幻影依赖”（Phantom Dependencies）\n\n*   **npm**：扁平化结构可能导致“幻影依赖”问题。即项目代码中 `import` 了一个并未在 `package.json` 中声明的包，但由于该包是其他依赖的子依赖并被提升到了根目录，代码也能运行。这会带来依赖关系不明确、潜在的版本冲突和构建失败风险。\n*   **pnpm**：其严格的 `node_modules` 结构（更接近嵌套）**有效防止了“幻影依赖”**。只有在 `package.json` 中明确声明的依赖，其直接子依赖才能被访问。这强制开发者显式声明所有依赖，提高了项目的可维护性和可靠性。\n\n### 5. 兼容性\n\n*   **pnpm**：高度兼容 `npm`。`pnpm` 使用相同的 `package.json` 格式和 `npm` registry。大多数为 `npm` 设计的包也能在 `pnpm` 下正常工作。`pnpm` 也提供了 `pnpmfile.js` 用于处理极少数不兼容的情况。\n\n### 6. 命令行语法\n\n*   `pnpm` 的命令行语法与 `npm` **几乎完全相同**。例如：\n    *   `npm install` -> `pnpm install` (或 `pnpm i`)\n    *   `npm install package-name` -> `pnpm add package-name`\n    *   `npm run script-name` -> `pnpm run script-name`\n    *   这使得从 `npm` 迁移到 `pnpm` 非常容易。\n\n### 总结\n\n| 特性         | npm                            | pnpm                                      |\n| :----------- | :----------------------------- | :---------------------------------------- |\n| **存储方式**   | 每个项目独立存储，可能重复       | 全局内容可寻址存储 + 硬链接，避免重复       |\n| **磁盘占用**   | 较高                           | **极低** (相同版本只存一份)                 |\n| **安装速度**   | 一般                           | **更快** (尤其在有缓存时)                   |\n| **依赖结构**   | 扁平化 (可能产生幻影依赖)       | 更严格嵌套 (**防止幻影依赖**)               |\n| **兼容性**    | 原生                           | 高度兼容 `npm`                             |\n| **命令语法**   | `npm xxx`                     | `pnpm xxx` (几乎相同)                     |\n\n**简单来说**：`pnpm` 在保持与 `npm` 高度兼容的同时，通过创新的存储机制，**显著提升了安装速度，大幅节省了磁盘空间，并增强了依赖管理的严格性**。如果你追求效率和更好的依赖管理实践，`pnpm` 是一个非常值得考虑的优秀替代品。","source":"_posts/npm vs pnpm.md","raw":"---\ntitle: npm vs pnpm\n---\n> [软链接硬链接](07-软链接和硬链接.md)\n`pnpm` 和 `npm` 都是 Node.js 生态系统中的包管理器，用于安装、更新、卸载和管理项目依赖。它们的主要区别体现在性能、磁盘空间使用、依赖结构和安装方式上。\n\n以下是 `pnpm` 和 `npm` 的主要区别：\n\n### 1. 依赖存储方式（核心区别）\n\n*   **npm**:\n    *   从 npm 3.x 开始，npm 采用扁平化依赖结构（flat dependency tree）。\n    *   它会将所有依赖尽可能地提升到 `node_modules` 的根目录，以减少嵌套层级。\n    *   但是，当存在版本冲突时，它仍然会在子目录中安装不同版本的包。\n    *   每个项目都会独立下载和存储其依赖，即使多个项目使用相同的包版本，也会在各自的 `node_modules` 中重复存储，占用更多磁盘空间。\n\n*   **pnpm**:\n    *   采用**内容可寻址存储**（Content-Addressable Store）和**硬链接**（Hard Links）机制。\n    *   所有下载的包都存储在一个全局的、单一的内容可寻址存储中（通常位于用户主目录下，如 `~/.pnpm-store`）。\n    *   当一个项目需要某个包时，`pnpm` 会从全局存储中创建指向该包的**硬链接**到项目的 `node_modules` 中。\n    *   这意味着**相同的包版本在磁盘上只存储一份**，无论被多少个项目使用，极大地节省了磁盘空间。\n    *   项目中的 `node_modules` 结构是“符号链接 + 硬链接”的混合体，结构更严格，更接近 `node_modules` 的原始嵌套结构（类似 npm 2.x），但通过链接避免了重复。\n\n### 2. 安装速度\n\n*   **首次安装**：对于一个新项目，如果全局存储中没有所需包，`pnpm` 需要先下载并存入全局存储，然后创建链接，速度可能与 `npm` 相近或稍慢。\n*   **后续安装/重复安装**：如果所需包已在全局存储中，`pnpm` 只需创建硬链接，速度**极快**，远超 `npm` 的重复下载和解压。\n*   **总体速度**：由于避免了重复下载和解压，`pnpm` 在大多数情况下的安装速度（尤其是 CI/CD 环境或频繁创建项目时）**显著快于 `npm`**。\n\n### 3. 磁盘空间占用\n\n*   **npm**：每个项目的 `node_modules` 都包含完整的依赖副本，占用大量磁盘空间，尤其是在有多个项目时。\n*   **pnpm**：利用全局存储和硬链接，**磁盘空间占用远小于 `npm`**。相同包版本只存储一份。\n\n### 4. 依赖隔离与“幻影依赖”（Phantom Dependencies）\n\n*   **npm**：扁平化结构可能导致“幻影依赖”问题。即项目代码中 `import` 了一个并未在 `package.json` 中声明的包，但由于该包是其他依赖的子依赖并被提升到了根目录，代码也能运行。这会带来依赖关系不明确、潜在的版本冲突和构建失败风险。\n*   **pnpm**：其严格的 `node_modules` 结构（更接近嵌套）**有效防止了“幻影依赖”**。只有在 `package.json` 中明确声明的依赖，其直接子依赖才能被访问。这强制开发者显式声明所有依赖，提高了项目的可维护性和可靠性。\n\n### 5. 兼容性\n\n*   **pnpm**：高度兼容 `npm`。`pnpm` 使用相同的 `package.json` 格式和 `npm` registry。大多数为 `npm` 设计的包也能在 `pnpm` 下正常工作。`pnpm` 也提供了 `pnpmfile.js` 用于处理极少数不兼容的情况。\n\n### 6. 命令行语法\n\n*   `pnpm` 的命令行语法与 `npm` **几乎完全相同**。例如：\n    *   `npm install` -> `pnpm install` (或 `pnpm i`)\n    *   `npm install package-name` -> `pnpm add package-name`\n    *   `npm run script-name` -> `pnpm run script-name`\n    *   这使得从 `npm` 迁移到 `pnpm` 非常容易。\n\n### 总结\n\n| 特性         | npm                            | pnpm                                      |\n| :----------- | :----------------------------- | :---------------------------------------- |\n| **存储方式**   | 每个项目独立存储，可能重复       | 全局内容可寻址存储 + 硬链接，避免重复       |\n| **磁盘占用**   | 较高                           | **极低** (相同版本只存一份)                 |\n| **安装速度**   | 一般                           | **更快** (尤其在有缓存时)                   |\n| **依赖结构**   | 扁平化 (可能产生幻影依赖)       | 更严格嵌套 (**防止幻影依赖**)               |\n| **兼容性**    | 原生                           | 高度兼容 `npm`                             |\n| **命令语法**   | `npm xxx`                     | `pnpm xxx` (几乎相同)                     |\n\n**简单来说**：`pnpm` 在保持与 `npm` 高度兼容的同时，通过创新的存储机制，**显著提升了安装速度，大幅节省了磁盘空间，并增强了依赖管理的严格性**。如果你追求效率和更好的依赖管理实践，`pnpm` 是一个非常值得考虑的优秀替代品。","slug":"npm vs pnpm","published":1,"date":"2025-09-02T01:50:34.919Z","updated":"2025-09-01T09:54:01.763Z","_id":"cmf1wu3q8000qq4v9bmkego6l","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><a href=\"07-%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5.md\">软链接硬链接</a><br><code>pnpm</code> 和 <code>npm</code> 都是 Node.js 生态系统中的包管理器，用于安装、更新、卸载和管理项目依赖。它们的主要区别体现在性能、磁盘空间使用、依赖结构和安装方式上。</p>\n</blockquote>\n<p>以下是 <code>pnpm</code> 和 <code>npm</code> 的主要区别：</p>\n<h3 id=\"1-依赖存储方式（核心区别）\"><a href=\"#1-依赖存储方式（核心区别）\" class=\"headerlink\" title=\"1. 依赖存储方式（核心区别）\"></a>1. 依赖存储方式（核心区别）</h3><ul>\n<li><p><strong>npm</strong>:</p>\n<ul>\n<li>从 npm 3.x 开始，npm 采用扁平化依赖结构（flat dependency tree）。</li>\n<li>它会将所有依赖尽可能地提升到 <code>node_modules</code> 的根目录，以减少嵌套层级。</li>\n<li>但是，当存在版本冲突时，它仍然会在子目录中安装不同版本的包。</li>\n<li>每个项目都会独立下载和存储其依赖，即使多个项目使用相同的包版本，也会在各自的 <code>node_modules</code> 中重复存储，占用更多磁盘空间。</li>\n</ul>\n</li>\n<li><p><strong>pnpm</strong>:</p>\n<ul>\n<li>采用<strong>内容可寻址存储</strong>（Content-Addressable Store）和<strong>硬链接</strong>（Hard Links）机制。</li>\n<li>所有下载的包都存储在一个全局的、单一的内容可寻址存储中（通常位于用户主目录下，如 <code>~/.pnpm-store</code>）。</li>\n<li>当一个项目需要某个包时，<code>pnpm</code> 会从全局存储中创建指向该包的<strong>硬链接</strong>到项目的 <code>node_modules</code> 中。</li>\n<li>这意味着<strong>相同的包版本在磁盘上只存储一份</strong>，无论被多少个项目使用，极大地节省了磁盘空间。</li>\n<li>项目中的 <code>node_modules</code> 结构是“符号链接 + 硬链接”的混合体，结构更严格，更接近 <code>node_modules</code> 的原始嵌套结构（类似 npm 2.x），但通过链接避免了重复。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-安装速度\"><a href=\"#2-安装速度\" class=\"headerlink\" title=\"2. 安装速度\"></a>2. 安装速度</h3><ul>\n<li><strong>首次安装</strong>：对于一个新项目，如果全局存储中没有所需包，<code>pnpm</code> 需要先下载并存入全局存储，然后创建链接，速度可能与 <code>npm</code> 相近或稍慢。</li>\n<li><strong>后续安装&#x2F;重复安装</strong>：如果所需包已在全局存储中，<code>pnpm</code> 只需创建硬链接，速度<strong>极快</strong>，远超 <code>npm</code> 的重复下载和解压。</li>\n<li><strong>总体速度</strong>：由于避免了重复下载和解压，<code>pnpm</code> 在大多数情况下的安装速度（尤其是 CI&#x2F;CD 环境或频繁创建项目时）**显著快于 <code>npm</code>**。</li>\n</ul>\n<h3 id=\"3-磁盘空间占用\"><a href=\"#3-磁盘空间占用\" class=\"headerlink\" title=\"3. 磁盘空间占用\"></a>3. 磁盘空间占用</h3><ul>\n<li><strong>npm</strong>：每个项目的 <code>node_modules</code> 都包含完整的依赖副本，占用大量磁盘空间，尤其是在有多个项目时。</li>\n<li><strong>pnpm</strong>：利用全局存储和硬链接，**磁盘空间占用远小于 <code>npm</code>**。相同包版本只存储一份。</li>\n</ul>\n<h3 id=\"4-依赖隔离与“幻影依赖”（Phantom-Dependencies）\"><a href=\"#4-依赖隔离与“幻影依赖”（Phantom-Dependencies）\" class=\"headerlink\" title=\"4. 依赖隔离与“幻影依赖”（Phantom Dependencies）\"></a>4. 依赖隔离与“幻影依赖”（Phantom Dependencies）</h3><ul>\n<li><strong>npm</strong>：扁平化结构可能导致“幻影依赖”问题。即项目代码中 <code>import</code> 了一个并未在 <code>package.json</code> 中声明的包，但由于该包是其他依赖的子依赖并被提升到了根目录，代码也能运行。这会带来依赖关系不明确、潜在的版本冲突和构建失败风险。</li>\n<li><strong>pnpm</strong>：其严格的 <code>node_modules</code> 结构（更接近嵌套）<strong>有效防止了“幻影依赖”</strong>。只有在 <code>package.json</code> 中明确声明的依赖，其直接子依赖才能被访问。这强制开发者显式声明所有依赖，提高了项目的可维护性和可靠性。</li>\n</ul>\n<h3 id=\"5-兼容性\"><a href=\"#5-兼容性\" class=\"headerlink\" title=\"5. 兼容性\"></a>5. 兼容性</h3><ul>\n<li><strong>pnpm</strong>：高度兼容 <code>npm</code>。<code>pnpm</code> 使用相同的 <code>package.json</code> 格式和 <code>npm</code> registry。大多数为 <code>npm</code> 设计的包也能在 <code>pnpm</code> 下正常工作。<code>pnpm</code> 也提供了 <code>pnpmfile.js</code> 用于处理极少数不兼容的情况。</li>\n</ul>\n<h3 id=\"6-命令行语法\"><a href=\"#6-命令行语法\" class=\"headerlink\" title=\"6. 命令行语法\"></a>6. 命令行语法</h3><ul>\n<li><code>pnpm</code> 的命令行语法与 <code>npm</code> <strong>几乎完全相同</strong>。例如：<ul>\n<li><code>npm install</code> -&gt; <code>pnpm install</code> (或 <code>pnpm i</code>)</li>\n<li><code>npm install package-name</code> -&gt; <code>pnpm add package-name</code></li>\n<li><code>npm run script-name</code> -&gt; <code>pnpm run script-name</code></li>\n<li>这使得从 <code>npm</code> 迁移到 <code>pnpm</code> 非常容易。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">npm</th>\n<th align=\"left\">pnpm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>存储方式</strong></td>\n<td align=\"left\">每个项目独立存储，可能重复</td>\n<td align=\"left\">全局内容可寻址存储 + 硬链接，避免重复</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>磁盘占用</strong></td>\n<td align=\"left\">较高</td>\n<td align=\"left\"><strong>极低</strong> (相同版本只存一份)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>安装速度</strong></td>\n<td align=\"left\">一般</td>\n<td align=\"left\"><strong>更快</strong> (尤其在有缓存时)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>依赖结构</strong></td>\n<td align=\"left\">扁平化 (可能产生幻影依赖)</td>\n<td align=\"left\">更严格嵌套 (<strong>防止幻影依赖</strong>)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>兼容性</strong></td>\n<td align=\"left\">原生</td>\n<td align=\"left\">高度兼容 <code>npm</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>命令语法</strong></td>\n<td align=\"left\"><code>npm xxx</code></td>\n<td align=\"left\"><code>pnpm xxx</code> (几乎相同)</td>\n</tr>\n</tbody></table>\n<p><strong>简单来说</strong>：<code>pnpm</code> 在保持与 <code>npm</code> 高度兼容的同时，通过创新的存储机制，<strong>显著提升了安装速度，大幅节省了磁盘空间，并增强了依赖管理的严格性</strong>。如果你追求效率和更好的依赖管理实践，<code>pnpm</code> 是一个非常值得考虑的优秀替代品。</p>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"07-%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5.md\">软链接硬链接</a><br><code>pnpm</code> 和 <code>npm</code> 都是 Node.js 生态系统中的包管理器，用于安装、更新、卸载和管理项目依赖。它们的主要区别体现在性能、磁盘空间使用、依赖结构和安装方式上。</p>\n</blockquote>\n<p>以下是 <code>pnpm</code> 和 <code>npm</code> 的主要区别：</p>\n<h3 id=\"1-依赖存储方式（核心区别）\"><a href=\"#1-依赖存储方式（核心区别）\" class=\"headerlink\" title=\"1. 依赖存储方式（核心区别）\"></a>1. 依赖存储方式（核心区别）</h3><ul>\n<li><p><strong>npm</strong>:</p>\n<ul>\n<li>从 npm 3.x 开始，npm 采用扁平化依赖结构（flat dependency tree）。</li>\n<li>它会将所有依赖尽可能地提升到 <code>node_modules</code> 的根目录，以减少嵌套层级。</li>\n<li>但是，当存在版本冲突时，它仍然会在子目录中安装不同版本的包。</li>\n<li>每个项目都会独立下载和存储其依赖，即使多个项目使用相同的包版本，也会在各自的 <code>node_modules</code> 中重复存储，占用更多磁盘空间。</li>\n</ul>\n</li>\n<li><p><strong>pnpm</strong>:</p>\n<ul>\n<li>采用<strong>内容可寻址存储</strong>（Content-Addressable Store）和<strong>硬链接</strong>（Hard Links）机制。</li>\n<li>所有下载的包都存储在一个全局的、单一的内容可寻址存储中（通常位于用户主目录下，如 <code>~/.pnpm-store</code>）。</li>\n<li>当一个项目需要某个包时，<code>pnpm</code> 会从全局存储中创建指向该包的<strong>硬链接</strong>到项目的 <code>node_modules</code> 中。</li>\n<li>这意味着<strong>相同的包版本在磁盘上只存储一份</strong>，无论被多少个项目使用，极大地节省了磁盘空间。</li>\n<li>项目中的 <code>node_modules</code> 结构是“符号链接 + 硬链接”的混合体，结构更严格，更接近 <code>node_modules</code> 的原始嵌套结构（类似 npm 2.x），但通过链接避免了重复。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-安装速度\"><a href=\"#2-安装速度\" class=\"headerlink\" title=\"2. 安装速度\"></a>2. 安装速度</h3><ul>\n<li><strong>首次安装</strong>：对于一个新项目，如果全局存储中没有所需包，<code>pnpm</code> 需要先下载并存入全局存储，然后创建链接，速度可能与 <code>npm</code> 相近或稍慢。</li>\n<li><strong>后续安装&#x2F;重复安装</strong>：如果所需包已在全局存储中，<code>pnpm</code> 只需创建硬链接，速度<strong>极快</strong>，远超 <code>npm</code> 的重复下载和解压。</li>\n<li><strong>总体速度</strong>：由于避免了重复下载和解压，<code>pnpm</code> 在大多数情况下的安装速度（尤其是 CI&#x2F;CD 环境或频繁创建项目时）**显著快于 <code>npm</code>**。</li>\n</ul>\n<h3 id=\"3-磁盘空间占用\"><a href=\"#3-磁盘空间占用\" class=\"headerlink\" title=\"3. 磁盘空间占用\"></a>3. 磁盘空间占用</h3><ul>\n<li><strong>npm</strong>：每个项目的 <code>node_modules</code> 都包含完整的依赖副本，占用大量磁盘空间，尤其是在有多个项目时。</li>\n<li><strong>pnpm</strong>：利用全局存储和硬链接，**磁盘空间占用远小于 <code>npm</code>**。相同包版本只存储一份。</li>\n</ul>\n<h3 id=\"4-依赖隔离与“幻影依赖”（Phantom-Dependencies）\"><a href=\"#4-依赖隔离与“幻影依赖”（Phantom-Dependencies）\" class=\"headerlink\" title=\"4. 依赖隔离与“幻影依赖”（Phantom Dependencies）\"></a>4. 依赖隔离与“幻影依赖”（Phantom Dependencies）</h3><ul>\n<li><strong>npm</strong>：扁平化结构可能导致“幻影依赖”问题。即项目代码中 <code>import</code> 了一个并未在 <code>package.json</code> 中声明的包，但由于该包是其他依赖的子依赖并被提升到了根目录，代码也能运行。这会带来依赖关系不明确、潜在的版本冲突和构建失败风险。</li>\n<li><strong>pnpm</strong>：其严格的 <code>node_modules</code> 结构（更接近嵌套）<strong>有效防止了“幻影依赖”</strong>。只有在 <code>package.json</code> 中明确声明的依赖，其直接子依赖才能被访问。这强制开发者显式声明所有依赖，提高了项目的可维护性和可靠性。</li>\n</ul>\n<h3 id=\"5-兼容性\"><a href=\"#5-兼容性\" class=\"headerlink\" title=\"5. 兼容性\"></a>5. 兼容性</h3><ul>\n<li><strong>pnpm</strong>：高度兼容 <code>npm</code>。<code>pnpm</code> 使用相同的 <code>package.json</code> 格式和 <code>npm</code> registry。大多数为 <code>npm</code> 设计的包也能在 <code>pnpm</code> 下正常工作。<code>pnpm</code> 也提供了 <code>pnpmfile.js</code> 用于处理极少数不兼容的情况。</li>\n</ul>\n<h3 id=\"6-命令行语法\"><a href=\"#6-命令行语法\" class=\"headerlink\" title=\"6. 命令行语法\"></a>6. 命令行语法</h3><ul>\n<li><code>pnpm</code> 的命令行语法与 <code>npm</code> <strong>几乎完全相同</strong>。例如：<ul>\n<li><code>npm install</code> -&gt; <code>pnpm install</code> (或 <code>pnpm i</code>)</li>\n<li><code>npm install package-name</code> -&gt; <code>pnpm add package-name</code></li>\n<li><code>npm run script-name</code> -&gt; <code>pnpm run script-name</code></li>\n<li>这使得从 <code>npm</code> 迁移到 <code>pnpm</code> 非常容易。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">npm</th>\n<th align=\"left\">pnpm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>存储方式</strong></td>\n<td align=\"left\">每个项目独立存储，可能重复</td>\n<td align=\"left\">全局内容可寻址存储 + 硬链接，避免重复</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>磁盘占用</strong></td>\n<td align=\"left\">较高</td>\n<td align=\"left\"><strong>极低</strong> (相同版本只存一份)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>安装速度</strong></td>\n<td align=\"left\">一般</td>\n<td align=\"left\"><strong>更快</strong> (尤其在有缓存时)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>依赖结构</strong></td>\n<td align=\"left\">扁平化 (可能产生幻影依赖)</td>\n<td align=\"left\">更严格嵌套 (<strong>防止幻影依赖</strong>)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>兼容性</strong></td>\n<td align=\"left\">原生</td>\n<td align=\"left\">高度兼容 <code>npm</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>命令语法</strong></td>\n<td align=\"left\"><code>npm xxx</code></td>\n<td align=\"left\"><code>pnpm xxx</code> (几乎相同)</td>\n</tr>\n</tbody></table>\n<p><strong>简单来说</strong>：<code>pnpm</code> 在保持与 <code>npm</code> 高度兼容的同时，通过创新的存储机制，<strong>显著提升了安装速度，大幅节省了磁盘空间，并增强了依赖管理的严格性</strong>。如果你追求效率和更好的依赖管理实践，<code>pnpm</code> 是一个非常值得考虑的优秀替代品。</p>\n"},{"title":"📦npm `package.json` 的作用","_content":"\n---\n\n## ✅ 一句话总结\n\n> `package.json` 是一个 **项目说明书**，它告诉：\n>\n> - **你**：这个项目依赖哪些包、怎么运行\n> - **npm / yarn / pnpm**：怎么安装、发布、管理这个项目\n> - **别人**：这是个什么项目、怎么使用它\n\n它就像一本书的“封面 + 目录 + 前言”。\n\n---\n\n## 🧩 举个生活例子：开餐馆\n\n| 类比 | 对应 `package.json` |\n|------|---------------------|\n| 餐馆名字 | `\"name\": \"小王面馆\"` |\n| 菜单（有什么菜） | `\"scripts\"`：`start`, `build` 等命令 |\n| 食材从哪进货 | `\"dependencies\"`：用了哪些 npm 包 |\n| 厨房用什么工具（炒菜用燃气灶） | `\"devDependencies\"`：开发时用的工具 |\n| 客人怎么点餐 | `\"main\"`：别人 `require` 时从哪开始 |\n| 餐馆地址、电话、营业时间 | `\"version\"`, `\"description\"`, `\"author\"`, `\"license\"` |\n\n---\n\n## 🔍 核心作用分类\n\n### 1️⃣ 项目元信息（基本信息）\n\n这些是“介绍项目”的字段：\n\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"一个简单的计算器应用\",\n  \"author\": \"小明\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/xiaoming/my-app#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/xiaoming/my-app.git\"\n  }\n}\n```\n\n> ✅ 作用：别人一看就知道这是什么项目、谁写的、能不能商用（license）、代码在哪。\n\n---\n\n### 2️⃣ 依赖管理（自动安装第三方包）\n\n这是 `package.json` 最强大的功能！\n\n#### ✅ `dependencies`：项目运行必须的包\n```json\n\"dependencies\": {\n  \"lodash\": \"^4.17.21\",\n  \"react\": \"^18.0.0\"\n}\n```\n- 运行 `npm install` 时，会自动下载这些包到 `node_modules`\n- 别人拿到你的项目，一运行 `npm install`，所有依赖自动装好\n\n#### ✅ `devDependencies`：开发时用的工具\n```json\n\"devDependencies\": {\n  \"vite\": \"^4.0.0\",\n  \"eslint\": \"^8.0.0\"\n}\n```\n- 比如打包工具、代码检查工具\n- 发布包时，别人不需要这些（但你开发时需要）\n\n> 🔑 核心价值：**告别“手动下载 JS 文件”时代，实现依赖自动化管理**\n\n---\n\n### 3️⃣ 脚本命令（快捷方式）\n\n```json\n\"scripts\": {\n  \"start\": \"node index.js\",\n  \"build\": \"babel src -d lib\",\n  \"test\": \"jest\"\n}\n```\n\n你可以运行：\n\n```bash\nnpm run start   → 执行 node index.js\nnpm run build   → 执行 babel src -d lib\n```\n\n> ✅ 作用：把复杂命令简化成一句话，团队协作时统一操作方式。\n\n---\n\n### 4️⃣ 包入口（别人怎么引用你）\n\n当你发布一个 npm 包时，这些字段告诉别人“从哪开始用”：\n\n```json\n{\n  \"main\": \"lib/index.js\",           // Node.js require 用\n  \"browser\": \"dist/index.js\",       // 浏览器打包用\n  \"module\": \"es/index.js\"           // 支持 tree-shaking 的格式\n}\n```\n\n> ✅ 作用：让别人能正确加载你的代码。\n\n---\n\n### 5️⃣ 发布控制\n\n```json\n{\n  \"files\": [\"lib\", \"dist\"],         // 只发布这些文件\n  \"private\": true,                  // 设为 true 就不能发布到共有仓库 防止不小心发包\n  \"publishConfig\": {\n    \"registry\": \"https://my-registry.com\"\n  }\n}\n```\n\n> ✅ 作用：控制包的发布行为。\n\n---\n\n### 6️⃣ 其他工具配置（一配置多用）\n\n很多工具会读 `package.json`，比如：\n\n```json\n\"eslintConfig\": {\n  \"rules\": {\n    \"semi\": \"error\"\n  }\n},\n\"browserslist\": [\n  \"> 1%\",\n  \"last 2 versions\"\n]\n```\n\n> ✅ 作用：不用单独写 `.eslintrc`、`.browserslistrc` 文件，全在 `package.json` 里配。\n\n---\n\n## 📌 总结：`package.json` 的 6 大作用\n\n| 作用 | 关键字段 | 举例 |\n|------|----------|------|\n| 1. 项目介绍 | `name`, `version`, `description` | 别人一看就知道这是啥 |\n| 2. 依赖管理 | `dependencies`, `devDependencies` | `npm install` 自动装包 |\n| 3. 命令快捷方式 | `scripts` | `npm run build` 打包 |\n| 4. 包入口 | `main`, `browser` | 别人 `require` 时从哪开始 |\n| 5. 发布控制 | `files`, `private` | 控制发布内容 |\n| 6. 工具配置 | `eslintConfig`, `browserslist` | 统一开发规范 |\n\n---\n\n## ✅ 什么时候会用到 `package.json`？\n\n| 场景 | 用到 `package.json` 吗？ |\n|------|--------------------------|\n| 创建新项目 | ✅ `npm init` 生成它 |\n| 安装包 | ✅ `npm install xxx` 会写入 `dependencies` |\n| 运行项目 | ✅ `npm start` 读 `scripts` |\n| 发布包 | ✅ 必须有 `name`, `version`, `main` |\n| 别人使用你的项目 | ✅ 他们靠它知道怎么运行 |\n\n---\n\n## 🎯 最后一句话\n\n> `package.json` 是 **现代 JavaScript 项目的“身份证 + 操作手册 + 依赖清单”三位一体的核心文件**。  \n> 没有它，npm 就不知道你是谁、用什么、怎么运行。\n\n---\n\n现在你对 `package.json` 的理解就非常完整了！🎉  \n如果你要开发任何 JS 项目（前端、后端、工具库），都绕不开它。","source":"_posts/npm.md","raw":"---\ntitle: 📦npm `package.json` 的作用\n---\n\n---\n\n## ✅ 一句话总结\n\n> `package.json` 是一个 **项目说明书**，它告诉：\n>\n> - **你**：这个项目依赖哪些包、怎么运行\n> - **npm / yarn / pnpm**：怎么安装、发布、管理这个项目\n> - **别人**：这是个什么项目、怎么使用它\n\n它就像一本书的“封面 + 目录 + 前言”。\n\n---\n\n## 🧩 举个生活例子：开餐馆\n\n| 类比 | 对应 `package.json` |\n|------|---------------------|\n| 餐馆名字 | `\"name\": \"小王面馆\"` |\n| 菜单（有什么菜） | `\"scripts\"`：`start`, `build` 等命令 |\n| 食材从哪进货 | `\"dependencies\"`：用了哪些 npm 包 |\n| 厨房用什么工具（炒菜用燃气灶） | `\"devDependencies\"`：开发时用的工具 |\n| 客人怎么点餐 | `\"main\"`：别人 `require` 时从哪开始 |\n| 餐馆地址、电话、营业时间 | `\"version\"`, `\"description\"`, `\"author\"`, `\"license\"` |\n\n---\n\n## 🔍 核心作用分类\n\n### 1️⃣ 项目元信息（基本信息）\n\n这些是“介绍项目”的字段：\n\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"一个简单的计算器应用\",\n  \"author\": \"小明\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/xiaoming/my-app#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/xiaoming/my-app.git\"\n  }\n}\n```\n\n> ✅ 作用：别人一看就知道这是什么项目、谁写的、能不能商用（license）、代码在哪。\n\n---\n\n### 2️⃣ 依赖管理（自动安装第三方包）\n\n这是 `package.json` 最强大的功能！\n\n#### ✅ `dependencies`：项目运行必须的包\n```json\n\"dependencies\": {\n  \"lodash\": \"^4.17.21\",\n  \"react\": \"^18.0.0\"\n}\n```\n- 运行 `npm install` 时，会自动下载这些包到 `node_modules`\n- 别人拿到你的项目，一运行 `npm install`，所有依赖自动装好\n\n#### ✅ `devDependencies`：开发时用的工具\n```json\n\"devDependencies\": {\n  \"vite\": \"^4.0.0\",\n  \"eslint\": \"^8.0.0\"\n}\n```\n- 比如打包工具、代码检查工具\n- 发布包时，别人不需要这些（但你开发时需要）\n\n> 🔑 核心价值：**告别“手动下载 JS 文件”时代，实现依赖自动化管理**\n\n---\n\n### 3️⃣ 脚本命令（快捷方式）\n\n```json\n\"scripts\": {\n  \"start\": \"node index.js\",\n  \"build\": \"babel src -d lib\",\n  \"test\": \"jest\"\n}\n```\n\n你可以运行：\n\n```bash\nnpm run start   → 执行 node index.js\nnpm run build   → 执行 babel src -d lib\n```\n\n> ✅ 作用：把复杂命令简化成一句话，团队协作时统一操作方式。\n\n---\n\n### 4️⃣ 包入口（别人怎么引用你）\n\n当你发布一个 npm 包时，这些字段告诉别人“从哪开始用”：\n\n```json\n{\n  \"main\": \"lib/index.js\",           // Node.js require 用\n  \"browser\": \"dist/index.js\",       // 浏览器打包用\n  \"module\": \"es/index.js\"           // 支持 tree-shaking 的格式\n}\n```\n\n> ✅ 作用：让别人能正确加载你的代码。\n\n---\n\n### 5️⃣ 发布控制\n\n```json\n{\n  \"files\": [\"lib\", \"dist\"],         // 只发布这些文件\n  \"private\": true,                  // 设为 true 就不能发布到共有仓库 防止不小心发包\n  \"publishConfig\": {\n    \"registry\": \"https://my-registry.com\"\n  }\n}\n```\n\n> ✅ 作用：控制包的发布行为。\n\n---\n\n### 6️⃣ 其他工具配置（一配置多用）\n\n很多工具会读 `package.json`，比如：\n\n```json\n\"eslintConfig\": {\n  \"rules\": {\n    \"semi\": \"error\"\n  }\n},\n\"browserslist\": [\n  \"> 1%\",\n  \"last 2 versions\"\n]\n```\n\n> ✅ 作用：不用单独写 `.eslintrc`、`.browserslistrc` 文件，全在 `package.json` 里配。\n\n---\n\n## 📌 总结：`package.json` 的 6 大作用\n\n| 作用 | 关键字段 | 举例 |\n|------|----------|------|\n| 1. 项目介绍 | `name`, `version`, `description` | 别人一看就知道这是啥 |\n| 2. 依赖管理 | `dependencies`, `devDependencies` | `npm install` 自动装包 |\n| 3. 命令快捷方式 | `scripts` | `npm run build` 打包 |\n| 4. 包入口 | `main`, `browser` | 别人 `require` 时从哪开始 |\n| 5. 发布控制 | `files`, `private` | 控制发布内容 |\n| 6. 工具配置 | `eslintConfig`, `browserslist` | 统一开发规范 |\n\n---\n\n## ✅ 什么时候会用到 `package.json`？\n\n| 场景 | 用到 `package.json` 吗？ |\n|------|--------------------------|\n| 创建新项目 | ✅ `npm init` 生成它 |\n| 安装包 | ✅ `npm install xxx` 会写入 `dependencies` |\n| 运行项目 | ✅ `npm start` 读 `scripts` |\n| 发布包 | ✅ 必须有 `name`, `version`, `main` |\n| 别人使用你的项目 | ✅ 他们靠它知道怎么运行 |\n\n---\n\n## 🎯 最后一句话\n\n> `package.json` 是 **现代 JavaScript 项目的“身份证 + 操作手册 + 依赖清单”三位一体的核心文件**。  \n> 没有它，npm 就不知道你是谁、用什么、怎么运行。\n\n---\n\n现在你对 `package.json` 的理解就非常完整了！🎉  \n如果你要开发任何 JS 项目（前端、后端、工具库），都绕不开它。","slug":"npm","published":1,"date":"2025-09-02T01:50:34.925Z","updated":"2025-09-01T09:54:01.764Z","_id":"cmf1wu7ll000rq4v9c9sz7k7r","comments":1,"layout":"post","photos":[],"content":"<hr>\n<h2 id=\"✅-一句话总结\"><a href=\"#✅-一句话总结\" class=\"headerlink\" title=\"✅ 一句话总结\"></a>✅ 一句话总结</h2><blockquote>\n<p><code>package.json</code> 是一个 <strong>项目说明书</strong>，它告诉：</p>\n<ul>\n<li><strong>你</strong>：这个项目依赖哪些包、怎么运行</li>\n<li><strong>npm &#x2F; yarn &#x2F; pnpm</strong>：怎么安装、发布、管理这个项目</li>\n<li><strong>别人</strong>：这是个什么项目、怎么使用它</li>\n</ul>\n</blockquote>\n<p>它就像一本书的“封面 + 目录 + 前言”。</p>\n<hr>\n<h2 id=\"🧩-举个生活例子：开餐馆\"><a href=\"#🧩-举个生活例子：开餐馆\" class=\"headerlink\" title=\"🧩 举个生活例子：开餐馆\"></a>🧩 举个生活例子：开餐馆</h2><table>\n<thead>\n<tr>\n<th>类比</th>\n<th>对应 <code>package.json</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>餐馆名字</td>\n<td><code>&quot;name&quot;: &quot;小王面馆&quot;</code></td>\n</tr>\n<tr>\n<td>菜单（有什么菜）</td>\n<td><code>&quot;scripts&quot;</code>：<code>start</code>, <code>build</code> 等命令</td>\n</tr>\n<tr>\n<td>食材从哪进货</td>\n<td><code>&quot;dependencies&quot;</code>：用了哪些 npm 包</td>\n</tr>\n<tr>\n<td>厨房用什么工具（炒菜用燃气灶）</td>\n<td><code>&quot;devDependencies&quot;</code>：开发时用的工具</td>\n</tr>\n<tr>\n<td>客人怎么点餐</td>\n<td><code>&quot;main&quot;</code>：别人 <code>require</code> 时从哪开始</td>\n</tr>\n<tr>\n<td>餐馆地址、电话、营业时间</td>\n<td><code>&quot;version&quot;</code>, <code>&quot;description&quot;</code>, <code>&quot;author&quot;</code>, <code>&quot;license&quot;</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔍-核心作用分类\"><a href=\"#🔍-核心作用分类\" class=\"headerlink\" title=\"🔍 核心作用分类\"></a>🔍 核心作用分类</h2><h3 id=\"1️⃣-项目元信息（基本信息）\"><a href=\"#1️⃣-项目元信息（基本信息）\" class=\"headerlink\" title=\"1️⃣ 项目元信息（基本信息）\"></a>1️⃣ 项目元信息（基本信息）</h3><p>这些是“介绍项目”的字段：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;my-app&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;一个简单的计算器应用&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;author&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;小明&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;license&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;MIT&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;homepage&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://github.com/xiaoming/my-app#readme&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;repository&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;git&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;url&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://github.com/xiaoming/my-app.git&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：别人一看就知道这是什么项目、谁写的、能不能商用（license）、代码在哪。</p>\n</blockquote>\n<hr>\n<h3 id=\"2️⃣-依赖管理（自动安装第三方包）\"><a href=\"#2️⃣-依赖管理（自动安装第三方包）\" class=\"headerlink\" title=\"2️⃣ 依赖管理（自动安装第三方包）\"></a>2️⃣ 依赖管理（自动安装第三方包）</h3><p>这是 <code>package.json</code> 最强大的功能！</p>\n<h4 id=\"✅-dependencies：项目运行必须的包\"><a href=\"#✅-dependencies：项目运行必须的包\" class=\"headerlink\" title=\"✅ dependencies：项目运行必须的包\"></a>✅ <code>dependencies</code>：项目运行必须的包</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;lodash&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^4.17.21&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;react&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^18.0.0&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行 <code>npm install</code> 时，会自动下载这些包到 <code>node_modules</code></li>\n<li>别人拿到你的项目，一运行 <code>npm install</code>，所有依赖自动装好</li>\n</ul>\n<h4 id=\"✅-devDependencies：开发时用的工具\"><a href=\"#✅-devDependencies：开发时用的工具\" class=\"headerlink\" title=\"✅ devDependencies：开发时用的工具\"></a>✅ <code>devDependencies</code>：开发时用的工具</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;devDependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;vite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^4.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;eslint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^8.0.0&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>比如打包工具、代码检查工具</li>\n<li>发布包时，别人不需要这些（但你开发时需要）</li>\n</ul>\n<blockquote>\n<p>🔑 核心价值：<strong>告别“手动下载 JS 文件”时代，实现依赖自动化管理</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"3️⃣-脚本命令（快捷方式）\"><a href=\"#3️⃣-脚本命令（快捷方式）\" class=\"headerlink\" title=\"3️⃣ 脚本命令（快捷方式）\"></a>3️⃣ 脚本命令（快捷方式）</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;start&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;node index.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;build&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;babel src -d lib&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;test&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;jest&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start   → 执行 node index.js</span><br><span class=\"line\">npm run build   → 执行 babel src -d lib</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：把复杂命令简化成一句话，团队协作时统一操作方式。</p>\n</blockquote>\n<hr>\n<h3 id=\"4️⃣-包入口（别人怎么引用你）\"><a href=\"#4️⃣-包入口（别人怎么引用你）\" class=\"headerlink\" title=\"4️⃣ 包入口（别人怎么引用你）\"></a>4️⃣ 包入口（别人怎么引用你）</h3><p>当你发布一个 npm 包时，这些字段告诉别人“从哪开始用”：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lib/index.js&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">// Node.js require 用</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;browser&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dist/index.js&quot;</span><span class=\"punctuation\">,</span>       <span class=\"comment\">// 浏览器打包用</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es/index.js&quot;</span>           <span class=\"comment\">// 支持 tree-shaking 的格式</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：让别人能正确加载你的代码。</p>\n</blockquote>\n<hr>\n<h3 id=\"5️⃣-发布控制\"><a href=\"#5️⃣-发布控制\" class=\"headerlink\" title=\"5️⃣ 发布控制\"></a>5️⃣ 发布控制</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;files&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;lib&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;dist&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>         <span class=\"comment\">// 只发布这些文件</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                  <span class=\"comment\">// 设为 true 就不能发布到共有仓库 防止不小心发包</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;publishConfig&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;registry&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://my-registry.com&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：控制包的发布行为。</p>\n</blockquote>\n<hr>\n<h3 id=\"6️⃣-其他工具配置（一配置多用）\"><a href=\"#6️⃣-其他工具配置（一配置多用）\" class=\"headerlink\" title=\"6️⃣ 其他工具配置（一配置多用）\"></a>6️⃣ 其他工具配置（一配置多用）</h3><p>很多工具会读 <code>package.json</code>，比如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;eslintConfig&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;rules&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;semi&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;error&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;browserslist&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"string\">&quot;&gt; 1%&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"string\">&quot;last 2 versions&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：不用单独写 <code>.eslintrc</code>、<code>.browserslistrc</code> 文件，全在 <code>package.json</code> 里配。</p>\n</blockquote>\n<hr>\n<h2 id=\"📌-总结：package-json-的-6-大作用\"><a href=\"#📌-总结：package-json-的-6-大作用\" class=\"headerlink\" title=\"📌 总结：package.json 的 6 大作用\"></a>📌 总结：<code>package.json</code> 的 6 大作用</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th>关键字段</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. 项目介绍</td>\n<td><code>name</code>, <code>version</code>, <code>description</code></td>\n<td>别人一看就知道这是啥</td>\n</tr>\n<tr>\n<td>2. 依赖管理</td>\n<td><code>dependencies</code>, <code>devDependencies</code></td>\n<td><code>npm install</code> 自动装包</td>\n</tr>\n<tr>\n<td>3. 命令快捷方式</td>\n<td><code>scripts</code></td>\n<td><code>npm run build</code> 打包</td>\n</tr>\n<tr>\n<td>4. 包入口</td>\n<td><code>main</code>, <code>browser</code></td>\n<td>别人 <code>require</code> 时从哪开始</td>\n</tr>\n<tr>\n<td>5. 发布控制</td>\n<td><code>files</code>, <code>private</code></td>\n<td>控制发布内容</td>\n</tr>\n<tr>\n<td>6. 工具配置</td>\n<td><code>eslintConfig</code>, <code>browserslist</code></td>\n<td>统一开发规范</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-什么时候会用到-package-json？\"><a href=\"#✅-什么时候会用到-package-json？\" class=\"headerlink\" title=\"✅ 什么时候会用到 package.json？\"></a>✅ 什么时候会用到 <code>package.json</code>？</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>用到 <code>package.json</code> 吗？</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>创建新项目</td>\n<td>✅ <code>npm init</code> 生成它</td>\n</tr>\n<tr>\n<td>安装包</td>\n<td>✅ <code>npm install xxx</code> 会写入 <code>dependencies</code></td>\n</tr>\n<tr>\n<td>运行项目</td>\n<td>✅ <code>npm start</code> 读 <code>scripts</code></td>\n</tr>\n<tr>\n<td>发布包</td>\n<td>✅ 必须有 <code>name</code>, <code>version</code>, <code>main</code></td>\n</tr>\n<tr>\n<td>别人使用你的项目</td>\n<td>✅ 他们靠它知道怎么运行</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🎯-最后一句话\"><a href=\"#🎯-最后一句话\" class=\"headerlink\" title=\"🎯 最后一句话\"></a>🎯 最后一句话</h2><blockquote>\n<p><code>package.json</code> 是 <strong>现代 JavaScript 项目的“身份证 + 操作手册 + 依赖清单”三位一体的核心文件</strong>。<br>没有它，npm 就不知道你是谁、用什么、怎么运行。</p>\n</blockquote>\n<hr>\n<p>现在你对 <code>package.json</code> 的理解就非常完整了！🎉<br>如果你要开发任何 JS 项目（前端、后端、工具库），都绕不开它。</p>\n","excerpt":"","more":"<hr>\n<h2 id=\"✅-一句话总结\"><a href=\"#✅-一句话总结\" class=\"headerlink\" title=\"✅ 一句话总结\"></a>✅ 一句话总结</h2><blockquote>\n<p><code>package.json</code> 是一个 <strong>项目说明书</strong>，它告诉：</p>\n<ul>\n<li><strong>你</strong>：这个项目依赖哪些包、怎么运行</li>\n<li><strong>npm &#x2F; yarn &#x2F; pnpm</strong>：怎么安装、发布、管理这个项目</li>\n<li><strong>别人</strong>：这是个什么项目、怎么使用它</li>\n</ul>\n</blockquote>\n<p>它就像一本书的“封面 + 目录 + 前言”。</p>\n<hr>\n<h2 id=\"🧩-举个生活例子：开餐馆\"><a href=\"#🧩-举个生活例子：开餐馆\" class=\"headerlink\" title=\"🧩 举个生活例子：开餐馆\"></a>🧩 举个生活例子：开餐馆</h2><table>\n<thead>\n<tr>\n<th>类比</th>\n<th>对应 <code>package.json</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>餐馆名字</td>\n<td><code>&quot;name&quot;: &quot;小王面馆&quot;</code></td>\n</tr>\n<tr>\n<td>菜单（有什么菜）</td>\n<td><code>&quot;scripts&quot;</code>：<code>start</code>, <code>build</code> 等命令</td>\n</tr>\n<tr>\n<td>食材从哪进货</td>\n<td><code>&quot;dependencies&quot;</code>：用了哪些 npm 包</td>\n</tr>\n<tr>\n<td>厨房用什么工具（炒菜用燃气灶）</td>\n<td><code>&quot;devDependencies&quot;</code>：开发时用的工具</td>\n</tr>\n<tr>\n<td>客人怎么点餐</td>\n<td><code>&quot;main&quot;</code>：别人 <code>require</code> 时从哪开始</td>\n</tr>\n<tr>\n<td>餐馆地址、电话、营业时间</td>\n<td><code>&quot;version&quot;</code>, <code>&quot;description&quot;</code>, <code>&quot;author&quot;</code>, <code>&quot;license&quot;</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔍-核心作用分类\"><a href=\"#🔍-核心作用分类\" class=\"headerlink\" title=\"🔍 核心作用分类\"></a>🔍 核心作用分类</h2><h3 id=\"1️⃣-项目元信息（基本信息）\"><a href=\"#1️⃣-项目元信息（基本信息）\" class=\"headerlink\" title=\"1️⃣ 项目元信息（基本信息）\"></a>1️⃣ 项目元信息（基本信息）</h3><p>这些是“介绍项目”的字段：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;my-app&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;一个简单的计算器应用&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;author&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;小明&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;license&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;MIT&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;homepage&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://github.com/xiaoming/my-app#readme&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;repository&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;git&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;url&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://github.com/xiaoming/my-app.git&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：别人一看就知道这是什么项目、谁写的、能不能商用（license）、代码在哪。</p>\n</blockquote>\n<hr>\n<h3 id=\"2️⃣-依赖管理（自动安装第三方包）\"><a href=\"#2️⃣-依赖管理（自动安装第三方包）\" class=\"headerlink\" title=\"2️⃣ 依赖管理（自动安装第三方包）\"></a>2️⃣ 依赖管理（自动安装第三方包）</h3><p>这是 <code>package.json</code> 最强大的功能！</p>\n<h4 id=\"✅-dependencies：项目运行必须的包\"><a href=\"#✅-dependencies：项目运行必须的包\" class=\"headerlink\" title=\"✅ dependencies：项目运行必须的包\"></a>✅ <code>dependencies</code>：项目运行必须的包</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;dependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;lodash&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^4.17.21&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;react&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^18.0.0&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行 <code>npm install</code> 时，会自动下载这些包到 <code>node_modules</code></li>\n<li>别人拿到你的项目，一运行 <code>npm install</code>，所有依赖自动装好</li>\n</ul>\n<h4 id=\"✅-devDependencies：开发时用的工具\"><a href=\"#✅-devDependencies：开发时用的工具\" class=\"headerlink\" title=\"✅ devDependencies：开发时用的工具\"></a>✅ <code>devDependencies</code>：开发时用的工具</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;devDependencies&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;vite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^4.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;eslint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^8.0.0&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>比如打包工具、代码检查工具</li>\n<li>发布包时，别人不需要这些（但你开发时需要）</li>\n</ul>\n<blockquote>\n<p>🔑 核心价值：<strong>告别“手动下载 JS 文件”时代，实现依赖自动化管理</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"3️⃣-脚本命令（快捷方式）\"><a href=\"#3️⃣-脚本命令（快捷方式）\" class=\"headerlink\" title=\"3️⃣ 脚本命令（快捷方式）\"></a>3️⃣ 脚本命令（快捷方式）</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;start&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;node index.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;build&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;babel src -d lib&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;test&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;jest&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start   → 执行 node index.js</span><br><span class=\"line\">npm run build   → 执行 babel src -d lib</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：把复杂命令简化成一句话，团队协作时统一操作方式。</p>\n</blockquote>\n<hr>\n<h3 id=\"4️⃣-包入口（别人怎么引用你）\"><a href=\"#4️⃣-包入口（别人怎么引用你）\" class=\"headerlink\" title=\"4️⃣ 包入口（别人怎么引用你）\"></a>4️⃣ 包入口（别人怎么引用你）</h3><p>当你发布一个 npm 包时，这些字段告诉别人“从哪开始用”：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lib/index.js&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">// Node.js require 用</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;browser&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dist/index.js&quot;</span><span class=\"punctuation\">,</span>       <span class=\"comment\">// 浏览器打包用</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es/index.js&quot;</span>           <span class=\"comment\">// 支持 tree-shaking 的格式</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：让别人能正确加载你的代码。</p>\n</blockquote>\n<hr>\n<h3 id=\"5️⃣-发布控制\"><a href=\"#5️⃣-发布控制\" class=\"headerlink\" title=\"5️⃣ 发布控制\"></a>5️⃣ 发布控制</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;files&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;lib&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;dist&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>         <span class=\"comment\">// 只发布这些文件</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                  <span class=\"comment\">// 设为 true 就不能发布到共有仓库 防止不小心发包</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;publishConfig&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;registry&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://my-registry.com&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：控制包的发布行为。</p>\n</blockquote>\n<hr>\n<h3 id=\"6️⃣-其他工具配置（一配置多用）\"><a href=\"#6️⃣-其他工具配置（一配置多用）\" class=\"headerlink\" title=\"6️⃣ 其他工具配置（一配置多用）\"></a>6️⃣ 其他工具配置（一配置多用）</h3><p>很多工具会读 <code>package.json</code>，比如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;eslintConfig&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;rules&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;semi&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;error&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;browserslist&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"string\">&quot;&gt; 1%&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"string\">&quot;last 2 versions&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>✅ 作用：不用单独写 <code>.eslintrc</code>、<code>.browserslistrc</code> 文件，全在 <code>package.json</code> 里配。</p>\n</blockquote>\n<hr>\n<h2 id=\"📌-总结：package-json-的-6-大作用\"><a href=\"#📌-总结：package-json-的-6-大作用\" class=\"headerlink\" title=\"📌 总结：package.json 的 6 大作用\"></a>📌 总结：<code>package.json</code> 的 6 大作用</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th>关键字段</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. 项目介绍</td>\n<td><code>name</code>, <code>version</code>, <code>description</code></td>\n<td>别人一看就知道这是啥</td>\n</tr>\n<tr>\n<td>2. 依赖管理</td>\n<td><code>dependencies</code>, <code>devDependencies</code></td>\n<td><code>npm install</code> 自动装包</td>\n</tr>\n<tr>\n<td>3. 命令快捷方式</td>\n<td><code>scripts</code></td>\n<td><code>npm run build</code> 打包</td>\n</tr>\n<tr>\n<td>4. 包入口</td>\n<td><code>main</code>, <code>browser</code></td>\n<td>别人 <code>require</code> 时从哪开始</td>\n</tr>\n<tr>\n<td>5. 发布控制</td>\n<td><code>files</code>, <code>private</code></td>\n<td>控制发布内容</td>\n</tr>\n<tr>\n<td>6. 工具配置</td>\n<td><code>eslintConfig</code>, <code>browserslist</code></td>\n<td>统一开发规范</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-什么时候会用到-package-json？\"><a href=\"#✅-什么时候会用到-package-json？\" class=\"headerlink\" title=\"✅ 什么时候会用到 package.json？\"></a>✅ 什么时候会用到 <code>package.json</code>？</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>用到 <code>package.json</code> 吗？</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>创建新项目</td>\n<td>✅ <code>npm init</code> 生成它</td>\n</tr>\n<tr>\n<td>安装包</td>\n<td>✅ <code>npm install xxx</code> 会写入 <code>dependencies</code></td>\n</tr>\n<tr>\n<td>运行项目</td>\n<td>✅ <code>npm start</code> 读 <code>scripts</code></td>\n</tr>\n<tr>\n<td>发布包</td>\n<td>✅ 必须有 <code>name</code>, <code>version</code>, <code>main</code></td>\n</tr>\n<tr>\n<td>别人使用你的项目</td>\n<td>✅ 他们靠它知道怎么运行</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🎯-最后一句话\"><a href=\"#🎯-最后一句话\" class=\"headerlink\" title=\"🎯 最后一句话\"></a>🎯 最后一句话</h2><blockquote>\n<p><code>package.json</code> 是 <strong>现代 JavaScript 项目的“身份证 + 操作手册 + 依赖清单”三位一体的核心文件</strong>。<br>没有它，npm 就不知道你是谁、用什么、怎么运行。</p>\n</blockquote>\n<hr>\n<p>现在你对 <code>package.json</code> 的理解就非常完整了！🎉<br>如果你要开发任何 JS 项目（前端、后端、工具库），都绕不开它。</p>\n"},{"title":"什么是 Monorepo (单一代码仓库)","_content":"\n> 前置技能 npm工具的简单了解\n\n\nMonorepo 是一种软件开发策略，它将多个项目、模块、包或应用程序的代码存储在同一个版本控制仓库（Repository）中。这与传统的 Multirepo（多仓库）模式形成对比，后者是为每个项目或模块创建一个独立的仓库。\n\n- Monorepo (单一仓库): 所有代码都在一个大仓库里，比如 my-company-monorepo/，里面可能包含 packages/frontend/, packages/backend/, packages/shared-utils/, apps/mobile-app/ 等。\n- Multirepo (多仓库): 每个项目或模块都有自己的独立仓库，比如 frontend-repo/, backend-repo/, shared-utils-repo/, mobile-app-repo/。\n## 快速启动学习\n\nMonorepo 的核心思想是将多个项目放在一个仓库里，但要让这种模式高效、可管理，必须依赖一系列**具体的工具和技术栈**来解决随之而来的挑战（如依赖管理、构建、测试、发布、代码组织等）。\n\n以下是 Monorepo 开发模式中关键的具体实现技术和工具，按功能领域划分：\n\n---\n\n### 1. 包管理与依赖解析 (Package Management & Dependency Resolution)\n\n这是 Monorepo 的基础，用于管理内部包（packages）之间的依赖关系和外部依赖。\n\n*   **npm/yarn/pnpm Workspaces**:\n    *   **作用**: 这是最底层的基础设施。它们允许在单个根 `package.json` 中定义多个子包（位于 `packages/` 或 `libs/` 目录下），并自动解析和链接这些内部包之间的依赖。\n    *   **原理**: 使用符号链接 (`symlinks`) 将内部包链接到 `node_modules`，使得 `import` 或 `require` 可以像引用外部包一样引用内部包（例如 `import { util } from '@myorg/shared-utils'`）。\n    *   **特点**: 轻量级，是其他高级工具的基础。`pnpm` 因其高效的硬链接和内容寻址存储，在大型 Monorepo 中尤其受欢迎，能显著节省磁盘空间和安装时间。\n\n*   **Lerna**:\n    *   **作用**: 一个较早的、专门为 JavaScript/TypeScript Monorepo 设计的工具。它建立在 `npm`/`yarn` workspaces 之上，主要提供：\n        *   **Bootstrapping**: 安装所有包的依赖并链接内部包。\n        *   **版本管理**: 协助管理包的版本号（支持固定/锁定版本或独立版本）。\n        *   **发布**: 自动化发布包到 npm registry。\n        *   **运行脚本**: 在多个包上并行运行 npm scripts (如 `lerna run build`)。\n    *   **特点**: 功能全面，但本身不提供增量构建，性能优化依赖于其他工具。\n\n---\n\n### 2. 构建、测试与任务调度 (Build, Test & Task Orchestration)\n\n这是解决 Monorepo 性能瓶颈（全量构建/测试太慢）的核心。关键在于**增量构建**和**影响分析**。\n\n*   **Turborepo**:\n    *   **作用**: 由 Vercel 开发，目前非常流行的高性能构建系统。它深度集成 `npm`/`yarn`/`pnpm` workspaces。\n    *   **核心技术**:\n        *   **智能缓存 (Smart Caching)**: 将任务（如 `build`, `test`, `lint`）的输出缓存到本地或云端。如果输入（源码、依赖、配置）未变，直接复用缓存结果，避免重复执行。\n        *   **增量构建 (Incremental Builds)**: 结合缓存，只重新构建真正发生变化的包及其下游依赖。\n        *   **并行执行**: 自动并行运行独立的任务。\n        *   **任务图 (Task Graph)**: 分析任务之间的依赖关系（如 `app` 依赖 `lib`，`build` 依赖 `lint`）。\n        *   **远程缓存**: 团队成员共享缓存，极大加速 CI/CD 和新开发者环境搭建。\n    *   **特点**: 配置简单（通常只需 `turbo.json`），性能提升显著，尤其适合 React、Next.js 等生态。\n\n*   **Nx**:\n    *   **作用**: 一个功能极其强大的 Monorepo 平台，由 Nrwl 开发。它不仅是一个构建工具，更是一个完整的开发框架。\n    *   **核心技术**:\n        *   **计算任务图 (Computationally Generated Task Graph)**: Nx 会分析代码中的 `import` 语句来构建精确的**项目依赖图**。\n        *   **影响分析 (Affected Commands)**: `nx affected:build` 等命令能精确计算出当前变更（基于 Git）影响了哪些项目，只执行这些项目的任务。\n        *   **分布式任务执行 (DTE)**: 将任务分发到多台机器或云端执行。\n        *   **远程缓存**: 类似 Turborepo。\n        *   **代码生成器 (Generators)**: 提供大量预设的代码生成器（`nx generate`），用于快速创建应用、库、组件等，保证结构一致性。\n        *   **插件生态**: 支持 Angular, React, Node.js, NestJS, Web Components, 甚至 .NET, Python 等。\n    *   **特点**: 功能全面，学习曲线稍陡，但提供了从代码生成到部署的完整解决方案，适合大型复杂项目。\n\n*   **Bazel**:\n    *   **作用**: Google 开发的通用、可扩展的构建和测试工具，是 Google 内部超大 Monorepo 的基石。\n    *   **核心技术**:\n        *   **声明式构建**: 使用 `BUILD` 文件（基于 Starlark 语言）明确声明每个构建目标的输入、输出、依赖和构建规则。\n        *   **确定性构建**: 保证相同输入产生相同输出。\n        *   **强大的缓存和远程执行**: 支持本地和远程缓存/执行，效率极高。\n        *   **多语言支持**: 原生支持 C++, Java, Python, JavaScript, Go 等。\n    *   **特点**: 性能顶尖，可扩展性强，但配置复杂，学习成本高。适合对构建性能和可重现性有极致要求的大型组织。\n\n*   **Pants**:\n    *   **作用**: 另一个类似 Bazel 的快速、可扩展的 Python 优先的构建系统，也支持 JVM, Go, Node.js, Shell 等。\n    *   **特点**: 设计哲学与 Bazel 类似，强调速度和可扩展性，配置也相对复杂。\n\n---\n\n### 3. 代码组织与结构 (Code Organization)\n\n*   **目录结构约定**:\n    *   常见模式：`/apps` (存放可部署的应用), `/libs` 或 `/packages` (存放可复用的库/模块), `/tools` (存放自定义脚本/工具), `/docs` (文档)。\n    *   例如：\n        ```\n        my-monorepo/\n        ├── apps/\n        │   ├── web-app/\n        │   ├── mobile-app/\n        │   └── admin-dashboard/\n        ├── libs/\n        │   ├── shared-ui/\n        │   ├── data-access/\n        │   └── utils/\n        ├── tools/\n        ├── package.json (根)\n        ├── turbo.json / nx.json / bazel.rc\n        └── ...\n        ```\n\n*   **路径别名 (Path Aliasing)**:\n    *   在 TypeScript (`tsconfig.json`) 或 Webpack/Vite 等打包工具中配置路径别名，方便跨包导入。\n    *   例如：`\"paths\": { \"@myorg/shared-ui\": [\"libs/shared-ui/src/index.ts\"] }`。\n\n---\n\n### 4. 版本管理与发布 (Versioning & Publishing)\n\n*   **工具集成**: `Lerna`, `Nx`, `Turborepo` 都提供了发布功能。\n*   **策略**:\n    *   **固定/锁定版本 (Fixed/Locked)**: 所有包共享一个版本号（如 Lerna 的默认模式）。简单，但版本号意义不大。\n    *   **独立版本 (Independent)**: 每个包独立管理自己的版本号（语义化版本）。更灵活，更能反映实际变更。\n*   **自动化发布**: 结合 CI/CD 流程，当主分支合并后，自动检测变更的包，生成变更日志，更新版本号，并发布到包管理器（npm, private registry）。\n\n---\n\n### 5. CI/CD 集成 (CI/CD Integration)\n\n*   **核心原则**: **只运行受影响的任务**。\n*   **实现方式**:\n    *   利用 `Nx affected`, `Turborepo` 的缓存/影响分析、`Bazel` 的增量构建特性。\n    *   CI 脚本首先确定自上次成功构建以来哪些文件被修改（`git diff`），然后调用工具命令（如 `nx affected:build --base=origin/main`）来精确执行必要的构建、测试和 lint 任务。\n    *   结合远程缓存，避免重复工作。\n\n---\n\n### 6. 代码质量与规范 (Code Quality & Standards)\n\n*   **统一配置**: 在根目录配置 ESLint, Prettier, Stylelint 等，并在所有子项目中继承。\n*   **预提交钩子 (Pre-commit Hooks)**: 使用 `Husky` + `lint-staged` 在代码提交前自动格式化和检查代码，保证一致性。\n\n---\n\n### 总结：典型技术栈组合\n\n1.  **轻量级/快速启动**:\n    *   `pnpm workspaces` + `Turborepo`\n    *   优点：简单易上手，性能好，现代前端项目首选。\n\n2.  **大型复杂项目/企业级**:\n    *   `Nx` (提供最完整的解决方案)\n    *   `Bazel` (追求极致性能和可重现性，多语言)\n    *   优点：功能强大，可扩展性好，治理能力强。\n\n3.  **传统/已存在**:\n    *   `yarn workspaces` + `Lerna`\n    *   优点：成熟稳定，社区支持好。\n\n**选择哪个技术栈取决于你的具体需求：项目规模、技术栈、团队偏好、对性能和功能的要求。** `Turborepo` 和 `Nx` 是当前 JavaScript/TypeScript 生态中最主流和活跃的选择。","source":"_posts/Monorepo（单一代码仓库）.md","raw":"---\ntitle: 什么是 Monorepo (单一代码仓库)\n---\n\n> 前置技能 npm工具的简单了解\n\n\nMonorepo 是一种软件开发策略，它将多个项目、模块、包或应用程序的代码存储在同一个版本控制仓库（Repository）中。这与传统的 Multirepo（多仓库）模式形成对比，后者是为每个项目或模块创建一个独立的仓库。\n\n- Monorepo (单一仓库): 所有代码都在一个大仓库里，比如 my-company-monorepo/，里面可能包含 packages/frontend/, packages/backend/, packages/shared-utils/, apps/mobile-app/ 等。\n- Multirepo (多仓库): 每个项目或模块都有自己的独立仓库，比如 frontend-repo/, backend-repo/, shared-utils-repo/, mobile-app-repo/。\n## 快速启动学习\n\nMonorepo 的核心思想是将多个项目放在一个仓库里，但要让这种模式高效、可管理，必须依赖一系列**具体的工具和技术栈**来解决随之而来的挑战（如依赖管理、构建、测试、发布、代码组织等）。\n\n以下是 Monorepo 开发模式中关键的具体实现技术和工具，按功能领域划分：\n\n---\n\n### 1. 包管理与依赖解析 (Package Management & Dependency Resolution)\n\n这是 Monorepo 的基础，用于管理内部包（packages）之间的依赖关系和外部依赖。\n\n*   **npm/yarn/pnpm Workspaces**:\n    *   **作用**: 这是最底层的基础设施。它们允许在单个根 `package.json` 中定义多个子包（位于 `packages/` 或 `libs/` 目录下），并自动解析和链接这些内部包之间的依赖。\n    *   **原理**: 使用符号链接 (`symlinks`) 将内部包链接到 `node_modules`，使得 `import` 或 `require` 可以像引用外部包一样引用内部包（例如 `import { util } from '@myorg/shared-utils'`）。\n    *   **特点**: 轻量级，是其他高级工具的基础。`pnpm` 因其高效的硬链接和内容寻址存储，在大型 Monorepo 中尤其受欢迎，能显著节省磁盘空间和安装时间。\n\n*   **Lerna**:\n    *   **作用**: 一个较早的、专门为 JavaScript/TypeScript Monorepo 设计的工具。它建立在 `npm`/`yarn` workspaces 之上，主要提供：\n        *   **Bootstrapping**: 安装所有包的依赖并链接内部包。\n        *   **版本管理**: 协助管理包的版本号（支持固定/锁定版本或独立版本）。\n        *   **发布**: 自动化发布包到 npm registry。\n        *   **运行脚本**: 在多个包上并行运行 npm scripts (如 `lerna run build`)。\n    *   **特点**: 功能全面，但本身不提供增量构建，性能优化依赖于其他工具。\n\n---\n\n### 2. 构建、测试与任务调度 (Build, Test & Task Orchestration)\n\n这是解决 Monorepo 性能瓶颈（全量构建/测试太慢）的核心。关键在于**增量构建**和**影响分析**。\n\n*   **Turborepo**:\n    *   **作用**: 由 Vercel 开发，目前非常流行的高性能构建系统。它深度集成 `npm`/`yarn`/`pnpm` workspaces。\n    *   **核心技术**:\n        *   **智能缓存 (Smart Caching)**: 将任务（如 `build`, `test`, `lint`）的输出缓存到本地或云端。如果输入（源码、依赖、配置）未变，直接复用缓存结果，避免重复执行。\n        *   **增量构建 (Incremental Builds)**: 结合缓存，只重新构建真正发生变化的包及其下游依赖。\n        *   **并行执行**: 自动并行运行独立的任务。\n        *   **任务图 (Task Graph)**: 分析任务之间的依赖关系（如 `app` 依赖 `lib`，`build` 依赖 `lint`）。\n        *   **远程缓存**: 团队成员共享缓存，极大加速 CI/CD 和新开发者环境搭建。\n    *   **特点**: 配置简单（通常只需 `turbo.json`），性能提升显著，尤其适合 React、Next.js 等生态。\n\n*   **Nx**:\n    *   **作用**: 一个功能极其强大的 Monorepo 平台，由 Nrwl 开发。它不仅是一个构建工具，更是一个完整的开发框架。\n    *   **核心技术**:\n        *   **计算任务图 (Computationally Generated Task Graph)**: Nx 会分析代码中的 `import` 语句来构建精确的**项目依赖图**。\n        *   **影响分析 (Affected Commands)**: `nx affected:build` 等命令能精确计算出当前变更（基于 Git）影响了哪些项目，只执行这些项目的任务。\n        *   **分布式任务执行 (DTE)**: 将任务分发到多台机器或云端执行。\n        *   **远程缓存**: 类似 Turborepo。\n        *   **代码生成器 (Generators)**: 提供大量预设的代码生成器（`nx generate`），用于快速创建应用、库、组件等，保证结构一致性。\n        *   **插件生态**: 支持 Angular, React, Node.js, NestJS, Web Components, 甚至 .NET, Python 等。\n    *   **特点**: 功能全面，学习曲线稍陡，但提供了从代码生成到部署的完整解决方案，适合大型复杂项目。\n\n*   **Bazel**:\n    *   **作用**: Google 开发的通用、可扩展的构建和测试工具，是 Google 内部超大 Monorepo 的基石。\n    *   **核心技术**:\n        *   **声明式构建**: 使用 `BUILD` 文件（基于 Starlark 语言）明确声明每个构建目标的输入、输出、依赖和构建规则。\n        *   **确定性构建**: 保证相同输入产生相同输出。\n        *   **强大的缓存和远程执行**: 支持本地和远程缓存/执行，效率极高。\n        *   **多语言支持**: 原生支持 C++, Java, Python, JavaScript, Go 等。\n    *   **特点**: 性能顶尖，可扩展性强，但配置复杂，学习成本高。适合对构建性能和可重现性有极致要求的大型组织。\n\n*   **Pants**:\n    *   **作用**: 另一个类似 Bazel 的快速、可扩展的 Python 优先的构建系统，也支持 JVM, Go, Node.js, Shell 等。\n    *   **特点**: 设计哲学与 Bazel 类似，强调速度和可扩展性，配置也相对复杂。\n\n---\n\n### 3. 代码组织与结构 (Code Organization)\n\n*   **目录结构约定**:\n    *   常见模式：`/apps` (存放可部署的应用), `/libs` 或 `/packages` (存放可复用的库/模块), `/tools` (存放自定义脚本/工具), `/docs` (文档)。\n    *   例如：\n        ```\n        my-monorepo/\n        ├── apps/\n        │   ├── web-app/\n        │   ├── mobile-app/\n        │   └── admin-dashboard/\n        ├── libs/\n        │   ├── shared-ui/\n        │   ├── data-access/\n        │   └── utils/\n        ├── tools/\n        ├── package.json (根)\n        ├── turbo.json / nx.json / bazel.rc\n        └── ...\n        ```\n\n*   **路径别名 (Path Aliasing)**:\n    *   在 TypeScript (`tsconfig.json`) 或 Webpack/Vite 等打包工具中配置路径别名，方便跨包导入。\n    *   例如：`\"paths\": { \"@myorg/shared-ui\": [\"libs/shared-ui/src/index.ts\"] }`。\n\n---\n\n### 4. 版本管理与发布 (Versioning & Publishing)\n\n*   **工具集成**: `Lerna`, `Nx`, `Turborepo` 都提供了发布功能。\n*   **策略**:\n    *   **固定/锁定版本 (Fixed/Locked)**: 所有包共享一个版本号（如 Lerna 的默认模式）。简单，但版本号意义不大。\n    *   **独立版本 (Independent)**: 每个包独立管理自己的版本号（语义化版本）。更灵活，更能反映实际变更。\n*   **自动化发布**: 结合 CI/CD 流程，当主分支合并后，自动检测变更的包，生成变更日志，更新版本号，并发布到包管理器（npm, private registry）。\n\n---\n\n### 5. CI/CD 集成 (CI/CD Integration)\n\n*   **核心原则**: **只运行受影响的任务**。\n*   **实现方式**:\n    *   利用 `Nx affected`, `Turborepo` 的缓存/影响分析、`Bazel` 的增量构建特性。\n    *   CI 脚本首先确定自上次成功构建以来哪些文件被修改（`git diff`），然后调用工具命令（如 `nx affected:build --base=origin/main`）来精确执行必要的构建、测试和 lint 任务。\n    *   结合远程缓存，避免重复工作。\n\n---\n\n### 6. 代码质量与规范 (Code Quality & Standards)\n\n*   **统一配置**: 在根目录配置 ESLint, Prettier, Stylelint 等，并在所有子项目中继承。\n*   **预提交钩子 (Pre-commit Hooks)**: 使用 `Husky` + `lint-staged` 在代码提交前自动格式化和检查代码，保证一致性。\n\n---\n\n### 总结：典型技术栈组合\n\n1.  **轻量级/快速启动**:\n    *   `pnpm workspaces` + `Turborepo`\n    *   优点：简单易上手，性能好，现代前端项目首选。\n\n2.  **大型复杂项目/企业级**:\n    *   `Nx` (提供最完整的解决方案)\n    *   `Bazel` (追求极致性能和可重现性，多语言)\n    *   优点：功能强大，可扩展性好，治理能力强。\n\n3.  **传统/已存在**:\n    *   `yarn workspaces` + `Lerna`\n    *   优点：成熟稳定，社区支持好。\n\n**选择哪个技术栈取决于你的具体需求：项目规模、技术栈、团队偏好、对性能和功能的要求。** `Turborepo` 和 `Nx` 是当前 JavaScript/TypeScript 生态中最主流和活跃的选择。","slug":"Monorepo（单一代码仓库）","published":1,"date":"2025-09-02T01:50:34.931Z","updated":"2025-09-01T09:54:01.769Z","_id":"cmf1wufal000sq4v9c4pw2rri","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>前置技能 npm工具的简单了解</p>\n</blockquote>\n<p>Monorepo 是一种软件开发策略，它将多个项目、模块、包或应用程序的代码存储在同一个版本控制仓库（Repository）中。这与传统的 Multirepo（多仓库）模式形成对比，后者是为每个项目或模块创建一个独立的仓库。</p>\n<ul>\n<li>Monorepo (单一仓库): 所有代码都在一个大仓库里，比如 my-company-monorepo&#x2F;，里面可能包含 packages&#x2F;frontend&#x2F;, packages&#x2F;backend&#x2F;, packages&#x2F;shared-utils&#x2F;, apps&#x2F;mobile-app&#x2F; 等。</li>\n<li>Multirepo (多仓库): 每个项目或模块都有自己的独立仓库，比如 frontend-repo&#x2F;, backend-repo&#x2F;, shared-utils-repo&#x2F;, mobile-app-repo&#x2F;。</li>\n</ul>\n<h2 id=\"快速启动学习\"><a href=\"#快速启动学习\" class=\"headerlink\" title=\"快速启动学习\"></a>快速启动学习</h2><p>Monorepo 的核心思想是将多个项目放在一个仓库里，但要让这种模式高效、可管理，必须依赖一系列<strong>具体的工具和技术栈</strong>来解决随之而来的挑战（如依赖管理、构建、测试、发布、代码组织等）。</p>\n<p>以下是 Monorepo 开发模式中关键的具体实现技术和工具，按功能领域划分：</p>\n<hr>\n<h3 id=\"1-包管理与依赖解析-Package-Management-Dependency-Resolution\"><a href=\"#1-包管理与依赖解析-Package-Management-Dependency-Resolution\" class=\"headerlink\" title=\"1. 包管理与依赖解析 (Package Management &amp; Dependency Resolution)\"></a>1. 包管理与依赖解析 (Package Management &amp; Dependency Resolution)</h3><p>这是 Monorepo 的基础，用于管理内部包（packages）之间的依赖关系和外部依赖。</p>\n<ul>\n<li><p><strong>npm&#x2F;yarn&#x2F;pnpm Workspaces</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 这是最底层的基础设施。它们允许在单个根 <code>package.json</code> 中定义多个子包（位于 <code>packages/</code> 或 <code>libs/</code> 目录下），并自动解析和链接这些内部包之间的依赖。</li>\n<li><strong>原理</strong>: 使用符号链接 (<code>symlinks</code>) 将内部包链接到 <code>node_modules</code>，使得 <code>import</code> 或 <code>require</code> 可以像引用外部包一样引用内部包（例如 <code>import &#123; util &#125; from &#39;@myorg/shared-utils&#39;</code>）。</li>\n<li><strong>特点</strong>: 轻量级，是其他高级工具的基础。<code>pnpm</code> 因其高效的硬链接和内容寻址存储，在大型 Monorepo 中尤其受欢迎，能显著节省磁盘空间和安装时间。</li>\n</ul>\n</li>\n<li><p><strong>Lerna</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 一个较早的、专门为 JavaScript&#x2F;TypeScript Monorepo 设计的工具。它建立在 <code>npm</code>&#x2F;<code>yarn</code> workspaces 之上，主要提供：<ul>\n<li><strong>Bootstrapping</strong>: 安装所有包的依赖并链接内部包。</li>\n<li><strong>版本管理</strong>: 协助管理包的版本号（支持固定&#x2F;锁定版本或独立版本）。</li>\n<li><strong>发布</strong>: 自动化发布包到 npm registry。</li>\n<li><strong>运行脚本</strong>: 在多个包上并行运行 npm scripts (如 <code>lerna run build</code>)。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 功能全面，但本身不提供增量构建，性能优化依赖于其他工具。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-构建、测试与任务调度-Build-Test-Task-Orchestration\"><a href=\"#2-构建、测试与任务调度-Build-Test-Task-Orchestration\" class=\"headerlink\" title=\"2. 构建、测试与任务调度 (Build, Test &amp; Task Orchestration)\"></a>2. 构建、测试与任务调度 (Build, Test &amp; Task Orchestration)</h3><p>这是解决 Monorepo 性能瓶颈（全量构建&#x2F;测试太慢）的核心。关键在于<strong>增量构建</strong>和<strong>影响分析</strong>。</p>\n<ul>\n<li><p><strong>Turborepo</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 由 Vercel 开发，目前非常流行的高性能构建系统。它深度集成 <code>npm</code>&#x2F;<code>yarn</code>&#x2F;<code>pnpm</code> workspaces。</li>\n<li><strong>核心技术</strong>:<ul>\n<li><strong>智能缓存 (Smart Caching)</strong>: 将任务（如 <code>build</code>, <code>test</code>, <code>lint</code>）的输出缓存到本地或云端。如果输入（源码、依赖、配置）未变，直接复用缓存结果，避免重复执行。</li>\n<li><strong>增量构建 (Incremental Builds)</strong>: 结合缓存，只重新构建真正发生变化的包及其下游依赖。</li>\n<li><strong>并行执行</strong>: 自动并行运行独立的任务。</li>\n<li><strong>任务图 (Task Graph)</strong>: 分析任务之间的依赖关系（如 <code>app</code> 依赖 <code>lib</code>，<code>build</code> 依赖 <code>lint</code>）。</li>\n<li><strong>远程缓存</strong>: 团队成员共享缓存，极大加速 CI&#x2F;CD 和新开发者环境搭建。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 配置简单（通常只需 <code>turbo.json</code>），性能提升显著，尤其适合 React、Next.js 等生态。</li>\n</ul>\n</li>\n<li><p><strong>Nx</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 一个功能极其强大的 Monorepo 平台，由 Nrwl 开发。它不仅是一个构建工具，更是一个完整的开发框架。</li>\n<li><strong>核心技术</strong>:<ul>\n<li><strong>计算任务图 (Computationally Generated Task Graph)</strong>: Nx 会分析代码中的 <code>import</code> 语句来构建精确的<strong>项目依赖图</strong>。</li>\n<li><strong>影响分析 (Affected Commands)</strong>: <code>nx affected:build</code> 等命令能精确计算出当前变更（基于 Git）影响了哪些项目，只执行这些项目的任务。</li>\n<li><strong>分布式任务执行 (DTE)</strong>: 将任务分发到多台机器或云端执行。</li>\n<li><strong>远程缓存</strong>: 类似 Turborepo。</li>\n<li><strong>代码生成器 (Generators)</strong>: 提供大量预设的代码生成器（<code>nx generate</code>），用于快速创建应用、库、组件等，保证结构一致性。</li>\n<li><strong>插件生态</strong>: 支持 Angular, React, Node.js, NestJS, Web Components, 甚至 .NET, Python 等。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 功能全面，学习曲线稍陡，但提供了从代码生成到部署的完整解决方案，适合大型复杂项目。</li>\n</ul>\n</li>\n<li><p><strong>Bazel</strong>:</p>\n<ul>\n<li><strong>作用</strong>: Google 开发的通用、可扩展的构建和测试工具，是 Google 内部超大 Monorepo 的基石。</li>\n<li><strong>核心技术</strong>:<ul>\n<li><strong>声明式构建</strong>: 使用 <code>BUILD</code> 文件（基于 Starlark 语言）明确声明每个构建目标的输入、输出、依赖和构建规则。</li>\n<li><strong>确定性构建</strong>: 保证相同输入产生相同输出。</li>\n<li><strong>强大的缓存和远程执行</strong>: 支持本地和远程缓存&#x2F;执行，效率极高。</li>\n<li><strong>多语言支持</strong>: 原生支持 C++, Java, Python, JavaScript, Go 等。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 性能顶尖，可扩展性强，但配置复杂，学习成本高。适合对构建性能和可重现性有极致要求的大型组织。</li>\n</ul>\n</li>\n<li><p><strong>Pants</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 另一个类似 Bazel 的快速、可扩展的 Python 优先的构建系统，也支持 JVM, Go, Node.js, Shell 等。</li>\n<li><strong>特点</strong>: 设计哲学与 Bazel 类似，强调速度和可扩展性，配置也相对复杂。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-代码组织与结构-Code-Organization\"><a href=\"#3-代码组织与结构-Code-Organization\" class=\"headerlink\" title=\"3. 代码组织与结构 (Code Organization)\"></a>3. 代码组织与结构 (Code Organization)</h3><ul>\n<li><p><strong>目录结构约定</strong>:</p>\n<ul>\n<li>常见模式：<code>/apps</code> (存放可部署的应用), <code>/libs</code> 或 <code>/packages</code> (存放可复用的库&#x2F;模块), <code>/tools</code> (存放自定义脚本&#x2F;工具), <code>/docs</code> (文档)。</li>\n<li>例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── apps/</span><br><span class=\"line\">│   ├── web-app/</span><br><span class=\"line\">│   ├── mobile-app/</span><br><span class=\"line\">│   └── admin-dashboard/</span><br><span class=\"line\">├── libs/</span><br><span class=\"line\">│   ├── shared-ui/</span><br><span class=\"line\">│   ├── data-access/</span><br><span class=\"line\">│   └── utils/</span><br><span class=\"line\">├── tools/</span><br><span class=\"line\">├── package.json (根)</span><br><span class=\"line\">├── turbo.json / nx.json / bazel.rc</span><br><span class=\"line\">└── ...</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>路径别名 (Path Aliasing)</strong>:</p>\n<ul>\n<li>在 TypeScript (<code>tsconfig.json</code>) 或 Webpack&#x2F;Vite 等打包工具中配置路径别名，方便跨包导入。</li>\n<li>例如：<code>&quot;paths&quot;: &#123; &quot;@myorg/shared-ui&quot;: [&quot;libs/shared-ui/src/index.ts&quot;] &#125;</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"4-版本管理与发布-Versioning-Publishing\"><a href=\"#4-版本管理与发布-Versioning-Publishing\" class=\"headerlink\" title=\"4. 版本管理与发布 (Versioning &amp; Publishing)\"></a>4. 版本管理与发布 (Versioning &amp; Publishing)</h3><ul>\n<li><strong>工具集成</strong>: <code>Lerna</code>, <code>Nx</code>, <code>Turborepo</code> 都提供了发布功能。</li>\n<li><strong>策略</strong>:<ul>\n<li><strong>固定&#x2F;锁定版本 (Fixed&#x2F;Locked)</strong>: 所有包共享一个版本号（如 Lerna 的默认模式）。简单，但版本号意义不大。</li>\n<li><strong>独立版本 (Independent)</strong>: 每个包独立管理自己的版本号（语义化版本）。更灵活，更能反映实际变更。</li>\n</ul>\n</li>\n<li><strong>自动化发布</strong>: 结合 CI&#x2F;CD 流程，当主分支合并后，自动检测变更的包，生成变更日志，更新版本号，并发布到包管理器（npm, private registry）。</li>\n</ul>\n<hr>\n<h3 id=\"5-CI-CD-集成-CI-CD-Integration\"><a href=\"#5-CI-CD-集成-CI-CD-Integration\" class=\"headerlink\" title=\"5. CI&#x2F;CD 集成 (CI&#x2F;CD Integration)\"></a>5. CI&#x2F;CD 集成 (CI&#x2F;CD Integration)</h3><ul>\n<li><strong>核心原则</strong>: <strong>只运行受影响的任务</strong>。</li>\n<li><strong>实现方式</strong>:<ul>\n<li>利用 <code>Nx affected</code>, <code>Turborepo</code> 的缓存&#x2F;影响分析、<code>Bazel</code> 的增量构建特性。</li>\n<li>CI 脚本首先确定自上次成功构建以来哪些文件被修改（<code>git diff</code>），然后调用工具命令（如 <code>nx affected:build --base=origin/main</code>）来精确执行必要的构建、测试和 lint 任务。</li>\n<li>结合远程缓存，避免重复工作。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"6-代码质量与规范-Code-Quality-Standards\"><a href=\"#6-代码质量与规范-Code-Quality-Standards\" class=\"headerlink\" title=\"6. 代码质量与规范 (Code Quality &amp; Standards)\"></a>6. 代码质量与规范 (Code Quality &amp; Standards)</h3><ul>\n<li><strong>统一配置</strong>: 在根目录配置 ESLint, Prettier, Stylelint 等，并在所有子项目中继承。</li>\n<li><strong>预提交钩子 (Pre-commit Hooks)</strong>: 使用 <code>Husky</code> + <code>lint-staged</code> 在代码提交前自动格式化和检查代码，保证一致性。</li>\n</ul>\n<hr>\n<h3 id=\"总结：典型技术栈组合\"><a href=\"#总结：典型技术栈组合\" class=\"headerlink\" title=\"总结：典型技术栈组合\"></a>总结：典型技术栈组合</h3><ol>\n<li><p><strong>轻量级&#x2F;快速启动</strong>:</p>\n<ul>\n<li><code>pnpm workspaces</code> + <code>Turborepo</code></li>\n<li>优点：简单易上手，性能好，现代前端项目首选。</li>\n</ul>\n</li>\n<li><p><strong>大型复杂项目&#x2F;企业级</strong>:</p>\n<ul>\n<li><code>Nx</code> (提供最完整的解决方案)</li>\n<li><code>Bazel</code> (追求极致性能和可重现性，多语言)</li>\n<li>优点：功能强大，可扩展性好，治理能力强。</li>\n</ul>\n</li>\n<li><p><strong>传统&#x2F;已存在</strong>:</p>\n<ul>\n<li><code>yarn workspaces</code> + <code>Lerna</code></li>\n<li>优点：成熟稳定，社区支持好。</li>\n</ul>\n</li>\n</ol>\n<p><strong>选择哪个技术栈取决于你的具体需求：项目规模、技术栈、团队偏好、对性能和功能的要求。</strong> <code>Turborepo</code> 和 <code>Nx</code> 是当前 JavaScript&#x2F;TypeScript 生态中最主流和活跃的选择。</p>\n","excerpt":"","more":"<blockquote>\n<p>前置技能 npm工具的简单了解</p>\n</blockquote>\n<p>Monorepo 是一种软件开发策略，它将多个项目、模块、包或应用程序的代码存储在同一个版本控制仓库（Repository）中。这与传统的 Multirepo（多仓库）模式形成对比，后者是为每个项目或模块创建一个独立的仓库。</p>\n<ul>\n<li>Monorepo (单一仓库): 所有代码都在一个大仓库里，比如 my-company-monorepo&#x2F;，里面可能包含 packages&#x2F;frontend&#x2F;, packages&#x2F;backend&#x2F;, packages&#x2F;shared-utils&#x2F;, apps&#x2F;mobile-app&#x2F; 等。</li>\n<li>Multirepo (多仓库): 每个项目或模块都有自己的独立仓库，比如 frontend-repo&#x2F;, backend-repo&#x2F;, shared-utils-repo&#x2F;, mobile-app-repo&#x2F;。</li>\n</ul>\n<h2 id=\"快速启动学习\"><a href=\"#快速启动学习\" class=\"headerlink\" title=\"快速启动学习\"></a>快速启动学习</h2><p>Monorepo 的核心思想是将多个项目放在一个仓库里，但要让这种模式高效、可管理，必须依赖一系列<strong>具体的工具和技术栈</strong>来解决随之而来的挑战（如依赖管理、构建、测试、发布、代码组织等）。</p>\n<p>以下是 Monorepo 开发模式中关键的具体实现技术和工具，按功能领域划分：</p>\n<hr>\n<h3 id=\"1-包管理与依赖解析-Package-Management-Dependency-Resolution\"><a href=\"#1-包管理与依赖解析-Package-Management-Dependency-Resolution\" class=\"headerlink\" title=\"1. 包管理与依赖解析 (Package Management &amp; Dependency Resolution)\"></a>1. 包管理与依赖解析 (Package Management &amp; Dependency Resolution)</h3><p>这是 Monorepo 的基础，用于管理内部包（packages）之间的依赖关系和外部依赖。</p>\n<ul>\n<li><p><strong>npm&#x2F;yarn&#x2F;pnpm Workspaces</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 这是最底层的基础设施。它们允许在单个根 <code>package.json</code> 中定义多个子包（位于 <code>packages/</code> 或 <code>libs/</code> 目录下），并自动解析和链接这些内部包之间的依赖。</li>\n<li><strong>原理</strong>: 使用符号链接 (<code>symlinks</code>) 将内部包链接到 <code>node_modules</code>，使得 <code>import</code> 或 <code>require</code> 可以像引用外部包一样引用内部包（例如 <code>import &#123; util &#125; from &#39;@myorg/shared-utils&#39;</code>）。</li>\n<li><strong>特点</strong>: 轻量级，是其他高级工具的基础。<code>pnpm</code> 因其高效的硬链接和内容寻址存储，在大型 Monorepo 中尤其受欢迎，能显著节省磁盘空间和安装时间。</li>\n</ul>\n</li>\n<li><p><strong>Lerna</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 一个较早的、专门为 JavaScript&#x2F;TypeScript Monorepo 设计的工具。它建立在 <code>npm</code>&#x2F;<code>yarn</code> workspaces 之上，主要提供：<ul>\n<li><strong>Bootstrapping</strong>: 安装所有包的依赖并链接内部包。</li>\n<li><strong>版本管理</strong>: 协助管理包的版本号（支持固定&#x2F;锁定版本或独立版本）。</li>\n<li><strong>发布</strong>: 自动化发布包到 npm registry。</li>\n<li><strong>运行脚本</strong>: 在多个包上并行运行 npm scripts (如 <code>lerna run build</code>)。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 功能全面，但本身不提供增量构建，性能优化依赖于其他工具。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-构建、测试与任务调度-Build-Test-Task-Orchestration\"><a href=\"#2-构建、测试与任务调度-Build-Test-Task-Orchestration\" class=\"headerlink\" title=\"2. 构建、测试与任务调度 (Build, Test &amp; Task Orchestration)\"></a>2. 构建、测试与任务调度 (Build, Test &amp; Task Orchestration)</h3><p>这是解决 Monorepo 性能瓶颈（全量构建&#x2F;测试太慢）的核心。关键在于<strong>增量构建</strong>和<strong>影响分析</strong>。</p>\n<ul>\n<li><p><strong>Turborepo</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 由 Vercel 开发，目前非常流行的高性能构建系统。它深度集成 <code>npm</code>&#x2F;<code>yarn</code>&#x2F;<code>pnpm</code> workspaces。</li>\n<li><strong>核心技术</strong>:<ul>\n<li><strong>智能缓存 (Smart Caching)</strong>: 将任务（如 <code>build</code>, <code>test</code>, <code>lint</code>）的输出缓存到本地或云端。如果输入（源码、依赖、配置）未变，直接复用缓存结果，避免重复执行。</li>\n<li><strong>增量构建 (Incremental Builds)</strong>: 结合缓存，只重新构建真正发生变化的包及其下游依赖。</li>\n<li><strong>并行执行</strong>: 自动并行运行独立的任务。</li>\n<li><strong>任务图 (Task Graph)</strong>: 分析任务之间的依赖关系（如 <code>app</code> 依赖 <code>lib</code>，<code>build</code> 依赖 <code>lint</code>）。</li>\n<li><strong>远程缓存</strong>: 团队成员共享缓存，极大加速 CI&#x2F;CD 和新开发者环境搭建。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 配置简单（通常只需 <code>turbo.json</code>），性能提升显著，尤其适合 React、Next.js 等生态。</li>\n</ul>\n</li>\n<li><p><strong>Nx</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 一个功能极其强大的 Monorepo 平台，由 Nrwl 开发。它不仅是一个构建工具，更是一个完整的开发框架。</li>\n<li><strong>核心技术</strong>:<ul>\n<li><strong>计算任务图 (Computationally Generated Task Graph)</strong>: Nx 会分析代码中的 <code>import</code> 语句来构建精确的<strong>项目依赖图</strong>。</li>\n<li><strong>影响分析 (Affected Commands)</strong>: <code>nx affected:build</code> 等命令能精确计算出当前变更（基于 Git）影响了哪些项目，只执行这些项目的任务。</li>\n<li><strong>分布式任务执行 (DTE)</strong>: 将任务分发到多台机器或云端执行。</li>\n<li><strong>远程缓存</strong>: 类似 Turborepo。</li>\n<li><strong>代码生成器 (Generators)</strong>: 提供大量预设的代码生成器（<code>nx generate</code>），用于快速创建应用、库、组件等，保证结构一致性。</li>\n<li><strong>插件生态</strong>: 支持 Angular, React, Node.js, NestJS, Web Components, 甚至 .NET, Python 等。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 功能全面，学习曲线稍陡，但提供了从代码生成到部署的完整解决方案，适合大型复杂项目。</li>\n</ul>\n</li>\n<li><p><strong>Bazel</strong>:</p>\n<ul>\n<li><strong>作用</strong>: Google 开发的通用、可扩展的构建和测试工具，是 Google 内部超大 Monorepo 的基石。</li>\n<li><strong>核心技术</strong>:<ul>\n<li><strong>声明式构建</strong>: 使用 <code>BUILD</code> 文件（基于 Starlark 语言）明确声明每个构建目标的输入、输出、依赖和构建规则。</li>\n<li><strong>确定性构建</strong>: 保证相同输入产生相同输出。</li>\n<li><strong>强大的缓存和远程执行</strong>: 支持本地和远程缓存&#x2F;执行，效率极高。</li>\n<li><strong>多语言支持</strong>: 原生支持 C++, Java, Python, JavaScript, Go 等。</li>\n</ul>\n</li>\n<li><strong>特点</strong>: 性能顶尖，可扩展性强，但配置复杂，学习成本高。适合对构建性能和可重现性有极致要求的大型组织。</li>\n</ul>\n</li>\n<li><p><strong>Pants</strong>:</p>\n<ul>\n<li><strong>作用</strong>: 另一个类似 Bazel 的快速、可扩展的 Python 优先的构建系统，也支持 JVM, Go, Node.js, Shell 等。</li>\n<li><strong>特点</strong>: 设计哲学与 Bazel 类似，强调速度和可扩展性，配置也相对复杂。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-代码组织与结构-Code-Organization\"><a href=\"#3-代码组织与结构-Code-Organization\" class=\"headerlink\" title=\"3. 代码组织与结构 (Code Organization)\"></a>3. 代码组织与结构 (Code Organization)</h3><ul>\n<li><p><strong>目录结构约定</strong>:</p>\n<ul>\n<li>常见模式：<code>/apps</code> (存放可部署的应用), <code>/libs</code> 或 <code>/packages</code> (存放可复用的库&#x2F;模块), <code>/tools</code> (存放自定义脚本&#x2F;工具), <code>/docs</code> (文档)。</li>\n<li>例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-monorepo/</span><br><span class=\"line\">├── apps/</span><br><span class=\"line\">│   ├── web-app/</span><br><span class=\"line\">│   ├── mobile-app/</span><br><span class=\"line\">│   └── admin-dashboard/</span><br><span class=\"line\">├── libs/</span><br><span class=\"line\">│   ├── shared-ui/</span><br><span class=\"line\">│   ├── data-access/</span><br><span class=\"line\">│   └── utils/</span><br><span class=\"line\">├── tools/</span><br><span class=\"line\">├── package.json (根)</span><br><span class=\"line\">├── turbo.json / nx.json / bazel.rc</span><br><span class=\"line\">└── ...</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>路径别名 (Path Aliasing)</strong>:</p>\n<ul>\n<li>在 TypeScript (<code>tsconfig.json</code>) 或 Webpack&#x2F;Vite 等打包工具中配置路径别名，方便跨包导入。</li>\n<li>例如：<code>&quot;paths&quot;: &#123; &quot;@myorg/shared-ui&quot;: [&quot;libs/shared-ui/src/index.ts&quot;] &#125;</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"4-版本管理与发布-Versioning-Publishing\"><a href=\"#4-版本管理与发布-Versioning-Publishing\" class=\"headerlink\" title=\"4. 版本管理与发布 (Versioning &amp; Publishing)\"></a>4. 版本管理与发布 (Versioning &amp; Publishing)</h3><ul>\n<li><strong>工具集成</strong>: <code>Lerna</code>, <code>Nx</code>, <code>Turborepo</code> 都提供了发布功能。</li>\n<li><strong>策略</strong>:<ul>\n<li><strong>固定&#x2F;锁定版本 (Fixed&#x2F;Locked)</strong>: 所有包共享一个版本号（如 Lerna 的默认模式）。简单，但版本号意义不大。</li>\n<li><strong>独立版本 (Independent)</strong>: 每个包独立管理自己的版本号（语义化版本）。更灵活，更能反映实际变更。</li>\n</ul>\n</li>\n<li><strong>自动化发布</strong>: 结合 CI&#x2F;CD 流程，当主分支合并后，自动检测变更的包，生成变更日志，更新版本号，并发布到包管理器（npm, private registry）。</li>\n</ul>\n<hr>\n<h3 id=\"5-CI-CD-集成-CI-CD-Integration\"><a href=\"#5-CI-CD-集成-CI-CD-Integration\" class=\"headerlink\" title=\"5. CI&#x2F;CD 集成 (CI&#x2F;CD Integration)\"></a>5. CI&#x2F;CD 集成 (CI&#x2F;CD Integration)</h3><ul>\n<li><strong>核心原则</strong>: <strong>只运行受影响的任务</strong>。</li>\n<li><strong>实现方式</strong>:<ul>\n<li>利用 <code>Nx affected</code>, <code>Turborepo</code> 的缓存&#x2F;影响分析、<code>Bazel</code> 的增量构建特性。</li>\n<li>CI 脚本首先确定自上次成功构建以来哪些文件被修改（<code>git diff</code>），然后调用工具命令（如 <code>nx affected:build --base=origin/main</code>）来精确执行必要的构建、测试和 lint 任务。</li>\n<li>结合远程缓存，避免重复工作。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"6-代码质量与规范-Code-Quality-Standards\"><a href=\"#6-代码质量与规范-Code-Quality-Standards\" class=\"headerlink\" title=\"6. 代码质量与规范 (Code Quality &amp; Standards)\"></a>6. 代码质量与规范 (Code Quality &amp; Standards)</h3><ul>\n<li><strong>统一配置</strong>: 在根目录配置 ESLint, Prettier, Stylelint 等，并在所有子项目中继承。</li>\n<li><strong>预提交钩子 (Pre-commit Hooks)</strong>: 使用 <code>Husky</code> + <code>lint-staged</code> 在代码提交前自动格式化和检查代码，保证一致性。</li>\n</ul>\n<hr>\n<h3 id=\"总结：典型技术栈组合\"><a href=\"#总结：典型技术栈组合\" class=\"headerlink\" title=\"总结：典型技术栈组合\"></a>总结：典型技术栈组合</h3><ol>\n<li><p><strong>轻量级&#x2F;快速启动</strong>:</p>\n<ul>\n<li><code>pnpm workspaces</code> + <code>Turborepo</code></li>\n<li>优点：简单易上手，性能好，现代前端项目首选。</li>\n</ul>\n</li>\n<li><p><strong>大型复杂项目&#x2F;企业级</strong>:</p>\n<ul>\n<li><code>Nx</code> (提供最完整的解决方案)</li>\n<li><code>Bazel</code> (追求极致性能和可重现性，多语言)</li>\n<li>优点：功能强大，可扩展性好，治理能力强。</li>\n</ul>\n</li>\n<li><p><strong>传统&#x2F;已存在</strong>:</p>\n<ul>\n<li><code>yarn workspaces</code> + <code>Lerna</code></li>\n<li>优点：成熟稳定，社区支持好。</li>\n</ul>\n</li>\n</ol>\n<p><strong>选择哪个技术栈取决于你的具体需求：项目规模、技术栈、团队偏好、对性能和功能的要求。</strong> <code>Turborepo</code> 和 <code>Nx</code> 是当前 JavaScript&#x2F;TypeScript 生态中最主流和活跃的选择。</p>\n"},{"title":"file 协议","_content":"\n---\n\n## 🎯 一、`file:` 协议是什么？\n\n> 🔥 **一句话定义**：  \n> `file:` 协议是一种 URL 格式，用来指向你**本地硬盘上的文件**，就像文件资源管理器的路径一样。\n\n---\n\n\n## 📁 二、基本语法\n\n```text\nfile:[//<host>]<path>\n     └──┬───┘ └──┬──┘\n        │       └── 路径（必须）\n        └───────── 主机名（可选）\n```\n\n### 常见形式：\n\n| 格式 | 说明 | 示例 |\n|------|------|------|\n| `file:///路径` | 本地文件（最常见） | `file:///C:/Users/Alice/docs/hello.txt` |\n| `file://主机名/路径` | 网络共享文件（少见） | `file://server/shared/report.pdf` |\n\n> ✅ 三个斜杠 `///`：前两个是 语法中的`://`，第三个表示“根目录”\n\n---\n\n## 🌰 三、实际例子\n\n### 1. 打开本地 HTML 文件\n\n```text\nfile:///Users/Alice/project/index.html\n```\n\n👉 在浏览器地址栏输入，就能打开你电脑上的 `index.html`\n\n### 2. 引用本地图片\n\n```html\n<img src=\"file:///Users/Alice/Pictures/photo.jpg\" />\n```\n\n### 3. Node.js 中使用\n\n```js\nconst url = 'file:///Users/Alice/data.json';\nrequire('fs').readFileSync(url.slice(7)); // 去掉 file://\n```\n\n---\n\n## 🧩 四、和普通路径的区别\n\n| 类型 | 示例 | 说明 |\n|------|------|------|\n| 普通文件路径 | `C:\\Users\\Alice\\file.txt` | 操作系统用 |\n| `file:` URL | `file:///C:/Users/Alice/file.txt` | 浏览器/程序用的标准格式 |\n| 相对路径 | `./docs/file.txt` | 相对于当前目录 |\n\n> ✅ `file:` 是 **跨平台的标准 URL 格式**\n\n---\n\n## 🔐 五、浏览器中的安全限制 ⚠️\n\n虽然你可以用 `file:` 打开本地文件，但现代浏览器有严格限制：\n\n### ❌ 不能做什么？\n\n| 操作 | 是否允许 | 说明 |\n|------|----------|------|\n| `file:///` 页面加载 `file:///` 脚本 | ❌ 通常禁止 | 安全策略 |\n| `file:///` 页面发起 AJAX 请求 | ❌ 禁止 | 不能读本地文件 |\n| `file:///` 页面使用 `import` 加载本地模块 | ❌ 大多数浏览器禁止 | CORS 限制 |\n\n### ✅ 能做什么？\n\n- 直接打开 `file:///index.html` 查看静态页面\n- 页面引用同目录的图片、CSS（有时允许）\n- 本地测试简单 HTML（无 JS 交互）\n\n---\n\n## 🛠️ 六、实际用途\n\n### 1. ✅ 快速预览 HTML 文件\n- 双击 `.html` 文件 → 浏览器用 `file://` 打开\n- 适合静态页面原型演示\n\n### 2. ✅ Electron / 桌面应用\n- Electron 应用可以用 `file:` 加载本地资源\n- 因为它有更高权限\n\n### 3. ✅ VS Code 预览\n- VS Code 的 \"Open in Browser\" 插件会用 `file:` 协议\n\n### 4. ✅ 本地文档查看\n- 本地 Markdown 生成的 HTML 文档\n\n---\n\n## 🚫 七、不适合做什么？\n\n| 场景 | 为什么不行 |\n|------|-----------|\n| Web 开发调试 | 会有 CORS、模块加载等问题 |\n| 使用 npm 包 | 无法解析 `node_modules` |\n| AJAX 请求本地文件 | 浏览器禁止 |\n| 使用 `import` 模块 | 需要服务器支持 |\n\n👉 **开发时建议用本地服务器**：\n```bash\nnpx serve  # 或 python -m http.server\n```\n\n---\n\n## 🔄 八、和其他协议对比\n\n| 协议 | 示例 | 用途 |\n|------|------|------|\n| `http://` | `http://example.com` | 网站（明文） |\n| `https://` | `https://google.com` | 网站（加密） |\n| `file://` | `file:///C:/doc.txt` | 本地文件 |\n| `data:` | `data:text/plain,Hello` | 内联数据 |\n| `blob:` | `blob:https://...` | 二进制大对象 |\n\n---\n\n## ✅ 九、总结\n\n> - ✅ `file:` 协议 = 访问**本地文件**的 URL 方式\n> - ✅ 格式：`file:///路径`（三个斜杠）\n> - ⚠️ 浏览器有安全限制，不能用于复杂 Web 开发\n> - ✅ 适合：预览静态页面、本地文档、桌面应用\n> - 🚫 不适合：开发调试（建议用 `http://localhost`）\n\n---\n\n## 💡 小技巧\n\n想在浏览器打开本地文件？  \n把文件拖到浏览器标签页，地址栏就会显示 `file://...`！\n\n","source":"_posts/flle协议.md","raw":"---\ntitle: file 协议\n---\n\n---\n\n## 🎯 一、`file:` 协议是什么？\n\n> 🔥 **一句话定义**：  \n> `file:` 协议是一种 URL 格式，用来指向你**本地硬盘上的文件**，就像文件资源管理器的路径一样。\n\n---\n\n\n## 📁 二、基本语法\n\n```text\nfile:[//<host>]<path>\n     └──┬───┘ └──┬──┘\n        │       └── 路径（必须）\n        └───────── 主机名（可选）\n```\n\n### 常见形式：\n\n| 格式 | 说明 | 示例 |\n|------|------|------|\n| `file:///路径` | 本地文件（最常见） | `file:///C:/Users/Alice/docs/hello.txt` |\n| `file://主机名/路径` | 网络共享文件（少见） | `file://server/shared/report.pdf` |\n\n> ✅ 三个斜杠 `///`：前两个是 语法中的`://`，第三个表示“根目录”\n\n---\n\n## 🌰 三、实际例子\n\n### 1. 打开本地 HTML 文件\n\n```text\nfile:///Users/Alice/project/index.html\n```\n\n👉 在浏览器地址栏输入，就能打开你电脑上的 `index.html`\n\n### 2. 引用本地图片\n\n```html\n<img src=\"file:///Users/Alice/Pictures/photo.jpg\" />\n```\n\n### 3. Node.js 中使用\n\n```js\nconst url = 'file:///Users/Alice/data.json';\nrequire('fs').readFileSync(url.slice(7)); // 去掉 file://\n```\n\n---\n\n## 🧩 四、和普通路径的区别\n\n| 类型 | 示例 | 说明 |\n|------|------|------|\n| 普通文件路径 | `C:\\Users\\Alice\\file.txt` | 操作系统用 |\n| `file:` URL | `file:///C:/Users/Alice/file.txt` | 浏览器/程序用的标准格式 |\n| 相对路径 | `./docs/file.txt` | 相对于当前目录 |\n\n> ✅ `file:` 是 **跨平台的标准 URL 格式**\n\n---\n\n## 🔐 五、浏览器中的安全限制 ⚠️\n\n虽然你可以用 `file:` 打开本地文件，但现代浏览器有严格限制：\n\n### ❌ 不能做什么？\n\n| 操作 | 是否允许 | 说明 |\n|------|----------|------|\n| `file:///` 页面加载 `file:///` 脚本 | ❌ 通常禁止 | 安全策略 |\n| `file:///` 页面发起 AJAX 请求 | ❌ 禁止 | 不能读本地文件 |\n| `file:///` 页面使用 `import` 加载本地模块 | ❌ 大多数浏览器禁止 | CORS 限制 |\n\n### ✅ 能做什么？\n\n- 直接打开 `file:///index.html` 查看静态页面\n- 页面引用同目录的图片、CSS（有时允许）\n- 本地测试简单 HTML（无 JS 交互）\n\n---\n\n## 🛠️ 六、实际用途\n\n### 1. ✅ 快速预览 HTML 文件\n- 双击 `.html` 文件 → 浏览器用 `file://` 打开\n- 适合静态页面原型演示\n\n### 2. ✅ Electron / 桌面应用\n- Electron 应用可以用 `file:` 加载本地资源\n- 因为它有更高权限\n\n### 3. ✅ VS Code 预览\n- VS Code 的 \"Open in Browser\" 插件会用 `file:` 协议\n\n### 4. ✅ 本地文档查看\n- 本地 Markdown 生成的 HTML 文档\n\n---\n\n## 🚫 七、不适合做什么？\n\n| 场景 | 为什么不行 |\n|------|-----------|\n| Web 开发调试 | 会有 CORS、模块加载等问题 |\n| 使用 npm 包 | 无法解析 `node_modules` |\n| AJAX 请求本地文件 | 浏览器禁止 |\n| 使用 `import` 模块 | 需要服务器支持 |\n\n👉 **开发时建议用本地服务器**：\n```bash\nnpx serve  # 或 python -m http.server\n```\n\n---\n\n## 🔄 八、和其他协议对比\n\n| 协议 | 示例 | 用途 |\n|------|------|------|\n| `http://` | `http://example.com` | 网站（明文） |\n| `https://` | `https://google.com` | 网站（加密） |\n| `file://` | `file:///C:/doc.txt` | 本地文件 |\n| `data:` | `data:text/plain,Hello` | 内联数据 |\n| `blob:` | `blob:https://...` | 二进制大对象 |\n\n---\n\n## ✅ 九、总结\n\n> - ✅ `file:` 协议 = 访问**本地文件**的 URL 方式\n> - ✅ 格式：`file:///路径`（三个斜杠）\n> - ⚠️ 浏览器有安全限制，不能用于复杂 Web 开发\n> - ✅ 适合：预览静态页面、本地文档、桌面应用\n> - 🚫 不适合：开发调试（建议用 `http://localhost`）\n\n---\n\n## 💡 小技巧\n\n想在浏览器打开本地文件？  \n把文件拖到浏览器标签页，地址栏就会显示 `file://...`！\n\n","slug":"flle协议","published":1,"date":"2025-09-02T01:50:34.939Z","updated":"2025-09-01T09:54:01.770Z","_id":"cmf1wujbd000tq4v95jsv1r7h","comments":1,"layout":"post","photos":[],"content":"<hr>\n<h2 id=\"🎯-一、file-协议是什么？\"><a href=\"#🎯-一、file-协议是什么？\" class=\"headerlink\" title=\"🎯 一、file: 协议是什么？\"></a>🎯 一、<code>file:</code> 协议是什么？</h2><blockquote>\n<p>🔥 <strong>一句话定义</strong>：<br><code>file:</code> 协议是一种 URL 格式，用来指向你<strong>本地硬盘上的文件</strong>，就像文件资源管理器的路径一样。</p>\n</blockquote>\n<hr>\n<h2 id=\"📁-二、基本语法\"><a href=\"#📁-二、基本语法\" class=\"headerlink\" title=\"📁 二、基本语法\"></a>📁 二、基本语法</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file:[//&lt;host&gt;]&lt;path&gt;</span><br><span class=\"line\">     └──┬───┘ └──┬──┘</span><br><span class=\"line\">        │       └── 路径（必须）</span><br><span class=\"line\">        └───────── 主机名（可选）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见形式：\"><a href=\"#常见形式：\" class=\"headerlink\" title=\"常见形式：\"></a>常见形式：</h3><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file:///路径</code></td>\n<td>本地文件（最常见）</td>\n<td><code>file:///C:/Users/Alice/docs/hello.txt</code></td>\n</tr>\n<tr>\n<td><code>file://主机名/路径</code></td>\n<td>网络共享文件（少见）</td>\n<td><code>file://server/shared/report.pdf</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ 三个斜杠 <code>///</code>：前两个是 语法中的<code>://</code>，第三个表示“根目录”</p>\n</blockquote>\n<hr>\n<h2 id=\"🌰-三、实际例子\"><a href=\"#🌰-三、实际例子\" class=\"headerlink\" title=\"🌰 三、实际例子\"></a>🌰 三、实际例子</h2><h3 id=\"1-打开本地-HTML-文件\"><a href=\"#1-打开本地-HTML-文件\" class=\"headerlink\" title=\"1. 打开本地 HTML 文件\"></a>1. 打开本地 HTML 文件</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file:///Users/Alice/project/index.html</span><br></pre></td></tr></table></figure>\n\n<p>👉 在浏览器地址栏输入，就能打开你电脑上的 <code>index.html</code></p>\n<h3 id=\"2-引用本地图片\"><a href=\"#2-引用本地图片\" class=\"headerlink\" title=\"2. 引用本地图片\"></a>2. 引用本地图片</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;file:///Users/Alice/Pictures/photo.jpg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Node-js-中使用\"><a href=\"#3-Node-js-中使用\" class=\"headerlink\" title=\"3. Node.js 中使用\"></a>3. Node.js 中使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"string\">&#x27;file:///Users/Alice/data.json&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>).<span class=\"title function_\">readFileSync</span>(url.<span class=\"title function_\">slice</span>(<span class=\"number\">7</span>)); <span class=\"comment\">// 去掉 file://</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧩-四、和普通路径的区别\"><a href=\"#🧩-四、和普通路径的区别\" class=\"headerlink\" title=\"🧩 四、和普通路径的区别\"></a>🧩 四、和普通路径的区别</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>普通文件路径</td>\n<td><code>C:\\Users\\Alice\\file.txt</code></td>\n<td>操作系统用</td>\n</tr>\n<tr>\n<td><code>file:</code> URL</td>\n<td><code>file:///C:/Users/Alice/file.txt</code></td>\n<td>浏览器&#x2F;程序用的标准格式</td>\n</tr>\n<tr>\n<td>相对路径</td>\n<td><code>./docs/file.txt</code></td>\n<td>相对于当前目录</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ <code>file:</code> 是 <strong>跨平台的标准 URL 格式</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"🔐-五、浏览器中的安全限制-⚠️\"><a href=\"#🔐-五、浏览器中的安全限制-⚠️\" class=\"headerlink\" title=\"🔐 五、浏览器中的安全限制 ⚠️\"></a>🔐 五、浏览器中的安全限制 ⚠️</h2><p>虽然你可以用 <code>file:</code> 打开本地文件，但现代浏览器有严格限制：</p>\n<h3 id=\"❌-不能做什么？\"><a href=\"#❌-不能做什么？\" class=\"headerlink\" title=\"❌ 不能做什么？\"></a>❌ 不能做什么？</h3><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>是否允许</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file:///</code> 页面加载 <code>file:///</code> 脚本</td>\n<td>❌ 通常禁止</td>\n<td>安全策略</td>\n</tr>\n<tr>\n<td><code>file:///</code> 页面发起 AJAX 请求</td>\n<td>❌ 禁止</td>\n<td>不能读本地文件</td>\n</tr>\n<tr>\n<td><code>file:///</code> 页面使用 <code>import</code> 加载本地模块</td>\n<td>❌ 大多数浏览器禁止</td>\n<td>CORS 限制</td>\n</tr>\n</tbody></table>\n<h3 id=\"✅-能做什么？\"><a href=\"#✅-能做什么？\" class=\"headerlink\" title=\"✅ 能做什么？\"></a>✅ 能做什么？</h3><ul>\n<li>直接打开 <code>file:///index.html</code> 查看静态页面</li>\n<li>页面引用同目录的图片、CSS（有时允许）</li>\n<li>本地测试简单 HTML（无 JS 交互）</li>\n</ul>\n<hr>\n<h2 id=\"🛠️-六、实际用途\"><a href=\"#🛠️-六、实际用途\" class=\"headerlink\" title=\"🛠️ 六、实际用途\"></a>🛠️ 六、实际用途</h2><h3 id=\"1-✅-快速预览-HTML-文件\"><a href=\"#1-✅-快速预览-HTML-文件\" class=\"headerlink\" title=\"1. ✅ 快速预览 HTML 文件\"></a>1. ✅ 快速预览 HTML 文件</h3><ul>\n<li>双击 <code>.html</code> 文件 → 浏览器用 <code>file://</code> 打开</li>\n<li>适合静态页面原型演示</li>\n</ul>\n<h3 id=\"2-✅-Electron-桌面应用\"><a href=\"#2-✅-Electron-桌面应用\" class=\"headerlink\" title=\"2. ✅ Electron &#x2F; 桌面应用\"></a>2. ✅ Electron &#x2F; 桌面应用</h3><ul>\n<li>Electron 应用可以用 <code>file:</code> 加载本地资源</li>\n<li>因为它有更高权限</li>\n</ul>\n<h3 id=\"3-✅-VS-Code-预览\"><a href=\"#3-✅-VS-Code-预览\" class=\"headerlink\" title=\"3. ✅ VS Code 预览\"></a>3. ✅ VS Code 预览</h3><ul>\n<li>VS Code 的 “Open in Browser” 插件会用 <code>file:</code> 协议</li>\n</ul>\n<h3 id=\"4-✅-本地文档查看\"><a href=\"#4-✅-本地文档查看\" class=\"headerlink\" title=\"4. ✅ 本地文档查看\"></a>4. ✅ 本地文档查看</h3><ul>\n<li>本地 Markdown 生成的 HTML 文档</li>\n</ul>\n<hr>\n<h2 id=\"🚫-七、不适合做什么？\"><a href=\"#🚫-七、不适合做什么？\" class=\"headerlink\" title=\"🚫 七、不适合做什么？\"></a>🚫 七、不适合做什么？</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>为什么不行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Web 开发调试</td>\n<td>会有 CORS、模块加载等问题</td>\n</tr>\n<tr>\n<td>使用 npm 包</td>\n<td>无法解析 <code>node_modules</code></td>\n</tr>\n<tr>\n<td>AJAX 请求本地文件</td>\n<td>浏览器禁止</td>\n</tr>\n<tr>\n<td>使用 <code>import</code> 模块</td>\n<td>需要服务器支持</td>\n</tr>\n</tbody></table>\n<p>👉 <strong>开发时建议用本地服务器</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx serve  <span class=\"comment\"># 或 python -m http.server</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔄-八、和其他协议对比\"><a href=\"#🔄-八、和其他协议对比\" class=\"headerlink\" title=\"🔄 八、和其他协议对比\"></a>🔄 八、和其他协议对比</h2><table>\n<thead>\n<tr>\n<th>协议</th>\n<th>示例</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>http://</code></td>\n<td><code>http://example.com</code></td>\n<td>网站（明文）</td>\n</tr>\n<tr>\n<td><code>https://</code></td>\n<td><code>https://google.com</code></td>\n<td>网站（加密）</td>\n</tr>\n<tr>\n<td><code>file://</code></td>\n<td><code>file:///C:/doc.txt</code></td>\n<td>本地文件</td>\n</tr>\n<tr>\n<td><code>data:</code></td>\n<td><code>data:text/plain,Hello</code></td>\n<td>内联数据</td>\n</tr>\n<tr>\n<td><code>blob:</code></td>\n<td><code>blob:https://...</code></td>\n<td>二进制大对象</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-九、总结\"><a href=\"#✅-九、总结\" class=\"headerlink\" title=\"✅ 九、总结\"></a>✅ 九、总结</h2><blockquote>\n<ul>\n<li>✅ <code>file:</code> 协议 &#x3D; 访问<strong>本地文件</strong>的 URL 方式</li>\n<li>✅ 格式：<code>file:///路径</code>（三个斜杠）</li>\n<li>⚠️ 浏览器有安全限制，不能用于复杂 Web 开发</li>\n<li>✅ 适合：预览静态页面、本地文档、桌面应用</li>\n<li>🚫 不适合：开发调试（建议用 <code>http://localhost</code>）</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"💡-小技巧\"><a href=\"#💡-小技巧\" class=\"headerlink\" title=\"💡 小技巧\"></a>💡 小技巧</h2><p>想在浏览器打开本地文件？<br>把文件拖到浏览器标签页，地址栏就会显示 <code>file://...</code>！</p>\n","excerpt":"","more":"<hr>\n<h2 id=\"🎯-一、file-协议是什么？\"><a href=\"#🎯-一、file-协议是什么？\" class=\"headerlink\" title=\"🎯 一、file: 协议是什么？\"></a>🎯 一、<code>file:</code> 协议是什么？</h2><blockquote>\n<p>🔥 <strong>一句话定义</strong>：<br><code>file:</code> 协议是一种 URL 格式，用来指向你<strong>本地硬盘上的文件</strong>，就像文件资源管理器的路径一样。</p>\n</blockquote>\n<hr>\n<h2 id=\"📁-二、基本语法\"><a href=\"#📁-二、基本语法\" class=\"headerlink\" title=\"📁 二、基本语法\"></a>📁 二、基本语法</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file:[//&lt;host&gt;]&lt;path&gt;</span><br><span class=\"line\">     └──┬───┘ └──┬──┘</span><br><span class=\"line\">        │       └── 路径（必须）</span><br><span class=\"line\">        └───────── 主机名（可选）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见形式：\"><a href=\"#常见形式：\" class=\"headerlink\" title=\"常见形式：\"></a>常见形式：</h3><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file:///路径</code></td>\n<td>本地文件（最常见）</td>\n<td><code>file:///C:/Users/Alice/docs/hello.txt</code></td>\n</tr>\n<tr>\n<td><code>file://主机名/路径</code></td>\n<td>网络共享文件（少见）</td>\n<td><code>file://server/shared/report.pdf</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ 三个斜杠 <code>///</code>：前两个是 语法中的<code>://</code>，第三个表示“根目录”</p>\n</blockquote>\n<hr>\n<h2 id=\"🌰-三、实际例子\"><a href=\"#🌰-三、实际例子\" class=\"headerlink\" title=\"🌰 三、实际例子\"></a>🌰 三、实际例子</h2><h3 id=\"1-打开本地-HTML-文件\"><a href=\"#1-打开本地-HTML-文件\" class=\"headerlink\" title=\"1. 打开本地 HTML 文件\"></a>1. 打开本地 HTML 文件</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file:///Users/Alice/project/index.html</span><br></pre></td></tr></table></figure>\n\n<p>👉 在浏览器地址栏输入，就能打开你电脑上的 <code>index.html</code></p>\n<h3 id=\"2-引用本地图片\"><a href=\"#2-引用本地图片\" class=\"headerlink\" title=\"2. 引用本地图片\"></a>2. 引用本地图片</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;file:///Users/Alice/Pictures/photo.jpg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Node-js-中使用\"><a href=\"#3-Node-js-中使用\" class=\"headerlink\" title=\"3. Node.js 中使用\"></a>3. Node.js 中使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"string\">&#x27;file:///Users/Alice/data.json&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>).<span class=\"title function_\">readFileSync</span>(url.<span class=\"title function_\">slice</span>(<span class=\"number\">7</span>)); <span class=\"comment\">// 去掉 file://</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧩-四、和普通路径的区别\"><a href=\"#🧩-四、和普通路径的区别\" class=\"headerlink\" title=\"🧩 四、和普通路径的区别\"></a>🧩 四、和普通路径的区别</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>普通文件路径</td>\n<td><code>C:\\Users\\Alice\\file.txt</code></td>\n<td>操作系统用</td>\n</tr>\n<tr>\n<td><code>file:</code> URL</td>\n<td><code>file:///C:/Users/Alice/file.txt</code></td>\n<td>浏览器&#x2F;程序用的标准格式</td>\n</tr>\n<tr>\n<td>相对路径</td>\n<td><code>./docs/file.txt</code></td>\n<td>相对于当前目录</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ <code>file:</code> 是 <strong>跨平台的标准 URL 格式</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"🔐-五、浏览器中的安全限制-⚠️\"><a href=\"#🔐-五、浏览器中的安全限制-⚠️\" class=\"headerlink\" title=\"🔐 五、浏览器中的安全限制 ⚠️\"></a>🔐 五、浏览器中的安全限制 ⚠️</h2><p>虽然你可以用 <code>file:</code> 打开本地文件，但现代浏览器有严格限制：</p>\n<h3 id=\"❌-不能做什么？\"><a href=\"#❌-不能做什么？\" class=\"headerlink\" title=\"❌ 不能做什么？\"></a>❌ 不能做什么？</h3><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>是否允许</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file:///</code> 页面加载 <code>file:///</code> 脚本</td>\n<td>❌ 通常禁止</td>\n<td>安全策略</td>\n</tr>\n<tr>\n<td><code>file:///</code> 页面发起 AJAX 请求</td>\n<td>❌ 禁止</td>\n<td>不能读本地文件</td>\n</tr>\n<tr>\n<td><code>file:///</code> 页面使用 <code>import</code> 加载本地模块</td>\n<td>❌ 大多数浏览器禁止</td>\n<td>CORS 限制</td>\n</tr>\n</tbody></table>\n<h3 id=\"✅-能做什么？\"><a href=\"#✅-能做什么？\" class=\"headerlink\" title=\"✅ 能做什么？\"></a>✅ 能做什么？</h3><ul>\n<li>直接打开 <code>file:///index.html</code> 查看静态页面</li>\n<li>页面引用同目录的图片、CSS（有时允许）</li>\n<li>本地测试简单 HTML（无 JS 交互）</li>\n</ul>\n<hr>\n<h2 id=\"🛠️-六、实际用途\"><a href=\"#🛠️-六、实际用途\" class=\"headerlink\" title=\"🛠️ 六、实际用途\"></a>🛠️ 六、实际用途</h2><h3 id=\"1-✅-快速预览-HTML-文件\"><a href=\"#1-✅-快速预览-HTML-文件\" class=\"headerlink\" title=\"1. ✅ 快速预览 HTML 文件\"></a>1. ✅ 快速预览 HTML 文件</h3><ul>\n<li>双击 <code>.html</code> 文件 → 浏览器用 <code>file://</code> 打开</li>\n<li>适合静态页面原型演示</li>\n</ul>\n<h3 id=\"2-✅-Electron-桌面应用\"><a href=\"#2-✅-Electron-桌面应用\" class=\"headerlink\" title=\"2. ✅ Electron &#x2F; 桌面应用\"></a>2. ✅ Electron &#x2F; 桌面应用</h3><ul>\n<li>Electron 应用可以用 <code>file:</code> 加载本地资源</li>\n<li>因为它有更高权限</li>\n</ul>\n<h3 id=\"3-✅-VS-Code-预览\"><a href=\"#3-✅-VS-Code-预览\" class=\"headerlink\" title=\"3. ✅ VS Code 预览\"></a>3. ✅ VS Code 预览</h3><ul>\n<li>VS Code 的 “Open in Browser” 插件会用 <code>file:</code> 协议</li>\n</ul>\n<h3 id=\"4-✅-本地文档查看\"><a href=\"#4-✅-本地文档查看\" class=\"headerlink\" title=\"4. ✅ 本地文档查看\"></a>4. ✅ 本地文档查看</h3><ul>\n<li>本地 Markdown 生成的 HTML 文档</li>\n</ul>\n<hr>\n<h2 id=\"🚫-七、不适合做什么？\"><a href=\"#🚫-七、不适合做什么？\" class=\"headerlink\" title=\"🚫 七、不适合做什么？\"></a>🚫 七、不适合做什么？</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>为什么不行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Web 开发调试</td>\n<td>会有 CORS、模块加载等问题</td>\n</tr>\n<tr>\n<td>使用 npm 包</td>\n<td>无法解析 <code>node_modules</code></td>\n</tr>\n<tr>\n<td>AJAX 请求本地文件</td>\n<td>浏览器禁止</td>\n</tr>\n<tr>\n<td>使用 <code>import</code> 模块</td>\n<td>需要服务器支持</td>\n</tr>\n</tbody></table>\n<p>👉 <strong>开发时建议用本地服务器</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx serve  <span class=\"comment\"># 或 python -m http.server</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔄-八、和其他协议对比\"><a href=\"#🔄-八、和其他协议对比\" class=\"headerlink\" title=\"🔄 八、和其他协议对比\"></a>🔄 八、和其他协议对比</h2><table>\n<thead>\n<tr>\n<th>协议</th>\n<th>示例</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>http://</code></td>\n<td><code>http://example.com</code></td>\n<td>网站（明文）</td>\n</tr>\n<tr>\n<td><code>https://</code></td>\n<td><code>https://google.com</code></td>\n<td>网站（加密）</td>\n</tr>\n<tr>\n<td><code>file://</code></td>\n<td><code>file:///C:/doc.txt</code></td>\n<td>本地文件</td>\n</tr>\n<tr>\n<td><code>data:</code></td>\n<td><code>data:text/plain,Hello</code></td>\n<td>内联数据</td>\n</tr>\n<tr>\n<td><code>blob:</code></td>\n<td><code>blob:https://...</code></td>\n<td>二进制大对象</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-九、总结\"><a href=\"#✅-九、总结\" class=\"headerlink\" title=\"✅ 九、总结\"></a>✅ 九、总结</h2><blockquote>\n<ul>\n<li>✅ <code>file:</code> 协议 &#x3D; 访问<strong>本地文件</strong>的 URL 方式</li>\n<li>✅ 格式：<code>file:///路径</code>（三个斜杠）</li>\n<li>⚠️ 浏览器有安全限制，不能用于复杂 Web 开发</li>\n<li>✅ 适合：预览静态页面、本地文档、桌面应用</li>\n<li>🚫 不适合：开发调试（建议用 <code>http://localhost</code>）</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"💡-小技巧\"><a href=\"#💡-小技巧\" class=\"headerlink\" title=\"💡 小技巧\"></a>💡 小技巧</h2><p>想在浏览器打开本地文件？<br>把文件拖到浏览器标签页，地址栏就会显示 <code>file://...</code>！</p>\n"},{"title":"硬链接和软链接","_content":"\n> 硬链接（Hard Link）是文件系统中一种特殊的机制，它允许**同一个文件在文件系统中拥有多个文件名（或路径）**。你可以把它理解为文件数据的“别名”或“多个入口”。\n\n### 核心概念\n\n1.  **指向数据，而非文件名**：\n    *   在大多数现代文件系统（如 NTFS, ext4）中，文件数据存储在磁盘的某个物理位置。\n    *   文件名（或路径）只是一个指向这些实际数据的“指针”或“入口”。\n    *   一个**硬链接**就是创建一个**新的文件名（路径）**，但它指向的是**同一个文件数据块**，而不是复制数据。\n\n2.  **共享数据**：\n    *   通过硬链接创建的多个文件名，它们共享完全相同的数据。\n    *   无论你通过哪个名字去读取或修改文件内容，看到的都是同一份数据。修改其中一个，其他所有硬链接也会立即反映出这些修改。\n\n3.  **没有“原文件”和“链接文件”之分**：\n    *   与“快捷方式”或“符号链接”不同，硬链接之间是**完全平等**的。\n    *   你无法区分哪个是“原始”文件，哪个是“链接”。它们都是文件数据的有效入口。\n\n4.  **删除行为**：\n    *   删除一个硬链接（即删除一个文件名），**并不会删除文件数据本身**。\n    *   文件数据会一直保留，直到**所有指向它的硬链接都被删除**。\n    *   文件系统通过一个“**链接计数**”（link count）来跟踪有多少个硬链接指向该数据。只有当链接计数降为0时，文件数据才会被真正释放（删除）。\n\n### 与符号链接（Symbolic Link / Soft Link）的区别\n\n这是最容易混淆的概念，理解它们的区别很重要：\n\n| 特性         | 硬链接 (Hard Link)                          | 符号链接 (Symbolic Link / Soft Link)          |\n| :----------- | :------------------------------------------ | :-------------------------------------------- |\n| **本质**     | 指向文件的**数据块**                         | 指向文件的**路径名**（一个包含路径的文本文件） |\n| **跨文件系统** | 通常**不能**跨不同的文件系统或磁盘分区         | **可以**跨文件系统或磁盘分区                    |\n| **目标删除** | 删除目标文件后，硬链接**仍然可以访问数据**（数据未删） | 删除目标文件后，符号链接变成“**悬空链接**”（失效） |\n| **目录支持** | 通常**不允许**为目录创建硬链接（防止循环）     | **可以**为目录创建符号链接                     |\n| **文件类型** | 只能链接到**文件**                           | 可以链接到**文件或目录**                       |\n| **inode**    | 所有硬链接共享**同一个 inode**（文件系统标识） | 符号链接有自己独立的 inode，指向目标的 inode    |\n\n### 举个例子\n\n想象一个文件 `original.txt`，内容是 \"Hello World\"。\n\n*   **创建硬链接**：你创建了一个硬链接 `link.txt` 指向 `original.txt`。\n    *   现在，`original.txt` 和 `link.txt` 都指向硬盘上存储 \"Hello World\" 的那块数据。\n    *   用 `cat original.txt` 和 `cat link.txt` 都会输出 \"Hello World\"。\n    *   如果你用 `echo \"New content\" > link.txt` 修改了 `link.txt`，那么 `original.txt` 的内容也会变成 \"New content\"。\n    *   如果你删除 `original.txt`，`link.txt` 依然存在且可以正常读写，数据不会丢失。\n*   **创建符号链接**：你创建了一个符号链接 `symlink.txt` 指向 `original.txt`。\n    *   `symlink.txt` 本身是一个小文件，里面只存着字符串 \"original.txt\"。\n    *   当你访问 `symlink.txt` 时，系统会先读取这个小文件，得知它指向 `original.txt`，然后再去打开 `original.txt`。\n    *   如果你删除了 `original.txt`，那么 `symlink.txt` 就变成了一个无效的链接，访问它会出错（\"No such file or directory\"）。\n\n### 在 pnpm 中的应用\n\n`pnpm` 利用硬链接的特性来实现高效的依赖管理：\n\n1.  **全局存储**：`pnpm` 将下载的包（如 `lodash@1.0.0`）解压后，存储在全局的、内容可寻址的存储区（如 `~/.pnpm-store`）的一个固定位置。\n2.  **创建硬链接**：当你的项目需要 `lodash@1.0.0` 时，`pnpm` 不会复制整个 `lodash` 文件夹到你的 `node_modules`，而是**在你的 `node_modules` 目录下创建一个指向全局存储中 `lodash@1.0.0` 数据的硬链接**。\n3.  **节省空间**：即使有100个项目都使用 `lodash@1.0.0`，磁盘上也只有一份 `lodash` 的数据，`node_modules` 里的 `lodash` 文件夹都是指向这份数据的硬链接，从而极大地节省了磁盘空间。\n4.  **速度**：创建硬链接是一个非常快速的文件系统操作（只是创建一个新目录项），远快于复制整个文件夹。\n\n**总结**：硬链接是一种让多个文件名共享同一份数据的技术。`pnpm` 通过它实现了依赖的“一次存储，多处链接”，这是其高效节省空间和快速安装的核心原因之一。","source":"_posts/软链接和硬链接.md","raw":"---\ntitle: 硬链接和软链接\n---\n\n> 硬链接（Hard Link）是文件系统中一种特殊的机制，它允许**同一个文件在文件系统中拥有多个文件名（或路径）**。你可以把它理解为文件数据的“别名”或“多个入口”。\n\n### 核心概念\n\n1.  **指向数据，而非文件名**：\n    *   在大多数现代文件系统（如 NTFS, ext4）中，文件数据存储在磁盘的某个物理位置。\n    *   文件名（或路径）只是一个指向这些实际数据的“指针”或“入口”。\n    *   一个**硬链接**就是创建一个**新的文件名（路径）**，但它指向的是**同一个文件数据块**，而不是复制数据。\n\n2.  **共享数据**：\n    *   通过硬链接创建的多个文件名，它们共享完全相同的数据。\n    *   无论你通过哪个名字去读取或修改文件内容，看到的都是同一份数据。修改其中一个，其他所有硬链接也会立即反映出这些修改。\n\n3.  **没有“原文件”和“链接文件”之分**：\n    *   与“快捷方式”或“符号链接”不同，硬链接之间是**完全平等**的。\n    *   你无法区分哪个是“原始”文件，哪个是“链接”。它们都是文件数据的有效入口。\n\n4.  **删除行为**：\n    *   删除一个硬链接（即删除一个文件名），**并不会删除文件数据本身**。\n    *   文件数据会一直保留，直到**所有指向它的硬链接都被删除**。\n    *   文件系统通过一个“**链接计数**”（link count）来跟踪有多少个硬链接指向该数据。只有当链接计数降为0时，文件数据才会被真正释放（删除）。\n\n### 与符号链接（Symbolic Link / Soft Link）的区别\n\n这是最容易混淆的概念，理解它们的区别很重要：\n\n| 特性         | 硬链接 (Hard Link)                          | 符号链接 (Symbolic Link / Soft Link)          |\n| :----------- | :------------------------------------------ | :-------------------------------------------- |\n| **本质**     | 指向文件的**数据块**                         | 指向文件的**路径名**（一个包含路径的文本文件） |\n| **跨文件系统** | 通常**不能**跨不同的文件系统或磁盘分区         | **可以**跨文件系统或磁盘分区                    |\n| **目标删除** | 删除目标文件后，硬链接**仍然可以访问数据**（数据未删） | 删除目标文件后，符号链接变成“**悬空链接**”（失效） |\n| **目录支持** | 通常**不允许**为目录创建硬链接（防止循环）     | **可以**为目录创建符号链接                     |\n| **文件类型** | 只能链接到**文件**                           | 可以链接到**文件或目录**                       |\n| **inode**    | 所有硬链接共享**同一个 inode**（文件系统标识） | 符号链接有自己独立的 inode，指向目标的 inode    |\n\n### 举个例子\n\n想象一个文件 `original.txt`，内容是 \"Hello World\"。\n\n*   **创建硬链接**：你创建了一个硬链接 `link.txt` 指向 `original.txt`。\n    *   现在，`original.txt` 和 `link.txt` 都指向硬盘上存储 \"Hello World\" 的那块数据。\n    *   用 `cat original.txt` 和 `cat link.txt` 都会输出 \"Hello World\"。\n    *   如果你用 `echo \"New content\" > link.txt` 修改了 `link.txt`，那么 `original.txt` 的内容也会变成 \"New content\"。\n    *   如果你删除 `original.txt`，`link.txt` 依然存在且可以正常读写，数据不会丢失。\n*   **创建符号链接**：你创建了一个符号链接 `symlink.txt` 指向 `original.txt`。\n    *   `symlink.txt` 本身是一个小文件，里面只存着字符串 \"original.txt\"。\n    *   当你访问 `symlink.txt` 时，系统会先读取这个小文件，得知它指向 `original.txt`，然后再去打开 `original.txt`。\n    *   如果你删除了 `original.txt`，那么 `symlink.txt` 就变成了一个无效的链接，访问它会出错（\"No such file or directory\"）。\n\n### 在 pnpm 中的应用\n\n`pnpm` 利用硬链接的特性来实现高效的依赖管理：\n\n1.  **全局存储**：`pnpm` 将下载的包（如 `lodash@1.0.0`）解压后，存储在全局的、内容可寻址的存储区（如 `~/.pnpm-store`）的一个固定位置。\n2.  **创建硬链接**：当你的项目需要 `lodash@1.0.0` 时，`pnpm` 不会复制整个 `lodash` 文件夹到你的 `node_modules`，而是**在你的 `node_modules` 目录下创建一个指向全局存储中 `lodash@1.0.0` 数据的硬链接**。\n3.  **节省空间**：即使有100个项目都使用 `lodash@1.0.0`，磁盘上也只有一份 `lodash` 的数据，`node_modules` 里的 `lodash` 文件夹都是指向这份数据的硬链接，从而极大地节省了磁盘空间。\n4.  **速度**：创建硬链接是一个非常快速的文件系统操作（只是创建一个新目录项），远快于复制整个文件夹。\n\n**总结**：硬链接是一种让多个文件名共享同一份数据的技术。`pnpm` 通过它实现了依赖的“一次存储，多处链接”，这是其高效节省空间和快速安装的核心原因之一。","slug":"软链接和硬链接","published":1,"date":"2025-09-02T01:50:34.944Z","updated":"2025-09-01T09:54:01.771Z","_id":"cmf1wun9c000uq4v9b79j388w","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>硬链接（Hard Link）是文件系统中一种特殊的机制，它允许<strong>同一个文件在文件系统中拥有多个文件名（或路径）</strong>。你可以把它理解为文件数据的“别名”或“多个入口”。</p>\n</blockquote>\n<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><ol>\n<li><p><strong>指向数据，而非文件名</strong>：</p>\n<ul>\n<li>在大多数现代文件系统（如 NTFS, ext4）中，文件数据存储在磁盘的某个物理位置。</li>\n<li>文件名（或路径）只是一个指向这些实际数据的“指针”或“入口”。</li>\n<li>一个<strong>硬链接</strong>就是创建一个<strong>新的文件名（路径）</strong>，但它指向的是<strong>同一个文件数据块</strong>，而不是复制数据。</li>\n</ul>\n</li>\n<li><p><strong>共享数据</strong>：</p>\n<ul>\n<li>通过硬链接创建的多个文件名，它们共享完全相同的数据。</li>\n<li>无论你通过哪个名字去读取或修改文件内容，看到的都是同一份数据。修改其中一个，其他所有硬链接也会立即反映出这些修改。</li>\n</ul>\n</li>\n<li><p><strong>没有“原文件”和“链接文件”之分</strong>：</p>\n<ul>\n<li>与“快捷方式”或“符号链接”不同，硬链接之间是<strong>完全平等</strong>的。</li>\n<li>你无法区分哪个是“原始”文件，哪个是“链接”。它们都是文件数据的有效入口。</li>\n</ul>\n</li>\n<li><p><strong>删除行为</strong>：</p>\n<ul>\n<li>删除一个硬链接（即删除一个文件名），<strong>并不会删除文件数据本身</strong>。</li>\n<li>文件数据会一直保留，直到<strong>所有指向它的硬链接都被删除</strong>。</li>\n<li>文件系统通过一个“<strong>链接计数</strong>”（link count）来跟踪有多少个硬链接指向该数据。只有当链接计数降为0时，文件数据才会被真正释放（删除）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"与符号链接（Symbolic-Link-Soft-Link）的区别\"><a href=\"#与符号链接（Symbolic-Link-Soft-Link）的区别\" class=\"headerlink\" title=\"与符号链接（Symbolic Link &#x2F; Soft Link）的区别\"></a>与符号链接（Symbolic Link &#x2F; Soft Link）的区别</h3><p>这是最容易混淆的概念，理解它们的区别很重要：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">硬链接 (Hard Link)</th>\n<th align=\"left\">符号链接 (Symbolic Link &#x2F; Soft Link)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>本质</strong></td>\n<td align=\"left\">指向文件的<strong>数据块</strong></td>\n<td align=\"left\">指向文件的<strong>路径名</strong>（一个包含路径的文本文件）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>跨文件系统</strong></td>\n<td align=\"left\">通常<strong>不能</strong>跨不同的文件系统或磁盘分区</td>\n<td align=\"left\"><strong>可以</strong>跨文件系统或磁盘分区</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>目标删除</strong></td>\n<td align=\"left\">删除目标文件后，硬链接<strong>仍然可以访问数据</strong>（数据未删）</td>\n<td align=\"left\">删除目标文件后，符号链接变成“<strong>悬空链接</strong>”（失效）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>目录支持</strong></td>\n<td align=\"left\">通常<strong>不允许</strong>为目录创建硬链接（防止循环）</td>\n<td align=\"left\"><strong>可以</strong>为目录创建符号链接</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>文件类型</strong></td>\n<td align=\"left\">只能链接到<strong>文件</strong></td>\n<td align=\"left\">可以链接到<strong>文件或目录</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>inode</strong></td>\n<td align=\"left\">所有硬链接共享<strong>同一个 inode</strong>（文件系统标识）</td>\n<td align=\"left\">符号链接有自己独立的 inode，指向目标的 inode</td>\n</tr>\n</tbody></table>\n<h3 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h3><p>想象一个文件 <code>original.txt</code>，内容是 “Hello World”。</p>\n<ul>\n<li><strong>创建硬链接</strong>：你创建了一个硬链接 <code>link.txt</code> 指向 <code>original.txt</code>。<ul>\n<li>现在，<code>original.txt</code> 和 <code>link.txt</code> 都指向硬盘上存储 “Hello World” 的那块数据。</li>\n<li>用 <code>cat original.txt</code> 和 <code>cat link.txt</code> 都会输出 “Hello World”。</li>\n<li>如果你用 <code>echo &quot;New content&quot; &gt; link.txt</code> 修改了 <code>link.txt</code>，那么 <code>original.txt</code> 的内容也会变成 “New content”。</li>\n<li>如果你删除 <code>original.txt</code>，<code>link.txt</code> 依然存在且可以正常读写，数据不会丢失。</li>\n</ul>\n</li>\n<li><strong>创建符号链接</strong>：你创建了一个符号链接 <code>symlink.txt</code> 指向 <code>original.txt</code>。<ul>\n<li><code>symlink.txt</code> 本身是一个小文件，里面只存着字符串 “original.txt”。</li>\n<li>当你访问 <code>symlink.txt</code> 时，系统会先读取这个小文件，得知它指向 <code>original.txt</code>，然后再去打开 <code>original.txt</code>。</li>\n<li>如果你删除了 <code>original.txt</code>，那么 <code>symlink.txt</code> 就变成了一个无效的链接，访问它会出错（”No such file or directory”）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在-pnpm-中的应用\"><a href=\"#在-pnpm-中的应用\" class=\"headerlink\" title=\"在 pnpm 中的应用\"></a>在 pnpm 中的应用</h3><p><code>pnpm</code> 利用硬链接的特性来实现高效的依赖管理：</p>\n<ol>\n<li><strong>全局存储</strong>：<code>pnpm</code> 将下载的包（如 <code>lodash@1.0.0</code>）解压后，存储在全局的、内容可寻址的存储区（如 <code>~/.pnpm-store</code>）的一个固定位置。</li>\n<li><strong>创建硬链接</strong>：当你的项目需要 <code>lodash@1.0.0</code> 时，<code>pnpm</code> 不会复制整个 <code>lodash</code> 文件夹到你的 <code>node_modules</code>，而是<strong>在你的 <code>node_modules</code> 目录下创建一个指向全局存储中 <code>lodash@1.0.0</code> 数据的硬链接</strong>。</li>\n<li><strong>节省空间</strong>：即使有100个项目都使用 <code>lodash@1.0.0</code>，磁盘上也只有一份 <code>lodash</code> 的数据，<code>node_modules</code> 里的 <code>lodash</code> 文件夹都是指向这份数据的硬链接，从而极大地节省了磁盘空间。</li>\n<li><strong>速度</strong>：创建硬链接是一个非常快速的文件系统操作（只是创建一个新目录项），远快于复制整个文件夹。</li>\n</ol>\n<p><strong>总结</strong>：硬链接是一种让多个文件名共享同一份数据的技术。<code>pnpm</code> 通过它实现了依赖的“一次存储，多处链接”，这是其高效节省空间和快速安装的核心原因之一。</p>\n","excerpt":"","more":"<blockquote>\n<p>硬链接（Hard Link）是文件系统中一种特殊的机制，它允许<strong>同一个文件在文件系统中拥有多个文件名（或路径）</strong>。你可以把它理解为文件数据的“别名”或“多个入口”。</p>\n</blockquote>\n<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><ol>\n<li><p><strong>指向数据，而非文件名</strong>：</p>\n<ul>\n<li>在大多数现代文件系统（如 NTFS, ext4）中，文件数据存储在磁盘的某个物理位置。</li>\n<li>文件名（或路径）只是一个指向这些实际数据的“指针”或“入口”。</li>\n<li>一个<strong>硬链接</strong>就是创建一个<strong>新的文件名（路径）</strong>，但它指向的是<strong>同一个文件数据块</strong>，而不是复制数据。</li>\n</ul>\n</li>\n<li><p><strong>共享数据</strong>：</p>\n<ul>\n<li>通过硬链接创建的多个文件名，它们共享完全相同的数据。</li>\n<li>无论你通过哪个名字去读取或修改文件内容，看到的都是同一份数据。修改其中一个，其他所有硬链接也会立即反映出这些修改。</li>\n</ul>\n</li>\n<li><p><strong>没有“原文件”和“链接文件”之分</strong>：</p>\n<ul>\n<li>与“快捷方式”或“符号链接”不同，硬链接之间是<strong>完全平等</strong>的。</li>\n<li>你无法区分哪个是“原始”文件，哪个是“链接”。它们都是文件数据的有效入口。</li>\n</ul>\n</li>\n<li><p><strong>删除行为</strong>：</p>\n<ul>\n<li>删除一个硬链接（即删除一个文件名），<strong>并不会删除文件数据本身</strong>。</li>\n<li>文件数据会一直保留，直到<strong>所有指向它的硬链接都被删除</strong>。</li>\n<li>文件系统通过一个“<strong>链接计数</strong>”（link count）来跟踪有多少个硬链接指向该数据。只有当链接计数降为0时，文件数据才会被真正释放（删除）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"与符号链接（Symbolic-Link-Soft-Link）的区别\"><a href=\"#与符号链接（Symbolic-Link-Soft-Link）的区别\" class=\"headerlink\" title=\"与符号链接（Symbolic Link &#x2F; Soft Link）的区别\"></a>与符号链接（Symbolic Link &#x2F; Soft Link）的区别</h3><p>这是最容易混淆的概念，理解它们的区别很重要：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">硬链接 (Hard Link)</th>\n<th align=\"left\">符号链接 (Symbolic Link &#x2F; Soft Link)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>本质</strong></td>\n<td align=\"left\">指向文件的<strong>数据块</strong></td>\n<td align=\"left\">指向文件的<strong>路径名</strong>（一个包含路径的文本文件）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>跨文件系统</strong></td>\n<td align=\"left\">通常<strong>不能</strong>跨不同的文件系统或磁盘分区</td>\n<td align=\"left\"><strong>可以</strong>跨文件系统或磁盘分区</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>目标删除</strong></td>\n<td align=\"left\">删除目标文件后，硬链接<strong>仍然可以访问数据</strong>（数据未删）</td>\n<td align=\"left\">删除目标文件后，符号链接变成“<strong>悬空链接</strong>”（失效）</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>目录支持</strong></td>\n<td align=\"left\">通常<strong>不允许</strong>为目录创建硬链接（防止循环）</td>\n<td align=\"left\"><strong>可以</strong>为目录创建符号链接</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>文件类型</strong></td>\n<td align=\"left\">只能链接到<strong>文件</strong></td>\n<td align=\"left\">可以链接到<strong>文件或目录</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>inode</strong></td>\n<td align=\"left\">所有硬链接共享<strong>同一个 inode</strong>（文件系统标识）</td>\n<td align=\"left\">符号链接有自己独立的 inode，指向目标的 inode</td>\n</tr>\n</tbody></table>\n<h3 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h3><p>想象一个文件 <code>original.txt</code>，内容是 “Hello World”。</p>\n<ul>\n<li><strong>创建硬链接</strong>：你创建了一个硬链接 <code>link.txt</code> 指向 <code>original.txt</code>。<ul>\n<li>现在，<code>original.txt</code> 和 <code>link.txt</code> 都指向硬盘上存储 “Hello World” 的那块数据。</li>\n<li>用 <code>cat original.txt</code> 和 <code>cat link.txt</code> 都会输出 “Hello World”。</li>\n<li>如果你用 <code>echo &quot;New content&quot; &gt; link.txt</code> 修改了 <code>link.txt</code>，那么 <code>original.txt</code> 的内容也会变成 “New content”。</li>\n<li>如果你删除 <code>original.txt</code>，<code>link.txt</code> 依然存在且可以正常读写，数据不会丢失。</li>\n</ul>\n</li>\n<li><strong>创建符号链接</strong>：你创建了一个符号链接 <code>symlink.txt</code> 指向 <code>original.txt</code>。<ul>\n<li><code>symlink.txt</code> 本身是一个小文件，里面只存着字符串 “original.txt”。</li>\n<li>当你访问 <code>symlink.txt</code> 时，系统会先读取这个小文件，得知它指向 <code>original.txt</code>，然后再去打开 <code>original.txt</code>。</li>\n<li>如果你删除了 <code>original.txt</code>，那么 <code>symlink.txt</code> 就变成了一个无效的链接，访问它会出错（”No such file or directory”）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在-pnpm-中的应用\"><a href=\"#在-pnpm-中的应用\" class=\"headerlink\" title=\"在 pnpm 中的应用\"></a>在 pnpm 中的应用</h3><p><code>pnpm</code> 利用硬链接的特性来实现高效的依赖管理：</p>\n<ol>\n<li><strong>全局存储</strong>：<code>pnpm</code> 将下载的包（如 <code>lodash@1.0.0</code>）解压后，存储在全局的、内容可寻址的存储区（如 <code>~/.pnpm-store</code>）的一个固定位置。</li>\n<li><strong>创建硬链接</strong>：当你的项目需要 <code>lodash@1.0.0</code> 时，<code>pnpm</code> 不会复制整个 <code>lodash</code> 文件夹到你的 <code>node_modules</code>，而是<strong>在你的 <code>node_modules</code> 目录下创建一个指向全局存储中 <code>lodash@1.0.0</code> 数据的硬链接</strong>。</li>\n<li><strong>节省空间</strong>：即使有100个项目都使用 <code>lodash@1.0.0</code>，磁盘上也只有一份 <code>lodash</code> 的数据，<code>node_modules</code> 里的 <code>lodash</code> 文件夹都是指向这份数据的硬链接，从而极大地节省了磁盘空间。</li>\n<li><strong>速度</strong>：创建硬链接是一个非常快速的文件系统操作（只是创建一个新目录项），远快于复制整个文件夹。</li>\n</ol>\n<p><strong>总结</strong>：硬链接是一种让多个文件名共享同一份数据的技术。<code>pnpm</code> 通过它实现了依赖的“一次存储，多处链接”，这是其高效节省空间和快速安装的核心原因之一。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[{"name":"hexo","_id":"cmf1z5gfr00018sv9af11d4gl"},{"name":"next","_id":"cmf1z5gft00028sv9225y6seu"}]}}